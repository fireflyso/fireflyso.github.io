<hr>
<p>title: python基础 – 函数特性<br>categories:</p>
<ul>
<li>python</li>
<li>python基础<br>tags:</li>
<li>python</li>
<li>python基础</li>
</ul>
<hr>
<h1 id="函数作为对象使用"><a href="#函数作为对象使用" class="headerlink" title="函数作为对象使用"></a>函数作为对象使用</h1><ul>
<li>python中一切皆为对象，函数也是对象，有很多离谱操作</li>
<li>赋值给变量</li>
<li>作为另一个函数的实参</li>
<li>作为函数的返回值</li>
<li>嵌套定义值另一个函数中</li>
</ul>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><pre><code>def add(num1, num2):
    return num1 + num2


print(add(1, 2))

print((lambda num1, num2: num1 + num2)(1, 2))

le = lambda num1, num2: num1 + num2
print(le(1, 2))

result = map(lambda x: x * x, [1, 2, 3, 4])
print(list(result))


def do_sth():
    return lambda num1, num2: num1 + num2


print(do_sth()(1, 2))
</code></pre>
<ul>
<li>相当于是一个匿名函数，同样是一个对象，也可以像函数那样用</li>
</ul>
<h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><pre><code>from functools import partial


def f(a, b=5):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b)


f_new = partial(f, 2)

f_new()
f_new(6)
f_new(b=6)


# f_new(a = 3)    


def eval_sum(*args):
    s = 0
    for n in args:
        s += n
    return s


eval_sum_new = partial(eval_sum, 20, 30)
print(eval_sum_new(1, 2, 3, 4, 5))

def f1(a, b=5, *args, **kwargs):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;args =&#39;, args, &#39;kwargs =&#39;, kwargs)


f1_new = partial(f1, 1, 3, 6, m=8)
f1_new(2, 4, n=9)


def f2(a, b=5, *, c, **kwargs):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;kwargs =&#39;, kwargs)


f2_new = partial(f2, 1, m=8)
f2_new(3, c=9)
</code></pre>
<ul>
<li>python可以为函数指定默认参数</li>
<li>一个函数定义的时候没有指定默认值，但后续使用的时候想给其指定，可以使用偏函数来实现</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><pre><code>def outer():
    a = 10

    def inner():
        print(a)

    return inner


def do_sth():
    temp = 8
    print(temp)


do_sth()
# print(temp)

outer_result = outer()
outer_result()
outer()()

print(outer_result.__closure__)
print(outer_result.__closure__[0].cell_contents)
</code></pre>
<ul>
<li>正常情况下，函数被调用后，函数内部声明的变量就会失效</li>
<li>如果一个函数的内部函数引用了外部函数，且外部函数的返回值是内部函数，这个种情况叫闭包，被内部函数引用的变量可以在内部函数特殊属性__closure__中找到</li>
</ul>
<pre><code>def outer2():
    a = 10

    def inner2():
        # a = 11

        # a += 1

        pass

    return inner2


def outer3():
    a = [3]

    def inner3():
        # a = [1]

        a[0] = 8

        print(a)

    return inner3


outer3()()


def outer4():
    a = 10

    def inner4():
        nonlocal a

        # a = 11
        a += 1

        print(a)

    return inner4


outer4_result = outer4()
outer4_result()

outer4_result()
</code></pre>
<ul>
<li>内部函数不能对外部函数的不可变类型的变量进行修改，只会进行覆盖，如果要进行修改需要使用nonlocal关键字来声明对外部函数变量进行使用</li>
<li>闭包的内部函数持有了外部函数的资源，使其在脱离了外部函数之后还可以独立的运行，具体的使用场景后续再探索</li>
</ul>
<h1 id="globals-和locals"><a href="#globals-和locals" class="headerlink" title="globals()和locals()"></a>globals()和locals()</h1><pre><code>def outer(a):
    b = 8

    def inner(c):
        d = 3

    print(locals()) # {&#39;a&#39;: 5, &#39;b&#39;: 8, &#39;inner&#39;: &lt;function outer.&lt;locals&gt;.inner at 0x107fd94c0&gt;}


outer(5)

g = 2


class MyClass(object):
    pass


print(globals())    # {&#39;__name__&#39;: &#39;__main__&#39; ... &#39;outer&#39;: &lt;function outer at 0x107fd9670&gt;, &#39;g&#39;: 2, &#39;MyClass&#39;: &lt;class &#39;__main__.MyClass&#39;&gt;}
</code></pre>
<ul>
<li>都是返回各自作用域中所有的对象类型和value，注意函数也是对象所以也被返回了</li>
<li>globals中打印了object中的资源所以有很多数据</li>
</ul>
<pre><code>def f():
    x = 8
    print(locals())

    locals()[&#39;x&#39;] = 9
    locals()[&#39;y&#39;] = 10

    print(locals())


f()
g = 2
globals()[&#39;g&#39;] = 6
globals()[&#39;gg&#39;] = 66

print(globals())
</code></pre>
<ul>
<li>locals返回的是值拷贝，所以通过locals无法修改资源，但是可以通过映射添加新资源</li>
<li>globals返回的是真实的命名空间（数据名和数值），通过globals做的任何修改都会生效</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul>
<li>上面说到的闭包的作用域比较特殊</li>
<li>还有就是python2和3中列表推导的差异，3中列表推导相当于一个函数有独立的作用域，注意for-in语句一直没有独立作用域</li>
</ul>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1>