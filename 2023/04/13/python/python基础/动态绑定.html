<hr>
<p>title: python基础 – 动态绑定<br>categories:</p>
<ul>
<li>python</li>
<li>python基础<br>tags:</li>
<li>python</li>
<li>python基础</li>
</ul>
<hr>
<pre><code class="python">from types import MethodType


class Student:
    pass


s = Student()
s.name = &#39;test&#39;
print(s.name)   # test


def set_name(self, name):
    self.name = name


s.set_name = MethodType(set_name, s)    # 为对象绑定方法，只有该对象可以使用
s.set_name(&#39;haha&#39;)
print(s.name)   # haha

# s1 = Student()
# s1.set_name(&#39;s1&#39;)
#  &#39;Student&#39; object has no attribute &#39;set_name&#39;  这个实例没有绑定该方法

Student.set_name = set_name     # 为class绑定方法，所有的对象都可以使用
s2 = Student()
s2.set_name(&#39;s2&#39;)
print(s2.name)  # s2


class Teacher:
    __slots__ = (&#39;name&#39;, &#39;age&#39;, &#39;set_name&#39;)    # 通过这个方法可以预留一些属性，同时也是限制
    # TODO 那和直接定义相应的实例属性有什么区别


t1 = Teacher()
t1.name = &#39;老师&#39;
t1.age = 25
print(&#39;name : {}, age : {}&#39;.format(t1.name, t1.age))    # name : 老师, age : 25
# t1.score = 100    score属性无法被绑定
# t1.set_name = set_name
# t1.set_name(name=&#39;new name&#39;)
# print(&#39;name : {}, age : {}&#39;.format(t1.name, t1.age))
# TODO 同样不能绑定成功

</code></pre>
