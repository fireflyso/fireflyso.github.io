<hr>
<p>title: python基础 – 实例资源和类资源<br>categories:</p>
<ul>
<li>python</li>
<li>python基础<br>tags:</li>
<li>python</li>
<li>python基础</li>
</ul>
<hr>
<h1 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h1><pre><code>#!/usr/bin/python3
# -*- coding: utf-8 -*-


class Student:
    name = &#39;globe_name&#39;

    def __init__(self):
        self.name = &#39;name&#39;


s1 = Student()
print(s1.name)  # name  实例属性优先级更高，先找实例属性，没有才会找类属性
</code></pre>
<ul>
<li>调用属性会先找实例属性，没有再找类属性</li>
</ul>
<pre><code>class Student:
    # 类属性
    count = 0

    def __init__(self, name) -&gt; None:
        # 实例属性
        self.name = name
        Student.count += 1


for i in range(10):
    s = Student(i)
    print(&#39;name : {}, count : {}&#39;.format(s.name, s.count))  # 这里使用s.count和Student.count是一样的

# 打印结果
name : 0, count : 1
name : 1, count : 2
name : 2, count : 3
name : 3, count : 4
name : 4, count : 5
name : 5, count : 6
name : 6, count : 7
name : 7, count : 8
name : 8, count : 9
name : 9, count : 10
</code></pre>
<ul>
<li>类属性是类绑定，实例之间共享，也就是会存在安全性问题</li>
</ul>
<h1 id="实例方法、类方法、静态方法"><a href="#实例方法、类方法、静态方法" class="headerlink" title="实例方法、类方法、静态方法"></a>实例方法、类方法、静态方法</h1><pre><code class="python">COUNT = 1


class Student:
    name = &#39;globe_name&#39;

    def instence_foo(self):
        print(&#39;instence_foo&#39;)

    @classmethod
    def class_foo(cls):
        print(&#39;class_foo&#39;)

    @staticmethod
    def static_foo():
        print(&#39;static_foo&#39;)


s1 = Student()
s1.instence_foo()
print(&#39;s1.instence_foo : {}&#39;.format(s1.instence_foo))

s1.class_foo()
print(&#39;s1.class_foo : {}&#39;.format(s1.class_foo))

Student.class_foo()
print(&#39;Student.class_foo : {}&#39;.format(Student.class_foo))

s1.static_foo()
print(&#39;s1.static_foo : {}&#39;.format(s1.static_foo))

Student.static_foo()
print(&#39;Student.static_foo : {}&#39;.format(Student.static_foo))

# 输出结果
instence_foo
s1.instence_foo : &lt;bound method Student.instence_foo of &lt;__main__.Student object at 0x10d0ef340&gt;&gt;
class_foo
s1.class_foo : &lt;bound method Student.class_foo of &lt;class &#39;__main__.Student&#39;&gt;&gt;
class_foo
Student.class_foo : &lt;bound method Student.class_foo of &lt;class &#39;__main__.Student&#39;&gt;&gt;
static_foo
s1.static_foo : &lt;function Student.static_foo at 0x10d161040&gt;
static_foo
Student.static_foo : &lt;function Student.static_foo at 0x10d161040&gt;
</code></pre>
<ul>
<li>实例方法只能被实例对象调用</li>
<li>类方法和静态方法都可以被实例对象或者类名调用</li>
<li>实例方法被绑定到实例对象上，类对象被绑定到类上，静态方法是独立的，只是被写入了class中，其实python和Java不同，完全可以写到class外也可以被调用（Java必须要依附于对象）</li>
</ul>
<pre><code class="python">COUNT = 1

class Student:
    name = &#39;globe_name&#39;

    def __init__(self):
        self.age = 100

    def instence_foo(self):
        print(&#39;instence_foo&#39;)
        print(&#39;get COUNT : {}&#39;.format(COUNT))
        print(&#39;get name : {}&#39;.format(self.name))
        print(&#39;get age : {}&#39;.format(self.age))

    @classmethod
    def class_test(cls):
        print(&#39;class_test&#39;)

    @classmethod
    def class_foo(cls):
        print(&#39;class_foo&#39;)
        print(&#39;get COUNT : {}&#39;.format(COUNT))
        print(&#39;get name : {}&#39;.format(cls.name))
        cls.class_test()
        # print(&#39;get age : {}&#39;.format(cls.age))   # AttributeError: type object &#39;Student&#39; has no attribute &#39;age&#39;

    @staticmethod
    def static_foo():
        print(&#39;static_foo&#39;)
        print(&#39;get COUNT : {}&#39;.format(COUNT))


s1 = Student()
s1.static_foo()
s1.class_foo()
s1.static_foo()

# 输出
static_foo
get COUNT : 1
class_foo
get COUNT : 1
get name : globe_name
class_test
static_foo
get COUNT : 1
</code></pre>
<ul>
<li>本质上，实例对象被创建后会被赋值给self，所以可以通过self关键字调用对象资源</li>
<li>而类资源被赋值给了cls，所以可以通过cls访问到类资源（属性和方法），但是不能访问到实例资源（这些资源是在对象创建的时候被初始化的）</li>
<li>静态方法就不说了，啥都访问不到，只有外面的公共资源可以访问</li>
<li>Java里面没有类资源这个层级，只有静态和实例，类名被使用的时候静态资源就被创建了（因为静态资源可以通过类名直接调用），别的都是实例资源在对象被创建后才可以使用</li>
<li>==放在类定义以外的资源是如何中内存中存活和销毁的呢？==</li>
</ul>
