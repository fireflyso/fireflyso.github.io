<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2019 -- java基础 | 南山山</title><meta name="author" content="南山山"><meta name="copyright" content="南山山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 一、数据类型基本类型   byte   char   short   int   long   double   float   boolean  包装类   Byte、Character、Short、Integer、Long、Double、Float、Boolean   &#x3D;&#x3D;所有的包装类都是final修饰的，为什么？？？&#x3D;&#x3D;   &#x3D;&#x3D;基本类型存在的意义是什么，为什么不直接用包装类，万">
<meta property="og:type" content="article">
<meta property="og:title" content="2019 -- java基础">
<meta property="og:url" content="http://example.com/2023/04/13/java/2019/java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="南山山">
<meta property="og:description" content="[TOC] 一、数据类型基本类型   byte   char   short   int   long   double   float   boolean  包装类   Byte、Character、Short、Integer、Long、Double、Float、Boolean   &#x3D;&#x3D;所有的包装类都是final修饰的，为什么？？？&#x3D;&#x3D;   &#x3D;&#x3D;基本类型存在的意义是什么，为什么不直接用包装类，万">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-13T03:21:43.684Z">
<meta property="article:modified_time" content="2023-04-23T06:36:17.930Z">
<meta property="article:author" content="南山山">
<meta property="article:tag" content="java">
<meta property="article:tag" content="2019">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/13/java/2019/java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2019 -- java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-23 14:36:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">161</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="南山山"><span class="site-name">南山山</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2019 -- java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-13T03:21:43.684Z" title="发表于 2023-04-13 11:21:43">2023-04-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-23T06:36:17.930Z" title="更新于 2023-04-23 14:36:17">2023-04-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/2019/">2019</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2019 -- java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li>  byte</li>
<li>  char</li>
<li>  short</li>
<li>  int</li>
<li>  long</li>
<li>  double</li>
<li>  float</li>
<li>  boolean</li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul>
<li>  Byte、Character、Short、Integer、Long、Double、Float、Boolean</li>
<li>  ==所有的包装类都是final修饰的，为什么？？？==</li>
<li>  ==基本类型存在的意义是什么，为什么不直接用包装类，万事万物皆对象，为什么还要有基本数据类型==</li>
<li>  基本数据类型除了Boolean以外都是可以相互转换的，但是由于各自占的空间大小不同，高精度转换为低精度时可能会丢失，而且他是直接通过位来截断的，可能会被转得面目全非，所以最好不要轻易进行降精度的转换</li>
<li>  int到Integer的转换</li>
</ul>
<!---->

<pre><code>Integer a = 1;
int b = a;
// 包装类转基本数据类型
int b = a.valueOf(1);

int c = 1;
Integer d = c;
// 基本数据类型转包装类
Integer d = c.intValue(1);
</code></pre>
<ul>
<li>  空指针</li>
</ul>
<!---->

<pre><code>Integer a = null;
int b = a;  //抛出NullPointException
</code></pre>
<ul>
<li>  两个包装类引用的相等性</li>
</ul>
<!---->

<pre><code>Integer a = 1;
Integer b = 1;
System.out.println(a==b);   //true

Integer c = 1000;
Integer d = 1000;
System.out.println(c==d);   //false

// 以下为Integer的源码
public static Integer valueOf(int i) &#123;
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127]
        return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象
    return new Integer(i); // 如果不在，则创建一个新的Integer对象
&#125; 
</code></pre>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>这个缓冲池是说的对于基本数据类型的缓存池</p>
<h4 id="new-Integer-123-和Integer-valueOf-123-的区别"><a href="#new-Integer-123-和Integer-valueOf-123-的区别" class="headerlink" title="new Integer(123)和Integer.valueOf(123)的区别"></a>new Integer(123)和Integer.valueOf(123)的区别</h4><p>其实就是上面的问题里面提过，使用valueOf的时候可以去访问缓存池，这个缓存池的大小是-128-127，如果在这个范围内的话会直接去取缓存池中的对象就不用新建对象了，而new这个关键字总是会创建新对象</p>
<h4 id="哪些基础数据类型拥有缓存池"><a href="#哪些基础数据类型拥有缓存池" class="headerlink" title="哪些基础数据类型拥有缓存池"></a>哪些基础数据类型拥有缓存池</h4><p>boolean、byte、short、int、char，Boolean就不用说了就俩值所以都在缓存池里面，byte类型大小和缓存池大小一样都可以缓存，而short和int都是-128-127，char的这个看不太懂\u0000 to \u007F，估计也是一样的大小只是表达方式问题</p>
<h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>String被声明为final，因此他不可以被继承；java8中String通过char数组进行存储；java9中使用byte数据进行存储，同时使用char类型的coder参数来标识使用了哪种编码。</p>
<h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><ul>
<li>  可以缓存hash值</li>
<li>  String Pool需要：Sting对象被创建后会从String Pool中取得引用，只有String是不可变的，才可能使用String Pool</li>
<li>  安全性：String作为参数可以保证参数不变，例如在作为网络连接参数的时候</li>
<li>  线程安全：不存在线程安全问题，可以在多个线程中安全的使用</li>
</ul>
<h3 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h3><ul>
<li>  String不可变，另外俩都可变，可变带来一些好处，如果一个字符串被修改的频率很高的时候可以节省创建新对象的开支</li>
<li>线程安全性<ul>
<li>  String天生线程安全</li>
<li>  StringBuilder不是线程安全的</li>
<li>  StringBuffer是线程安全的，为此带来的是更高的资源消耗</li>
</ul>
</li>
</ul>
<h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池中保存着所有字符串字面量，这个所谓字面量就是指字符串字符本身被存放到了一个内存空间中，这些字面量在编译时期就确定了，此外也可以通过String的intern()方法在运行过程中将字符串添加到常量池中。</p>
<h4 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h4><p>关于这个intern()方法，当调用它的时候它去常量池中检查是否存在了相同的字面量，存在就直接返回这个字面量对象的引用；否则会再常量池中新建一个字面量对象然后返回它的引用。</p>
<pre><code>String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);
System.out.println(s1 == s2);   //false
String s3 = s1.intern();
String s4 = s2.intern();
System.out.println(s3 == s4);   //true

//如果是以下面的这种字面量的形式创建字符串，则会自动将字符串放入常量池中
String s = &quot;aaa&quot;;
</code></pre>
<h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>经常会问说这个过程中有几个对象被创建了，两个或者一个，堆上一定会创建一个字符串对象，而常量池中就要看是否有相同的字符串对象存在了，不存在就创建一个，存在就直接引用。</p>
<p>再详细了说，在String Pool中不存在abc字面量的时候，会创建一个字符串对象，这是一个对象，在常量池中分配一块内存存储abc这个字面量，然后将常量池上创建的字符串对象指向这个字面量。再将这个常量池中的字符串对象作为String构造函数的参数在堆中创建一个字符串对象，这时并不是要复制一份常量池中对象内容而是将引用指向它。</p>
<pre><code>String s1 = new String(&quot;he&quot;) + new String(&quot;llo&quot;);
String s2 = s1.intern();
</code></pre>
<p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/markdown/java_string.png" alt="image"></p>
<h2 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>java中只有值传递，没有引用传递</p>
<p>==将不同类型的参数进行方法调用后，原来的参数是否会发生改变==</p>
<h3 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h3><p>这简直是大坑，总体上说两个类型都是浮点数，然后float属于的单精度，double是双精度，在内存上float占4个字节，double占用8个字节，float有效数字为8位（这里的有效数字是包含了小数点前的数字的，从小数点前向后计数），double有效数字为16位，通常来说cup处理单精度速度比处理双精度速度快；实际使用的时候好像很少会用到float</p>
<pre><code>//float的定义
float f = 1.1;  //会报错,默认1.1是double类型的
float f = (float) 1.1;
float f = 1.1f;
</code></pre>
<p>再看看java中浮点数的计算，结果很诡异</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 运算3*0.1</span><br><span class="line">System.out.println(3*0.1);</span><br><span class="line">//结果： 0.30000000000000004</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算机中所有的数最终都要转换成二进制表示，当浮点数参与了计算，那么浮点数的二进制与十进制之间的转换过程会变得不可预知且不可逆；这里说一下既然float和double其实都是在表示小数，为啥不直接说他们叫小数还要说是浮点数呢，这些数都是以科学计数法的形式进行存储的，一个数50.534转换成科学计数法形式5.053e1，不太清楚什么是科学计数法，但它的小数点移动到了一个新的位置（浮动了），这么说起来浮点数是服务于科学计算的，不适合用来进行精确计算；</p>
<p>==问题来了：java中到底该如何进行小数运算==</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">short s = 1;</span><br><span class="line">s = s + 1; //会报错，1这个字面量默认属于int，但不知道为什么在赋值的时候就可以，难道也是做了隐式的类型转换吗</span><br><span class="line">s = (short) (s + 1);</span><br><span class="line"></span><br><span class="line">// 通过下面的两种方法可以进行隐式的类型转换</span><br><span class="line">s += 1;</span><br><span class="line">s ++;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>枚举的关键字，枚举这个语法被用得好少，一般都直接使用判断语句了，其实还是有他的优点的，有机会试试；在java7之后可以在switch判断语句中使用String对象了</p>
<h2 id="四、继承"><a href="#四、继承" class="headerlink" title="四、继承"></a>四、继承</h2><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类和方法都用abstract进行修饰，抽象类里面一般都有抽象方法，当然一定包含也可以，但是抽象方法必须在抽象类中才能定义；抽象类和普通类最大的区别是抽象类不能被实现，需要通过继承后去实例化其子类。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是抽象类的延伸，在java8以前，可以把它看成是一个完全的抽象类，那时候它不能有任何的方法实现；但是从java8开始接口也可以有默认的方法实现了，因为完全抽象的维护成本太高了，在8之前要扩展一个接口方法时，就要修改所有实现了该接口的类；</p>
<p>接口的成员（方法和字段）都是public的，并且不允许被定义为private或者protected；</p>
<pre><code>public interface Man &#123;
    int i = 0;
    String name = &quot;11&quot;;
    default void show(String content)&#123;&#125;
    static void speak()&#123;&#125;
&#125;
</code></pre>
<ul>
<li>==接口的字段默认都是static和final的==<ul>
<li>  带来一些问题：接口是抽象类的延伸所以它也不能被实例化，所以它也没有构造函数，而字段又都是static final的，所以也不能留白，必须在定义的时候就实例化</li>
<li>  ==普通类里面static修饰的字段可以不初始化，final修饰的字段至少要在构造函数里面初始化，static final修饰的字段必须在定义的时候初始化==</li>
</ul>
</li>
</ul>
<h4 id="抽象类和接口对比"><a href="#抽象类和接口对比" class="headerlink" title="抽象类和接口对比"></a>抽象类和接口对比</h4><ul>
<li>  本质来说一个是类只是有了一些约束而另一个是接口是一个完全的契约，而具体的不同其实是由于接口成员都是public所以没有权限管理，类可以继承多个接口而抽象类只能单继承</li>
</ul>
<h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>其实大多数情况下都使用了接口，抽象类使用场景很少，一方面是抽象类严格的类层次要求，另一方面是java8之后接口可以默认实现方法后维护成本变低</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>==super大概就是一个父类的实例引用，对应this关键字是自身的一个实例引用==不知道为什么没把这俩哥们放到一起讲，然后super就是用来帮助访问父类的被重写了的方法（构造方法和普通方法都可以）的，不然被重写了就没法用了有的时候还是不科学的</p>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><h4 id="重写（override）"><a href="#重写（override）" class="headerlink" title="重写（override）"></a>重写（override）</h4><p>在继承中子类定义了和父类中声明上完全相同的一个方法，而为了满足里式替换原则，最好是用@Override注解来让编译器帮忙检查是否满足这些条件：</p>
<ul>
<li>  访问权限</li>
<li>  返回类型</li>
<li>  抛出异常</li>
</ul>
<h4 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h4><p>==方法名相同，参数类型、个数、顺序不同，不知道返回值类型不同算不算，而且返回值如果是父子类或者接口与实现关系时候怎么说==</p>
<h2 id="五、Object通用方法"><a href="#五、Object通用方法" class="headerlink" title="五、Object通用方法"></a>五、Object通用方法</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><pre><code>public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class&lt;?&gt; getClass()

protected void finalize() throws Throwable &#123;&#125;

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
</code></pre>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><ul>
<li>  等价关系</li>
</ul>
<!---->

<pre><code>//自反性
x.equals(x)
//对称性
x.equals(y) == y.equals(x); // true
//传递性
if (x.equals(y) &amp;&amp; y.equals(z))
    x.equals(z); // true;
//一致性：多次调用结果不变
x.equals(y) == x.equals(y); // true
//与null比较:这个才是重点，任何不是null的对象x调用equals(null)都是false，什么叫对象为null呢，就是对象被声明后没有被初始化
x.equals(null)
</code></pre>
<ul>
<li>作用<ul>
<li>与==的区别<ul>
<li>  对于基本类型： ==判断两个值是否相等，基本类型没有equals方法</li>
<li>  对于非基本类型：equals判断值是否相等，==判断两个变量是否指向相同的对象</li>
</ul>
</li>
<li>  ==判断是否是同一个对象的引用？不知道这里说的是什么意思==</li>
</ul>
</li>
</ul>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>返回hash值</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>==拷贝，内容挺多的，有时间看看==</p>
<h2 id="六、关键字"><a href="#六、关键字" class="headerlink" title="六、关键字"></a>六、关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>声明数据为常量，如果在定义的时候就赋值了那就是一个编译时常量，也可以是留白了等到运行时才赋值，赋值之后就不能改变</p>
<ul>
<li>  对基本类型，final使得数值不变</li>
<li>  对于引用，final使得引用不能在改变指向的对象，只是相当于指针被锁死，但是引用的对象的内容是可以发生变化的</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>声明方法的时候该方法不能被子类重写，其实private修饰方法的时候就是把方法指定为了final，这个时候当子类中再出现相同的方法签名也不会是重写，而是在子类中定义了一个新的方法</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>声明类不可以被继承，==什么时候需要说一个类不要被继承呢==</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p>叫做静态变量，意思说这个变量是类所有实例所共有的，静态变量在内存中只存储一份；别的变量都叫做实例变量，也就是说每个实例都会有一份，它与所在的实例是同生共死</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>  静态方法在类加载的时候就存在了，它不依赖与任何实例，所以静态方法必须有实现，导致它不能是抽象方法</li>
<li>  只能访问所属类的静态方法和静态字段，因为别的字段不一定初始化了（==但是当年鸣哥说过另外一个概念，有点忘了==），方法中也不能有super和this关键字（这两哥们大概都是在类的对象初始化的时候才会生成的）</li>
</ul>
<h4 id="静态语句块"><a href="#静态语句块" class="headerlink" title="静态语句块"></a>静态语句块</h4><p>在类初始化的时候运行一次</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>非静态内部类需要依赖于外部类的实例，儿静态内部类不需要，同时它也不能去访问外部类的非静态的成员</p>
<h4 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h4><ul>
<li>  静态变量和静态语句块由于实例变量和普通语句块，而它俩的优先级是相同的也就是说谁在前面谁先执行</li>
<li>  实例变量和普通语句块，这两哥们优先级也是一样的</li>
<li>  构造函数</li>
<li>存在继承的情况下<ol>
<li> 父类（静态内容）</li>
<li> 子类（静态内容）</li>
<li> 父类（实例变量、普通语句块）</li>
<li> 父类（构造函数）</li>
<li> 子类（实例变量、普通语句块）</li>
<li> 子类（构造函数）</li>
</ol>
</li>
</ul>
<h2 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h2><h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h2 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h2></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/2019/">2019</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/13/java/2019/why/" title="2019 -- why"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2019 -- why</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/13/java/2019/%E6%91%98%E5%BD%95/" title="2019 -- 摘录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2019 -- 摘录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">一、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.3.</span> <span class="toc-text">缓存池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-Integer-123-%E5%92%8CInteger-valueOf-123-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.1.</span> <span class="toc-text">new Integer(123)和Integer.valueOf(123)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%8B%A5%E6%9C%89%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">1.3.2.</span> <span class="toc-text">哪些基础数据类型拥有缓存池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81String"><span class="toc-number">2.</span> <span class="toc-text">二、String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.2.</span> <span class="toc-text">不可变的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%EF%BC%8CStringBuffer%EF%BC%8CStringBuilder"><span class="toc-number">2.3.</span> <span class="toc-text">String，StringBuffer，StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Pool"><span class="toc-number">2.4.</span> <span class="toc-text">String Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#intern-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">intern()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-String-%E2%80%9Cabc%E2%80%9D"><span class="toc-number">2.4.2.</span> <span class="toc-text">new String(“abc”)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E7%AE%97"><span class="toc-number">3.</span> <span class="toc-text">三、运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.1.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#float%E5%92%8Cdouble"><span class="toc-number">3.2.</span> <span class="toc-text">float和double</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.3.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">3.4.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%A7%E6%89%BF"><span class="toc-number">4.</span> <span class="toc-text">四、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.</span> <span class="toc-text">抽象类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%AF%B9%E6%AF%94"><span class="toc-number">4.1.3.</span> <span class="toc-text">抽象类和接口对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9"><span class="toc-number">4.1.4.</span> <span class="toc-text">使用选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">4.2.</span> <span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="toc-number">4.3.</span> <span class="toc-text">重载和重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88override%EF%BC%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">重写（override）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88overload%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">重载（overload）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Object%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">五、Object通用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">5.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals"><span class="toc-number">5.2.</span> <span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode"><span class="toc-number">5.3.</span> <span class="toc-text">hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-number">5.4.</span> <span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone"><span class="toc-number">5.5.</span> <span class="toc-text">clone()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.</span> <span class="toc-text">六、关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">6.1.</span> <span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">6.1.3.</span> <span class="toc-text">类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static"><span class="toc-number">6.2.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">6.2.3.</span> <span class="toc-text">静态语句块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">6.2.4.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.2.5.</span> <span class="toc-text">初始化顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-number">7.</span> <span class="toc-text">七、反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%BC%82%E5%B8%B8"><span class="toc-number">8.</span> <span class="toc-text">八、异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">九、泛型</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 南山山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">咱是有底线的</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>