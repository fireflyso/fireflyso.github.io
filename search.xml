<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python -- Java和Python的的差异及其成因</title>
    <url>/2023/04/13/python/Java%E5%92%8CPython%E7%9A%84%E7%9A%84%E5%B7%AE%E5%BC%82%E5%8F%8A%E5%85%B6%E6%88%90%E5%9B%A0/</url>
    <content><![CDATA[<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a><a href="attachments/noteshare%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a></h4><ul>
<li>  python的产生几十年了，几十年前面向过程是主流，所以用python有好多程序用的是面向过程设计方法，很多概念从c语言过来的，class在python中是后加入的，在大家提到Python的时候都会很自然的想到它的方便快捷，其实一方面是环境（linux内嵌）然后就是它可以按照面向过程的方式来编程，在写一个简单的爬虫程序的时候大家估计都不会去定义一个类，所以Python是对面向过程的支持</li>
<li>  Java在1991年推出JDK1.0的时候的虚拟机叫Sun Class JVM，也就是从他构建完成被正式发布的时候就已经是面向对象了，Java里有一句话叫万事万物皆对象，放到一个最基本的语法上说就是，不管你要做什么你都需要一个对象，所有的方法的调用必须是依赖于一个对象的实例的，不能像Python或者c那样打开文本写一个function然后在后面直接使用方法名调用。</li>
</ul>
<h4 id="语言类型："><a href="#语言类型：" class="headerlink" title="语言类型："></a>语言类型：</h4><p>机器是不能直接理解高级语言的，需要一个翻译的过程</p>
<ul>
<li>  编译型语言：Java有一个编译器来将开发者的代码编译为.class文件，然后JVM（Java虚拟机）只能加载.class文件，JVM又是用了解释的方式来执行了这个.class文件，所以Java其实也不算是纯粹的编译型语言，纯粹的编译型语言在完成一次编译后以后都是可以直接运行的</li>
<li>  解释型语言：在运行的时候才逐句的去翻译为机器语言，需要一个对应的解释器，每次运行都需要编译，所以效率通常就要低一些，Python通过在运行时生产字节码文件.pyc来改善性能，<a href="https://segmentfault.com/a/1190000011904489">更多关于.pyc的机制</a></li>
</ul>
<h4 id="快捷轻巧"><a href="#快捷轻巧" class="headerlink" title="快捷轻巧"></a>快捷轻巧</h4><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>java<ul>
<li>  基础数据类型：byte、char、short、int、long、float、double、boolean</li>
<li>  其他：String、list、set、map</li>
</ul>
</li>
<li>Python<ul>
<li>  Numbers:int、long、float、complex</li>
<li>  String:</li>
<li>  List:动态数组实现的，也就是说内存是连续的</li>
<li>  Tuple:静态数组</li>
<li>  Dictionary:</li>
</ul>
</li>
</ul>
<h4 id="运算法则"><a href="#运算法则" class="headerlink" title="运算法则"></a>运算法则</h4><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h2 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h2><ul>
<li>  搭建难度、成型框架（数量、功能）</li>
<li>  稳定性、运行速度</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- Python内存模型</title>
    <url>/2023/04/13/python/Python%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="变量、对象、引用"><a href="#变量、对象、引用" class="headerlink" title="变量、对象、引用"></a>变量、对象、引用</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里a叫做变量；1是对象；一个变量指向一个对象叫做这个对象产生了一个引用，和Java类似</p>
<ul>
<li>  变量类型：一个变量不会有任何类型信息或者约束，类型的概念和对象关联，而不是变量名字</li>
<li>  变量的使用：当变量出现在表达式中，他会立即使用当前指向的对象替换，这导致变量在使用之前都必须要被显示的赋值，使用未被赋值的变量时会产生错误</li>
<li>  变量和对象：变量和对象是存储到不同的内存中，变量永远会指向对象不会指向其他变量，对象是有可能指向别的对象的（list）</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>  每个对象都有两个标准的 header fields:type designator标识对象的类型，reference counter记录引用次数</li>
<li>  对象创建时会分配一片内存空间用来存储类中的数据，作为优化有一部分的数据（较小的integers和strings）是用缓存池来存储的，不用每次都在对象内存中去单独存储</li>
</ul>
<h4 id="对象回收"><a href="#对象回收" class="headerlink" title="对象回收"></a>对象回收</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">a = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>这个时候对象3会被回收，Python主要通过引用计算法来进行垃圾回收</p>
<h4 id="共享引用"><a href="#共享引用" class="headerlink" title="共享引用"></a>共享引用</h4><ul>
<li>  对不可变的类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line">b = a   <span class="comment"># b会创建指向对象3的引用</span></span><br><span class="line">a = <span class="number">4</span>   <span class="comment"># 不会影响b指向对象3</span></span><br><span class="line">a = a + <span class="number">1</span>   <span class="comment"># 对象5会作为加号的结果放到新的内存空间，integer是不可变类型，所以会分配新的内存空间，并为a创建指向对象5的引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  对可变的类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a   <span class="comment"># b也指向数组对象</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">2</span>    <span class="comment"># 这时是数组对象发生了变化，不是a引用了新的对象，a和b还是指向同一个对象，当然b[0]也发生了变化</span></span><br></pre></td></tr></table></figure>

<h3 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a == b  <span class="comment"># 对值的判断</span></span><br><span class="line">a <span class="keyword">is</span> b  <span class="comment"># 对指向的对象的判断，更严格的判断</span></span><br></pre></td></tr></table></figure>

<h3 id="整数对象"><a href="#整数对象" class="headerlink" title="整数对象"></a>整数对象</h3><ul>
<li><p>  integer是一个不可变类型，这就是说一个integer对象的内存中的数据是不会改变的，任何的运算都只会去新建对象来存放运算后的数据</p>
</li>
<li><p>  对于整数对象，有一个缓存池，这个缓存池的大小是[-5,256],这个很好证明</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = -<span class="number">5</span></span><br><span class="line">b = -<span class="number">5</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="built_in">id</span>(a))  <span class="comment"># &#x27;0x109d7ffc0&#x27;</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="built_in">id</span>(b))  <span class="comment"># &#x27;0x109d7ffc0&#x27;</span></span><br><span class="line"></span><br><span class="line">a = -<span class="number">5</span></span><br><span class="line">b = -<span class="number">5</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="built_in">id</span>(a))  <span class="comment"># &#x27;0x10a027fd0&#x27;</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="built_in">id</span>(b))  <span class="comment"># &#x27;0x10a027f70&#x27;</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">256</span></span><br><span class="line">b = <span class="number">256</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="built_in">id</span>(a))  <span class="comment"># &#x27;0x109d82060&#x27;</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="built_in">id</span>(b))  <span class="comment"># &#x27;0x109d82060&#x27;</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="number">257</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="built_in">id</span>(a))  <span class="comment"># &#x27;0x10a027fd0&#x27;</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="built_in">id</span>(b))  <span class="comment"># &#x27;0x10a027f50&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这块区域被称为小整型缓存池，静态分配，在Python初始化时被创建，用的时候直接去取就行，不用创建，超出这个范围的就是用到的时候创建的并且不会复用，也就是说创建两个257在内存中就有两片不同的空间用来存储了这两个字面量，再将两个变量分别指向这两片空间地址</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h3 id="list和dict"><a href="#list和dict" class="headerlink" title="list和dict"></a>list和dict</h3>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- Python基础</title>
    <url>/2023/04/13/python/Python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ul>
<li><p>虚拟环境： <a href="./virtualenv%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E.md">virtualenv使用说明</a></p>
</li>
<li><p>代码调试：代码调试</p>
</li>
<li><p>代码风格：代码风格</p>
</li>
<li><p>引用赋值、浅拷贝、深拷贝</p>
</li>
<li><p>访问限制：访问限制</p>
</li>
<li><p>生成器、迭代器：生成器迭代器</p>
</li>
<li><p>动态绑定属性与方法，__slots__方法：动态绑定</p>
</li>
<li><p>类属性、实例属性、类方法、静态方法、实例方法：实例资源和类资源</p>
</li>
<li><p>MRO：MRO</p>
</li>
<li><p>获取对象信息的内置方法：获取对象信息的内置方法</p>
</li>
<li><p>特殊方法和属性：特殊方法和属性</p>
</li>
<li><p>异常处理：异常处理</p>
</li>
<li><p>函数特性：函数特性</p>
</li>
<li><p>脚本传参：脚本传参</p>
</li>
<li><p>工作目录：工作目录</p>
</li>
<li><p>版本迭代：版本迭代</p>
</li>
</ul>
<h1 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h1><ul>
<li><p>日志模块：</p>
</li>
<li><p>ORM：Django ORM</p>
</li>
<li><p>Uwsgi服务调优：</p>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li><p>clickhouse操作：python调用clickhouse语法</p>
</li>
<li><p>pymysql基础操作：</p>
</li>
<li><p>peewee：Peewee框架使用</p>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- supervisor进程管理</title>
    <url>/2023/04/13/python/supervisor%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>supervisor本身就是由Python编写的，是一个很方便的进程管理工具；<br><a href="https://www.jianshu.com/p/bf2b3f4dec73">搭建教程产考</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install supervisor</span><br></pre></td></tr></table></figure>

<h4 id="搭建项目结构"><a href="#搭建项目结构" class="headerlink" title="搭建项目结构"></a>搭建项目结构</h4><ul>
<li>  在项目的根目录下创建一个文件夹supervisor来保存有关的文件</li>
<li>  在supervisor文件夹下创建子文件夹configs,用来保存每个进程对应的配置文件</li>
<li>  在项目中创建log文件夹来保存日志文件（如果有了就不用创建了）</li>
<li>  在supervisor文件夹中创建supervisor.conf来保存主配置信息</li>
</ul>
<h4 id="配置文件（主）"><a href="#配置文件（主）" class="headerlink" title="配置文件（主）"></a>配置文件（主）</h4><p>这里为了方便写入笔记，将所有的注释都删除了，其实还有很多的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=%(here)s/supervisor.sock   ; the path to the socket file</span><br><span class="line"><span class="built_in">chmod</span>=0700                 ; socket file mode (default 0700)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=%(here)s/../log/supervisord.log ; supervisor自己启动的日子文件</span><br><span class="line">logfile_maxbytes=50MB        ; 日志文件大小</span><br><span class="line">logfile_backups=10           ; 日志文件备份数量</span><br><span class="line">loglevel=info                ; <span class="built_in">log</span> level; default info; others: debug,warn,trace</span><br><span class="line">pidfile=%(here)s/supervisord.pid    ; 默认的路径会被Linux清理，修改为一个靠谱的路径</span><br><span class="line">nodaemon=<span class="literal">false</span>               ; start <span class="keyword">in</span> foreground <span class="keyword">if</span> <span class="literal">true</span>; default <span class="literal">false</span></span><br><span class="line">minfds=1024                  ; min. avail startup file descriptors; default 1024</span><br><span class="line">minprocs=200                 ; min. avail process descriptors;default 200</span><br><span class="line">directory=%(here)s/..        ; default is not to <span class="built_in">cd</span> during start</span><br><span class="line"></span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///%(here)s/supervisor.sock ; 默认的路径会被Linux清理，修改为一个靠谱的路径</span><br><span class="line"></span><br><span class="line">; [group:<span class="built_in">test</span>]    ; 分组管理进程</span><br><span class="line">; programs=<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">[include]   ; 引入不同进程的配置文件</span><br><span class="line">files = %(here)s/configs/*.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="进程独立的配置"><a href="#进程独立的配置" class="headerlink" title="进程独立的配置"></a>进程独立的配置</h4><p>在supervisor/configs下创建test.conf,这个配置文件中指定了进程运行的Python文件和日志文件路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[program:<span class="built_in">test</span>] ;项目名称</span><br><span class="line">directory = %(here)s/.. ; 程序的启动目录</span><br><span class="line"><span class="built_in">command</span> = python3 %(here)s/../../bin/Test.py  ; 启动命令，可以看出与手动在命令行启动的命令是一样</span><br><span class="line"></span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile = %(here)s/../../log/%(program_name)s/%(program_name)s.log</span><br><span class="line">loglevel=info</span><br></pre></td></tr></table></figure>

<h4 id="启动与管理"><a href="#启动与管理" class="headerlink" title="启动与管理"></a>启动与管理</h4><ul>
<li>  启动supervisor：指定的test.py开始运行，这里要注意如果只是用print语句打印的日志不会立即写入到日志文件，而是在进程执行完成后写入，用logger写入的日志会动态更新</li>
</ul>
<!---->

<pre><code># 主配置文件
supervisord -c supervisord.conf
</code></pre>
<ul>
<li>  查看运行状态</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">supervisorctl status</span><br></pre></td></tr></table></figure>

<ul>
<li>  常用的几个命令</li>
</ul>
<!---->

<pre><code>status
stop test
start test
restart test
reread  #   读取有更新的配置文件
update  #   重启配置文件修改过的程序
</code></pre>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><pre><code>supervisorctl shutdown
</code></pre>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- virtualenv使用说明</title>
    <url>/2023/04/13/python/virtualenv%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="一、virtualenv"><a href="#一、virtualenv" class="headerlink" title="一、virtualenv"></a>一、virtualenv</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在linux上通常账户都没有root权限安装python库会受到限制，而且python的库五花八门每个项目的依赖都不同导致安装的库混乱，通过virtualenv可以在项目里面隔离出一个虚拟的python环境，这样只要对项目有权限就能自由的安装python库</p>
<h2 id="python2解决方案"><a href="#python2解决方案" class="headerlink" title="python2解决方案"></a>python2解决方案</h2><p>pip在2021年放弃了对python2的维护，所以pip2不能正常使用了，但是pip还是指向了2并且可以使用</p>
<pre><code>python -m pip install --user virtualenv
python -m virtualenv venv
</code></pre>
<h2 id="新的解决方案"><a href="#新的解决方案" class="headerlink" title="新的解决方案"></a>新的解决方案</h2><p>Python3 在某一个版本中内置了venv，较低版本的Python3也需要安装该模块才能使用</p>
<pre><code>python3 -m venv venv
</code></pre>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>为项目搭建一个虚拟环境</p>
<p>  python3 -m venv venv</p>
</li>
<li><p>  进入虚拟环境</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到项目目录下，上一步应该生成了一个venv目录，执行</span></span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br><span class="line"><span class="comment"># 检查目前的python驱动位置</span></span><br><span class="line"><span class="built_in">which</span> python</span><br><span class="line">/Users/luoyang/workspace/cds/resop/venv/bin/python</span><br></pre></td></tr></table></figure>
<ul>
<li><p>退出virtual</p>
<p>  deactivate</p>
</li>
<li><p>  列出当前环境中的依赖库</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前环境中的依赖库</span></span><br><span class="line">pip3 freeze &gt; requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所有的依赖库</span></span><br><span class="line">pip3 install -r requirements.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装速度慢，可以指定资源</span></span><br><span class="line">-i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h1 id="二、pipenv"><a href="#二、pipenv" class="headerlink" title="二、pipenv"></a>二、pipenv</h1><p>下面的那个pyenv最后没有配置好</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装pipenv</span></span><br><span class="line">pip3 install --user pipenv</span><br><span class="line"><span class="comment"># 添加到shell</span></span><br><span class="line"><span class="comment"># 1.查看python目录</span></span><br><span class="line">python3 -m site --user-base</span><br><span class="line"><span class="comment"># 输出：/Users/luoyang/Library/Python/3.8</span></span><br><span class="line"><span class="comment"># 在输出结果后加上bin即：/Users/luoyang/Library/Python/3.8/bin，添加到.zshrc中</span></span><br><span class="line">vi ~/.zshrc</span><br><span class="line"><span class="built_in">export</span> PATH=/Users/luoyang/Library/Python/3.8/bin</span><br></pre></td></tr></table></figure>

<h1 id="三、pyenv"><a href="#三、pyenv" class="headerlink" title="三、pyenv"></a>三、pyenv</h1><p>virtualenv是系统去管理python版本，然后通过它去管理不同项目的环境，pyenv是替代系统去做python版本管理，同样提供了一个pyenv-virtualenv插件来管理不同py版本的虚拟环境</p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ul>
<li>  安装pyenv<code>brew install pyenv</code></li>
<li>  安装pyenv-virtualenv <code>brew install pyenv-virtualenv</code></li>
<li>  安装指定版本<code>pyenv install 2.7.16</code></li>
<li>  上一步可能会卡在下载安装包的步骤，可以手动下载（浏览器直接访问命令行中的链接），然后复制到.pyenv/cache目录（没有的话就新建一个），然后再次执行上一条命令</li>
</ul>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有的版本</span><br><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line"># 将python 2.7.16设置为默认版本</span><br><span class="line">pyenv global 2.7.16</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 代码调试</title>
    <url>/2023/04/13/python/%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="breakpoint"><a href="#breakpoint" class="headerlink" title="breakpoint"></a>breakpoint</h1><p>大概是python3.8版本引入了breakpoint()函数，用来替换pdb，功能非常接近，之前的pdb需要两句代码进行引入使用</p>
<h1 id="PDB"><a href="#PDB" class="headerlink" title="PDB"></a>PDB</h1><h2 id="加入调试点"><a href="#加入调试点" class="headerlink" title="加入调试点"></a>加入调试点</h2><p>直接在代码里面加上这两个语句，程序会在set_trace（）方法这里停下来</p>
<pre><code>import pdb
pdb.set_trace()
</code></pre>
<h2 id="pdb常用命令"><a href="#pdb常用命令" class="headerlink" title="pdb常用命令"></a>pdb常用命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出目前代码运行位置</span></span><br><span class="line"><span class="built_in">list</span>    </span><br><span class="line"><span class="comment"># 执行下一句</span></span><br><span class="line">n</span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line">quit或者q</span><br><span class="line"><span class="comment"># 打印变量</span></span><br><span class="line">p 变量名</span><br><span class="line"><span class="comment"># 动态改变值</span></span><br><span class="line">直接赋值即可</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 代码风格</title>
    <url>/2023/04/13/python/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里只是介绍Python代码的一些变量、函数命名和一些约定俗成的风格，目的是提高代码的可读性，这些风格规范不一定是Python的语法规范</p>
<h2 id="一、解释器和编码"><a href="#一、解释器和编码" class="headerlink" title="一、解释器和编码"></a>一、解释器和编码</h2><h4 id="可执行的Python脚本"><a href="#可执行的Python脚本" class="headerlink" title="可执行的Python脚本"></a>可执行的Python脚本</h4><p>在很多的Python文件中能看到第一行有以下格式的语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3.5</span></span><br></pre></td></tr></table></figure>

<p>原因是在一些Unix系统上Python是可以像shell一样被直接执行的，这个语句是指定了Python解释器的版本，为了不和2.x版本冲突</p>
<h4 id="指定编码"><a href="#指定编码" class="headerlink" title="指定编码"></a>指定编码</h4><p>在指定解释器版本后，是指定编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p>在Python3之后默认编码为utf-8，所以如果不是要指定为别的像上面的encoding的编码之类的话就不用写这个语句了</p>
<h2 id="二、占位符和pass语句"><a href="#二、占位符和pass语句" class="headerlink" title="二、占位符和pass语句"></a>二、占位符和pass语句</h2><h4 id="“-“下划线作为占位符"><a href="#“-“下划线作为占位符" class="headerlink" title="“_“下划线作为占位符"></a>“_“下划线作为占位符</h4><pre><code>for _ in range(10):
    print(&quot;I&#39;m sorry!&quot;)
</code></pre>
<p>在上面的案例中for循环在语法上需要一个循环的索引，但程序的逻辑中并不需要用到它，这个时候如果放一个i变量在这的话，vscode这样的编译器会提示你定义了一个参数但没有使用，这个时候用一个‘_’来做一个占位，表示符合语法规定但我不会用到这个参数</p>
<h4 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h4><pre><code>class Test:
    pass
</code></pre>
<p>这个多是在开发的过程中，我们定义了一个类或者方法，但又还没来得及对它进行实现的时候，语法上需要这里有语句，这时用pass来告诉程序这里什么都不用做</p>
<h2 id="三、默认值参数"><a href="#三、默认值参数" class="headerlink" title="三、默认值参数"></a>三、默认值参数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">name,age=<span class="number">20</span>,gender=<span class="string">&quot;male&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;name is &#123;&#125; ,age is &#123;&#125; ,gender is &#123;&#125;&quot;</span>.<span class="built_in">format</span>(name,age,gender)</span><br><span class="line">    </span><br><span class="line">fun(<span class="string">&quot;liu&quot;</span>)</span><br><span class="line"><span class="comment"># name is liu ,age is 20 ,gender is male</span></span><br><span class="line">fun(<span class="string">&quot;liu&quot;</span>,gender=<span class="string">&#x27;famale&#x27;</span>)</span><br><span class="line"><span class="comment"># name is liu ,age is 20 ,gender is famale</span></span><br></pre></td></tr></table></figure>

<p>这是一个很有意思的语法，它允许方法的参数有默认值，使得在调用上的fun()的时候可以只传一个name参数，当然也可以传递两个或者三个参数，这时就会覆盖相应的参数值</p>
<h2 id="四、命名规则"><a href="#四、命名规则" class="headerlink" title="四、命名规则"></a>四、命名规则</h2><ul>
<li>  列表末尾元素是否加逗号</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅当元素和)]&#125;不在同一行时推荐在末尾元素后加逗号</span></span><br><span class="line">golomb3 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">golomb4 = [</span><br><span class="line">   <span class="number">0</span>,</span><br><span class="line">   <span class="number">1</span>,</span><br><span class="line">   <span class="number">4</span>,</span><br><span class="line">   <span class="number">6</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>  导入格式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐每个导入独立一行，下面的第一种写法不推荐</span></span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE, STDOUT</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> signal</span><br></pre></td></tr></table></figure>

<ul>
<li>  命名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内部方法使用_前缀</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_run</span>():</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python -- 版本迭代</title>
    <url>/2023/04/17/python/%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul>
<li>  python2.6之后发布的python3.0（2008年），但是由于3.0并不能向下兼容2.0，所以10年的时候又发布了一个2.7版本，这个版本一直维护到了2020年，很多3.x后来的特性也被加入到了2.7的迭代中</li>
</ul>
<h1 id="3-10"><a href="#3-10" class="headerlink" title="3.10"></a>3.10</h1><h2 id="更清楚的错误消息"><a href="#更清楚的错误消息" class="headerlink" title="更清楚的错误消息"></a>更清楚的错误消息</h2><p>异常信息中会给出关于语法错误的更精准信息</p>
<h2 id="结构化模式匹配"><a href="#结构化模式匹配" class="headerlink" title="结构化模式匹配"></a>结构化模式匹配</h2><p>提供各种嵌套语法匹配的match</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    x: <span class="built_in">int</span></span><br><span class="line">    y: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">location</span>(<span class="params">point</span>):</span><br><span class="line">    <span class="keyword">match</span> point:</span><br><span class="line">        <span class="keyword">case</span> Point(x=<span class="number">0</span>, y=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Origin is the point&#x27;s location.&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> Point(x=<span class="number">0</span>, y=y):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Y=<span class="subst">&#123;y&#125;</span> and the point is on the y-axis.&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> Point(x=x, y=<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;X=<span class="subst">&#123;x&#125;</span> and the point is on the x-axis.&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> Point():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;The point is located somewhere else on the plane.&quot;</span>)</span><br><span class="line">        <span class="keyword">case</span> _:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Not a point&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">match</span> points:</span><br><span class="line">    <span class="keyword">case</span> []:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No points in the list.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(<span class="number">0</span>, <span class="number">0</span>)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;The origin is the only point in the list.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(x, y)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;A single point <span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span> is in the list.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> [Point(<span class="number">0</span>, y1), Point(<span class="number">0</span>, y2)]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Two points on the Y axis at <span class="subst">&#123;y1&#125;</span>, <span class="subst">&#123;y2&#125;</span> are in the list.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something else is found in the list.&quot;</span>)    </span><br></pre></td></tr></table></figure>



<h2 id="类型提示新特性"><a href="#类型提示新特性" class="headerlink" title="类型提示新特性"></a>类型提示新特性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">number: <span class="built_in">int</span> | <span class="built_in">float</span></span>) -&gt; <span class="built_in">int</span> | <span class="built_in">float</span>:</span><br><span class="line">    <span class="keyword">return</span> number ** <span class="number">2</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">isinstance</span>(<span class="number">1</span>, <span class="built_in">int</span> | <span class="built_in">str</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>





<h1 id="3-9版本"><a href="#3-9版本" class="headerlink" title="3.9版本"></a>3.9版本</h1><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul>
<li>  为字典提供两个新的运算符’|’和’|=’</li>
<li>  新增移除前后缀的方法<a href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#str.removeprefix" title="str.removeprefix"><code>str.removeprefix(prefix)</code></a> 和 <a href="https://docs.python.org/zh-cn/3.11/library/stdtypes.html#str.removesuffix" title="str.removesuffix"><code>str.removesuffix(suffix)</code></a></li>
</ul>
<h2 id="标注语法中类型优化"><a href="#标注语法中类型优化" class="headerlink" title="标注语法中类型优化"></a>标注语法中类型优化</h2><p>不需要再从typing中导入对应的List类型命，直接使用list，==那么list和List的关系是什么呢==</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet_all</span>(<span class="params">names: <span class="built_in">list</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, name)</span><br></pre></td></tr></table></figure>



<h2 id="新的解析器"><a href="#新的解析器" class="headerlink" title="新的解析器"></a>新的解析器</h2><p>基于PEG的解析器替换LL，性能上大致相当，PEG特性更为灵活，3.10中旧的解析器将被移除，另外3.9版本为最后一个提供对Python2兼容的版本</p>
<h2 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h2><p><a href="https://docs.python.org/zh-cn/3.11/library/multiprocessing.html#multiprocessing.SimpleQueue"><code>multiprocessing.SimpleQueue</code></a>新增close()方法进行显式的关闭</p>
<h2 id="ipaddress"><a href="#ipaddress" class="headerlink" title="ipaddress"></a>ipaddress</h2><p>不再支持IPv4地址字符串中存在前缀0，这个正好前两天碰到过，一般对IP地址的校验中认为前缀0是合法的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> ipaddress</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ipaddress.ip_address(<span class="string">&#x27;192.168.0.1&#x27;</span>)</span><br><span class="line">IPv4Address(<span class="string">&#x27;192.168.0.1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ipaddress.ip_address(<span class="string">&#x27;192.168.0.01&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/ipaddress.py&quot;</span>, line <span class="number">54</span>, <span class="keyword">in</span> ip_address</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;<span class="subst">&#123;address!r&#125;</span> does not appear to be an IPv4 or IPv6 address&#x27;</span>)</span><br><span class="line">ValueError: <span class="string">&#x27;192.168.0.01&#x27;</span> does <span class="keyword">not</span> appear to be an IPv4 <span class="keyword">or</span> IPv6 address</span><br></pre></td></tr></table></figure>



<h1 id="3-8版本"><a href="#3-8版本" class="headerlink" title="3.8版本"></a>3.8版本</h1><h2 id="‘-’-赋值表达式"><a href="#‘-’-赋值表达式" class="headerlink" title="‘:=’ 赋值表达式"></a>‘:=’ 赋值表达式</h2><p>表达式内部为变量赋值，以下代码避免len函数被调用两次，出了范围n的变量还在</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;List is too long (<span class="subst">&#123;n&#125;</span> elements, expected &lt;= 10)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="更多语言特性"><a href="#更多语言特性" class="headerlink" title="更多语言特性"></a>更多语言特性</h2><ul>
<li><p>  continue语句可以在finally子句中使用</p>
</li>
<li><p>  dict 和 dictview 可以使用 <a href="https://docs.python.org/zh-cn/3.11/library/functions.html#reversed" title="reversed"><code>reversed()</code></a> 按插入顺序反向迭代</p>
</li>
<li><p>新增metadata模块，可以用于查询第三方库的元信息</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> importlib.metadata <span class="keyword">import</span> version, requires, files</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>version(<span class="string">&#x27;requests&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;2.22.0&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(requires(<span class="string">&#x27;requests&#x27;</span>))</span><br><span class="line">[<span class="string">&#x27;chardet (&lt;3.1.0,&gt;=3.0.2)&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-7版本"><a href="#3-7版本" class="headerlink" title="3.7版本"></a>3.7版本</h1><h2 id="延迟的标注求值"><a href="#延迟的标注求值" class="headerlink" title="延迟的标注求值"></a>延迟的标注求值</h2><p>对上个版本中变量标注语法的优化</p>
<h2 id="breakpoint"><a href="#breakpoint" class="headerlink" title="breakpoint()"></a>breakpoint()</h2><p>新增内置函数breakpoint，替换之前的pdb，经过测试此函数功能等效于以前的pdb，主要是pdb写起来有点复杂，做了一个简单的语法替换</p>
<pre><code>import pdb
pdb.set_trace()

breakpoint()
</code></pre>
<h2 id="纳秒级的时间函数"><a href="#纳秒级的时间函数" class="headerlink" title="纳秒级的时间函数"></a>纳秒级的时间函数</h2><p>time.time()函数返回的浮点数时间精度跟不上现在计算机的时钟精度，所以进行了迭代</p>
<h2 id="基于哈希的pyc文件"><a href="#基于哈希的pyc文件" class="headerlink" title="基于哈希的pyc文件"></a>基于哈希的pyc文件</h2><div style="color:#F56C6C">可以了解一下pyc文件的作用，和java字节码文件的异同</div>

<h2 id="数据类dataclasses"><a href="#数据类dataclasses" class="headerlink" title="数据类dataclasses"></a>数据类dataclasses</h2><p>没用过，看了说明没没懂使用场景 <a href="https://peps.python.org/pep-0557/">PEP557</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryItem</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Class for keeping track of an item in inventory.&#x27;&#x27;&#x27;</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    unit_price: <span class="built_in">float</span></span><br><span class="line">    quantity_on_hand: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">total_cost</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">return</span> self.unit_price * self.quantity_on_hand</span><br></pre></td></tr></table></figure>

<h2 id="SimpleQueue"><a href="#SimpleQueue" class="headerlink" title="SimpleQueue"></a>SimpleQueue</h2><p>queue新添加了一个SimpleQueue对象，之前在多进程通信里面用了它的Queue对象，可以去了解下新增对象的特性，另外FIFO是先进先出的缩写</p>
<h1 id="3-6版本"><a href="#3-6版本" class="headerlink" title="3.6版本"></a>3.6版本</h1><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>这个东西类似于format，很多人喜欢用这个语法糖</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">&quot;Fred&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&quot;He said his name is <span class="subst">&#123;name&#125;</span>.&quot;</span></span><br><span class="line"><span class="string">&#x27;He said his name is Fred.&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="对变量类型的注释"><a href="#对变量类型的注释" class="headerlink" title="对变量类型的注释"></a>对变量类型的注释</h2><p>通过这个语法，实现了类似于java的类型规范，但这里只是一个注释，也就是说有没有都无所谓，增加可读性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">primes: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line">captain: <span class="built_in">str</span>  <span class="comment"># 这个时候，此参数是没有被初始化的，直接使用会有一个类似于java未初始化的异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Starship</span>:</span><br><span class="line">    stats: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数字文字中的下划线"><a href="#数字文字中的下划线" class="headerlink" title="数字文字中的下划线"></a>数字文字中的下划线</h2><p>增加数据可读性的语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1_000_000_000_000_000</span></span><br><span class="line"><span class="number">1000000000000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0x_FF_FF_FF_FF</span></span><br><span class="line"><span class="number">4294967295</span></span><br></pre></td></tr></table></figure>

<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 异步生成器</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ticker</span>(<span class="params">delay, to</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Yield numbers from 0 to *to* every *delay* seconds.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(to):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步推导</span></span><br><span class="line">result = [i <span class="keyword">async</span> <span class="keyword">for</span> i <span class="keyword">in</span> aiter() <span class="keyword">if</span> i % <span class="number">2</span>]</span><br><span class="line">result = [<span class="keyword">await</span> fun() <span class="keyword">for</span> fun <span class="keyword">in</span> funcs <span class="keyword">if</span> <span class="keyword">await</span> condition()]</span><br></pre></td></tr></table></figure>

<h1 id="3-5版本"><a href="#3-5版本" class="headerlink" title="3.5版本"></a>3.5版本</h1><h2 id="使用async和await实现协程"><a href="#使用async和await实现协程" class="headerlink" title="使用async和await实现协程"></a>使用async和await实现协程</h2><h2 id="‘-‘解包功能"><a href="#‘-‘解包功能" class="headerlink" title="‘*‘解包功能"></a>‘*‘解包功能</h2><p>*用于解包可迭代对象</p>
<p>**用于解包字典对象</p>
<h2 id="对函数的注释"><a href="#对函数的注释" class="headerlink" title="对函数的注释"></a>对函数的注释</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greeting</span>(<span class="params">name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span> + name</span><br></pre></td></tr></table></figure>

<h2 id="os-scandir"><a href="#os-scandir" class="headerlink" title="os.scandir()"></a>os.scandir()</h2><p>优化的目录迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> os.scandir(path):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> entry.name.startswith(<span class="string">&#x27;.&#x27;</span>) <span class="keyword">and</span> entry.is_file():</span><br><span class="line">        <span class="built_in">print</span>(entry.name)</span><br></pre></td></tr></table></figure>

<h2 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h2><div style="color:#F56C6C">python里面堆是什么</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;777&#x27;</span>, <span class="string">&#x27;55555&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;6666&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(heapq.merge(a, b, key=<span class="built_in">len</span>))</span><br><span class="line">[<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;88&#x27;</span>, <span class="string">&#x27;777&#x27;</span>, <span class="string">&#x27;6666&#x27;</span>, <span class="string">&#x27;55555&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="3-4版本"><a href="#3-4版本" class="headerlink" title="3.4版本"></a>3.4版本</h1><h2 id="asyncio模块"><a href="#asyncio模块" class="headerlink" title="asyncio模块"></a>asyncio模块</h2><div style="color:#F56C6C">协程相关的一个模块，协程这个东西应该研究一下</div>

<h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>枚举这个东西用得很少，或者对比和Java的枚举有什么区别</p>
<h2 id="selectors"><a href="#selectors" class="headerlink" title="selectors"></a>selectors</h2><p>实现高层级高效率的IO复用，之前在socket编程的时候好像有用到，是对select模块的迭代</p>
<h2 id="statistics"><a href="#statistics" class="headerlink" title="statistics"></a>statistics</h2><p>一个数学统计函数</p>
<h2 id="tracemalloc"><a href="#tracemalloc" class="headerlink" title="tracemalloc"></a>tracemalloc</h2><p>用于内存分配的分析</p>
<h1 id="3-3版本"><a href="#3-3版本" class="headerlink" title="3.3版本"></a>3.3版本</h1><p>3.3版本的迭代内容基本都看不懂。。。</p>
<h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><p>也就是venv模块是在这个版本加入的</p>
<h1 id="3-2版本"><a href="#3-2版本" class="headerlink" title="3.2版本"></a>3.2版本</h1><h2 id="添加argparse"><a href="#添加argparse" class="headerlink" title="添加argparse"></a>添加argparse</h2><p>这是一个第三方模块，在这个版本被官方采纳，替换了原本的optparse模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;此脚本运行需要输入必要参数&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;--pid&#x27;</span>, <span class="string">&#x27;-p&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;产品ID，必要参数&#x27;</span>, required=<span class="literal">False</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line">prodcut_id = args.pid</span><br></pre></td></tr></table></figure>

<h2 id="基于字典的日志模块配置"><a href="#基于字典的日志模块配置" class="headerlink" title="基于字典的日志模块配置"></a>基于字典的日志模块配置</h2><p>之前是不支持这种配置格式的，添加之后方便了很多</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging_config = &#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;disable_existing_loggers&quot;</span>: <span class="literal">False</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">logging.config.dictConfig(logging_config)</span><br></pre></td></tr></table></figure>

<h2 id="添加模块concurrent-futures"><a href="#添加模块concurrent-futures" class="headerlink" title="添加模块concurrent.futures"></a>添加模块concurrent.futures</h2><p>这个是线程相关的，灵感来自java，哈哈</p>
<h2 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># format方法添加字符 # 功能</span></span><br><span class="line"><span class="built_in">format</span>(<span class="number">20</span>, <span class="string">&#x27;#o&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;0o24&#x27;</span></span><br><span class="line"><span class="built_in">format</span>(<span class="number">12.34</span>, <span class="string">&#x27;#5.0f&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;  12.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 静默启动功能，隐藏版本信息</span></span><br><span class="line">➜  ~ python3 -q</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># range对象添加count和index方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">2</span>).count(<span class="number">10</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">2</span>).index(<span class="number">10</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># callable内置函数返场</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">callable</span>(<span class="built_in">max</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代工具新增累加函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(accumulate([<span class="number">8</span>, <span class="number">2</span>, <span class="number">50</span>]))</span><br><span class="line">[<span class="number">8</span>, <span class="number">10</span>, <span class="number">60</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Counter类添加运算功能</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tally = Counter(dogs=<span class="number">5</span>, cats=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tally -= Counter(dogs=<span class="number">2</span>, cats=<span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tally</span><br><span class="line">Counter(&#123;<span class="string">&#x27;dogs&#x27;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># datetime添加时区</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timezone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机函数优化，使得整数可以更加均匀的分布</span></span><br><span class="line"><span class="comment"># sort函数使用的timsort算法进行优化</span></span><br></pre></td></tr></table></figure>

<h2 id="线程增加障碍点"><a href="#线程增加障碍点" class="headerlink" title="线程增加障碍点"></a>线程增加障碍点</h2><div style="color:#F56C6C">这个可以详细的了解下</div>
`from threading import Barrier, Thread`

<h1 id="3-1版本"><a href="#3-1版本" class="headerlink" title="3.1版本"></a>3.1版本</h1><p><strong>3.x部分早期版本连Docker都配不出来，所以用python2进行对比</strong></p>
<h2 id="有序字典"><a href="#有序字典" class="headerlink" title="有序字典"></a>有序字典</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="string">&#x27;e&#x27;</span>] = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="format-自动编号"><a href="#format-自动编号" class="headerlink" title="format()自动编号"></a>format()自动编号</h2><p>这个特性我测试2.7里面已经有了，08年的时候发布了3.0，10年的时候发布的2.7</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Sir &#123;&#125; of &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Gallahad&#x27;</span>, <span class="string">&#x27;Camelot&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Sir Gallahad of Camelot&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="碎片-1"><a href="#碎片-1" class="headerlink" title="碎片"></a>碎片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># with语句允许多个上下文</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mylog.txt&#x27;</span>) <span class="keyword">as</span> infile, <span class="built_in">open</span>(<span class="string">&#x27;a.out&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> line <span class="keyword">in</span> infile:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> <span class="string">&#x27;&lt;critical&gt;&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line"><span class="meta">... </span>            outfile.write(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># round函数会返回整数，当传入参数为整数时</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">1123</span>, -<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="number">1100.0</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="number">1100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加Counter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>])</span><br><span class="line">Counter(&#123;<span class="string">&#x27;blue&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;green&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>  IO库使用C进行重写，有2-20倍速度提升</li>
<li>  元组和字典收集机制优化</li>
<li>  UTF-8等解码速度提升2-4倍</li>
<li>  为JSON模块添加了一个C扩展，大幅改进性能</li>
<li>  整数现在存储在内部以 2**15 为基数或以基数存储 2**30（64位计算机上性能提升），以前固定为2**15 </li>
</ul>
<h1 id="x20-3-0版本"><a href="#x20-3-0版本" class="headerlink" title="&#x20;3.0版本"></a>&#x20;3.0版本</h1><h2 id="x20-print"><a href="#x20-print" class="headerlink" title="&#x20;print"></a>&#x20;print</h2><p>print变成了一个方法</p>
<h2 id="不再返回列表"><a href="#不再返回列表" class="headerlink" title="不再返回列表"></a>不再返回列表</h2><p>这个变更主要是为了节省内存，不再直接生成一个列表对象，而是一个可迭代的对象，<div style="color:#F56C6C">而list是对象迭代器，是如何实现的</div></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.keys()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">dict_keys([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># map函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>) :</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x ** <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">map</span>(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x105d682e0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># zip函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped = <span class="built_in">zip</span>(a,b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped</span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x105d5dc40</span>&gt;</span><br><span class="line"><span class="comment"># 这里额外介绍下zip解压语法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">zip</span>(*zipped)</span><br><span class="line">[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><div style="color:#F56C6C">将int这么一个极为基础的数据定义进行修改的原因是什么呢，像Java中会有一个整型缓冲池来进行优化，那么Python如何去优化这些极其常用的变量</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1000000000000000000000000000000000</span>)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;long&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">1000000000000000000000000000000000</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3中不再有maxint这么个东西</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.maxint</span><br><span class="line"><span class="number">9223372036854775807</span></span><br></pre></td></tr></table></figure>

<h2 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h2><div style="color:#F56C6C">离奇</div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>/<span class="number">2</span></span><br><span class="line"><span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h2 id="新语法"><a href="#新语法" class="headerlink" title="新语法"></a>新语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 扩展的可迭代解包</span></span><br><span class="line">(a, *rest, b) = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量生效范围，列表推导的变量不再泄露到语句之外</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 -- vue cli 环境搭建</title>
    <url>/2023/04/13/%E5%89%8D%E7%AB%AF/vue%20cli%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="linux基本开发环境"><a href="#linux基本开发环境" class="headerlink" title="linux基本开发环境"></a>linux基本开发环境</h2><h3 id="zsh命令行"><a href="#zsh命令行" class="headerlink" title="zsh命令行"></a>zsh命令行</h3><ul>
<li><a href="https://segmentfault.com/a/1190000013857738">zsh安装教程</a></li>
</ul>
<h2 id="vue-iview环境"><a href="#vue-iview环境" class="headerlink" title="vue+iview环境"></a>vue+iview环境</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><ul>
<li>安装Python、pip</li>
<li>安装Django框架，创建一个Django项目</li>
<li>安装nodejs</li>
<li>安装cnpm,用cnpm安装vue-cil：sudo cnpm install vue-cli -g</li>
<li>安装git</li>
<li>切换到Django项目根目录：vue-init webpack &lt;前端项目名&gt;</li>
<li>cd到前端项目cnpm install 然后cnpm run dev这时可以浏览器里面访问到vue项目了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动服务并在后台运行</span><br><span class="line">cnpm run dev &amp;</span><br><span class="line">#ssh退出后服务保持继续执行</span><br><span class="line">nohup cnpm run dev &amp;</span><br></pre></td></tr></table></figure></li>
<li>配置Django项目的文件，<a href="https://blog.csdn.net/weixin_41004350/article/details/79626656">教程</a></li>
<li>运行 python manage.py runserver就可以在浏览器中访问了<h3 id="1-前端"><a href="#1-前端" class="headerlink" title="1.前端"></a>1.前端</h3><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4></li>
<li>这东西好像是不需要安装，直接在js文件中引入就可以了</li>
<li>npm install vue</li>
<li>安装cnpm：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></li>
<li></li>
</ul>
<h4 id="iview"><a href="#iview" class="headerlink" title="iview"></a>iview</h4><h3 id="2-服务器（node-js-nginx）"><a href="#2-服务器（node-js-nginx）" class="headerlink" title="2.服务器（node.js/nginx）"></a>2.服务器（node.js/nginx）</h3><h4 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h4><ul>
<li>已经有了，现在的环境是开发机也没有管理员权限，<a href="http://www.runoob.com/nodejs/nodejs-tutorial.html">nodejs教程</a>这个应该是官方的吧，很详细<h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4></li>
</ul>
<h3 id="3-后端"><a href="#3-后端" class="headerlink" title="3.后端"></a>3.后端</h3><h4 id="Python-Django框架"><a href="#Python-Django框架" class="headerlink" title="Python Django框架"></a>Python <a href="https://www.runoob.com/django/django-tutorial.html">Django框架</a></h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul>
<li>它算是Python的一个模块吧，所以可以通过pip3来安装，好像也有像apt-get之类的安装方式，没有试过</li>
<li>pip3安装：sudo pip3 install Django</li>
<li>查看Django安装目录：先进入Python命令行import django  然后输入django回车，命令行打印安装目录</li>
<li>新建项目：python3 /usr/local/python3.6.4/lib/python3.6/site-packages/django/bin/django-admin.py startproject fireflyPro<ul>
<li>这个地方很坑，首先教程里面说的方法是django-admin startproject <projectName>,这个应该是要把django-admin加入环境变量之后才可以直接调用，没去弄</projectName></li>
<li>不配环境变量就去找了Django的安装目录并找到django-admin.py文件，然后用Python运行它，结果环境里面有两个版本的Python还会报错，所以还需要在前面指定Python版本</li>
</ul>
</li>
</ul>
<h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h3><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><ul>
<li>npm用来安装nodeJs的模块，现在很多的技术都有自己的这种安装模块的工具，类似的Ubuntu的apt-get、Python的pip</li>
<li>现在nodeJs内置了npm，不用自己安装了，查看版本：npm -v</li>
<li>安装模块：npm install <Module name></Module></li>
<li>安装模式<ul>
<li>本地安装：将安装包放到./node_modules下（运行npm所在的目录，没有的话会自动生成），通过require引用</li>
<li>全局安装：将安装包放到/usr/local下或者个人node的安装目录，可以直接在命令行使用</li>
<li>全局安装是要管理员权限的，很尴尬的开发环境没有，而且实际在我用本地安装的时候它把安装包放到了/data/home/luoyang/node_modules下面去了</li>
</ul>
</li>
<li>卸载模块：npm uninstall express</li>
<li>查看安装的模块<ul>
<li>npm list  和 npm list -g(不知道本地查看有没有意义)</li>
<li>查看牧歌模块的版本号：npm -list <Module name></Module></li>
</ul>
</li>
<li>更新：npm update <module name></module></li>
<li>搜索：npm search <m n>(这个应该是在网络上搜索是否有该模块信息)</m></li>
<li>后续还有创建模块注册用户发布模块等操作，在注册用户的时候出问题了，这块以后有需要再去弄</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 -- vue接入阿里巴巴图标库</title>
    <url>/2023/04/13/%E5%89%8D%E7%AB%AF/vue%E6%8E%A5%E5%85%A5%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%9B%BE%E6%A0%87%E5%BA%93/</url>
    <content><![CDATA[<h1 id="阿里巴巴图标库"><a href="#阿里巴巴图标库" class="headerlink" title="阿里巴巴图标库"></a>阿里巴巴图标库</h1><p><a href="https://www.iconfont.cn/manage/index?spm=a313x.7781069.1998910419.23&manage_type=myprojects&projectId=3606086">图标库</a></p>
<h1 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h1><h2 id="下载图标素材"><a href="#下载图标素材" class="headerlink" title="下载图标素材"></a>下载图标素材</h2><ul>
<li>  访问图标库</li>
<li>  创建一个自己的项目，没有什么要求，谁便起个名称就行</li>
<li>  找到自己要的图标，添加到购物车后添加到项目</li>
<li>进入项目页面，以symbol方式下载到本地（目前只有这种方式支持彩色），解压后得到如下文件目录<br>  <img src="/img/16613099858181661309984903.png"></li>
</ul>
<h2 id="添加到vue项目"><a href="#添加到vue项目" class="headerlink" title="添加到vue项目"></a>添加到vue项目</h2><ul>
<li>  将素材文件复制到<code>src/assets/icons</code>目录，icons为新建的文件夹，名称和位置都无所谓，放这里比较标准</li>
<li>  在<code>src/main.js</code>中引用资源</li>
</ul>
<!---->

<pre><code>...
import &#39;./assets/icons/iconfont&#39;
import &#39;./assets/icons/iconfont.css&#39;
...
</code></pre>
<ul>
<li>  在一个父组件<code>src/views/HomeView.vue</code>中添加样式（这一步非必须只是用起来方便）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.icon &#123;</span><br><span class="line">  height: 25px;</span><br><span class="line">  width: 25px;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="vue中使用"><a href="#vue中使用" class="headerlink" title="vue中使用"></a>vue中使用</h2><ul>
<li>  在需要图标的地方添加一下代码，只要将href中的名称换成下载图标的名称即可（可以通过打开demo文件查看图标名称信息）</li>
</ul>
<!---->

<pre><code>&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;
  &lt;use xlink:href=&quot;#icon-wanopamscloudappxiaochengxuyunyingyong&quot;&gt;&lt;/use&gt;
&lt;/svg&gt;
</code></pre>
<h1 id="添加新图标"><a href="#添加新图标" class="headerlink" title="添加新图标"></a>添加新图标</h1><p>需要添加新图标时，到图标库中把想要的图标加入项目，再次下载并覆盖到vue项目即可</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Typora + github搭建教程</title>
    <url>/2023/04/17/%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/hexo/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hexo是一个开源的博客系统，对md有很好的支持，在本地安装后，可以推送到git上开启page即可使用github的服务器资源</p>
<p><strong>优点</strong>：</p>
<ul>
<li>md格式本身的通用性强，且无迁移成本</li>
<li>Typora编辑md非常方便</li>
<li>hexo的页面优化做得不错，解除软件和终端的限制</li>
<li>点名批评有道云，对md的支持是真的差，还有致命bug<ul>
<li>一个哥们写的开源项目，可以用来<a href="https://github.com/DeppWang/youdaonote-pull">导出有道云笔记Git地址</a>（官方自己不再提供批量导出功能）</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>多端编辑不方便，需要搭建环境，列举一些解决的思路<ul>
<li>封装为Docker，进行一键化环境部署</li>
<li>在服务端的admin中进行简单的编辑</li>
</ul>
</li>
</ul>
<h1 id="一、新设备搭建"><a href="#一、新设备搭建" class="headerlink" title="一、新设备搭建"></a>一、新设备搭建</h1><p>下面的方式太繁琐了，后面封装为Docker</p>
<ul>
<li><p>克隆git项目</p>
</li>
<li><p>环境依赖</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nodejs</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install --save hexo-admin</span><br><span class="line"><span class="comment"># 字数统计</span></span><br><span class="line">npm install hexo-wordcount --save</span><br><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>



<h1 id="二、相关配置"><a href="#二、相关配置" class="headerlink" title="二、相关配置"></a>二、相关配置</h1><h2 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h2><h3 id="图床配置"><a href="#图床配置" class="headerlink" title="图床配置"></a>图床配置</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>图片插入</strong></p>
<p>在Typora的偏好设置中选择图像，配置插入图片时，自动将图片复制到<code>./img</code>目录中</p>
<p><img src="/img/image-20230414194621453.png" alt="image-20230414194621453"></p>
<p><strong>打包插件</strong>（未完成）</p>
<p>需要安装插件<code>npm install hexo-asset-image --save</code>，该插件原本是适配方案三的，需要进行修改，将<code>node_modules/hexo-asset-image/index.js</code>内容修改为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">  <span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">  <span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">  link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">      <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">        <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">        <span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">            !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) &#123;</span><br><span class="line">          <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">          <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">          <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.<span class="title function_">shift</span>();</span><br><span class="line">          src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">          $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + <span class="string">&#x27;img/&#x27;</span> + src);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);</span></span><br><span class="line">          <span class="keyword">var</span> bash_path = data.<span class="property">asset_dir</span>.<span class="title function_">split</span>(<span class="string">&#x27;_posts&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">          <span class="keyword">var</span> img_path = <span class="built_in">decodeURI</span>(bash_path + <span class="string">&#x27;_posts/&#x27;</span> + link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">slice</span>(<span class="number">3</span>,-<span class="number">2</span>).<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="string">&#x27;/img/&#x27;</span> + src)</span><br><span class="line">          <span class="keyword">var</span> target_path = <span class="built_in">decodeURI</span>(bash_path + <span class="string">&#x27;img/&#x27;</span> + src)</span><br><span class="line">          fs.<span class="title function_">copyFile</span>(img_path, target_path, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(target_path + <span class="string">&#x27; File was copied successfully!&#x27;</span>);</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将各个img目录下的图片统一复制到<code>blog/source/img</code>中，hexo打包时将此目录文件复制到public的更目录，从而到达服务端访问目的</li>
<li>将md中图片的路径从<code>img/123.png</code>修改为<code>/img/123.png</code>来保证服务端通过绝对路径访问</li>
</ul>
<h4 id="方法二-（已放弃）"><a href="#方法二-（已放弃）" class="headerlink" title="方法二 （已放弃）"></a>方法二 （已放弃）</h4><p><strong>路径配置</strong></p>
<p>首先在hexo项目的source目录下创建文件夹img用于存储图片，hexo项目在打包的时候会将该文件夹复制到更目录下，所以对于服务端的页面来说，图片的访问地址为<code>img/123.png</code>，但是Typora通过这个绝对路径是无法找到图片的</p>
<p>配置图片根目录：菜单栏中’格式’–图像–设置图片根目录（设置为hexo的source目录）</p>
<p><strong>图片插入</strong></p>
<p>在Typora的偏好设置中选择图像，配置插入图片时，自动将图片复制到 hexo 的 source/img 目录中，图床脚本可以下岗了</p>
<p><img src="/img/image-20230413170824098.png" alt="image-20230414194621453"></p>
<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>一个比较通用的方法，hexo打开相关配置，在使用自己的命令创建文章的时候会生成一个同名的文件夹，用于存放该md的图片，后续打包过程中将md中图片的路径进行修改，来达到资源访问，这种方法逻辑有些绕，且会创建好多相关文件夹，让文件目录看起来混乱，这里就不进行详细说明了，可以自行搜索插件hexo-asset-image</p>
<h1 id="三、首次搭建"><a href="#三、首次搭建" class="headerlink" title="三、首次搭建"></a>三、首次搭建</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>依赖nodejs，这里不赘述nodejs安装方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装hexo依赖</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹初始化一个hexo项目</span></span><br><span class="line"><span class="built_in">mkdir</span> blog</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看下生成了一下目录文件</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">_config.landscape.yml node_modules          scaffolds             themes</span><br><span class="line">_config.yml           package.json          <span class="built_in">source</span>                yarn.lock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态部署和启动服务</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h2 id="git部署"><a href="#git部署" class="headerlink" title="git部署"></a>git部署</h2><ul>
<li><p>  在git上创建一个项目<a href="https://github.com/fireflyso/fireflyso.github.io">fireflyso/fireflyso.github.io</a></p>
</li>
<li><p>修改本地配置文件_config.yml</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:fireflyso/fireflyso.github.io.git  #你的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>  安装部署插件：<code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>部署</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean   <span class="comment">#清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo d       <span class="comment">#自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h2><ul>
<li><p>安装主题，<a href="https://butterfly.js.org/posts/21cfbf15/">官方教程</a><br>  # 使用gitee安装，github网络不稳定<br>  git clone -b master <a href="https://gitee.com/immyw/hexo-theme-butterfly.git">https://gitee.com/immyw/hexo-theme-butterfly.git</a> themes/butterfly</p>
<pre><code>  # 修改hexo根目录_config.yml文件
  theme: butterfly
  
  # 安装渲染器（非必要）
  npm install hexo-renderer-pug hexo-renderer-stylus --save
</code></pre>
</li>
<li><p>安装admin插件<br>  npm install –save hexo-admin</p>
</li>
</ul>
]]></content>
      <categories>
        <category>安装教程</category>
      </categories>
      <tags>
        <tag>安装教程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统 -- linux--convert命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux--convert%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="mac上使用"><a href="#mac上使用" class="headerlink" title="mac上使用"></a>mac上使用</h3><p>默认没有这个命令，需要先安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">brew install imagemagick</span><br><span class="line">brew install jpegoptim</span><br></pre></td></tr></table></figure>

<h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><h3 id="修改图片分辨率"><a href="#修改图片分辨率" class="headerlink" title="修改图片分辨率"></a>修改图片分辨率</h3><p><a href="https://blog.csdn.net/mybelief321/article/details/9969949">参考教程</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将宽高中较小的值修改为600，保持原比例</span></span><br><span class="line">convert -resize <span class="number">600</span>×<span class="number">600</span> src.jpg dst.jpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将宽高中较小的值修改为300，保持原比例</span></span><br><span class="line">convert -resize “<span class="number">300</span>×<span class="number">300</span>^” src.jpg dst.jpg</span><br></pre></td></tr></table></figure>

<h3 id="修改图片格式"><a href="#修改图片格式" class="headerlink" title="修改图片格式"></a>修改图片格式</h3>]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统 -- linux和mac中命令行别名配置</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%92%8Cmac%E4%B8%AD%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p>在~/.ssh/config文件中配置，没有就新建一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host firefly</span><br><span class="line"></span><br><span class="line">HostName 119.23.34.118</span><br><span class="line">User root</span><br><span class="line">Port 22</span><br></pre></td></tr></table></figure>
<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>使用zsh的时候将配置写入~/.zshrc文件中，下面是别名配置的demo，当然还可以配置路径什么的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias ssinit=&#x27;nohup sslocal -c /etc/shadowsocks/config.json &amp;&gt;&gt; /var/log/sslocal.log &amp;&#x27;</span><br><span class="line">alias sson=&#x27;export http_proxy=http://127.0.0.1:8118 &amp;&amp; export https_proxy=http://127.0.0.1:8118 &amp;&amp; systemctl start privoxy&#x27;</span><br><span class="line">alias ssoff=&#x27;unset http_proxy &amp;&amp; unset https_proxy &amp;&amp; systemctl stop privoxy &amp;&amp; pkill sslocal&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="sshpass"><a href="#sshpass" class="headerlink" title="sshpass"></a>sshpass</h3><p>通过上面配置ssh config的方式还是需要自己输入密码，可以通过<a href="https://my.oschina.net/Julian1988/blog/144261">安装sshpass</a>来解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#大致的安装</span><br><span class="line">#mac上就是下载，然后解压，运行写好的脚本就差不多了，运行命令</span><br><span class="line">sshpass -p 123456 scp /home/file.txt root@10.0.0.37:/home/copy</span><br><span class="line"></span><br><span class="line">#把这个写到系统的别名里面就可以直接用了</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统 -- 深入理解计算机系统</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="第一章：计算机系统漫游"><a href="#第一章：计算机系统漫游" class="headerlink" title="第一章：计算机系统漫游"></a>第一章：计算机系统漫游</h1><h2 id="1-1-约定"><a href="#1-1-约定" class="headerlink" title="1.1 约定"></a>1.1 约定</h2><ul>
<li>  本次分享的内容涉及到的计算机的一些机制都以现在世界上现存的典型协议进行描述，不对一些为特殊场景下进行定制的协议进行阐述，例如我们会认为文本字符在计算机上的表示是通过基础的ASCII标准，涉及到字符存储时不去对别的标准原理进行介绍。</li>
<li>  由于第一章里面直接对整个系统的运行进行了笼统的介绍，涉及的内容太多，<font color="red">所有笔记中指名道姓提及本书后续某章会详细讲解的内容和问题，朋友们就别问了，免得大家都尴尬 ：）</font></li>
</ul>
<h2 id="1-2概述"><a href="#1-2概述" class="headerlink" title="1.2概述"></a>1.2概述</h2><p>本章我们试图去简单的介绍一个最基本的hello world程序的运行原理，实际上，这一整本书就是在详细的描述这一程序运行过程中计算机各个模块之间的配合调度,以下为hello.c文件内容</p>
<pre><code>#include &lt;stdio.h&gt;

int main()
&#123;
    printf(&quot;hello world\n&quot;);
    return 0;
&#125;
</code></pre>
<h2 id="1-3-hello-world生命周期"><a href="#1-3-hello-world生命周期" class="headerlink" title="1.3 hello world生命周期"></a>1.3 hello world生命周期</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>上面的hello.c文件在磁盘上是以一串byte格式进行的存储，当我们用文本工具打开时会翻译为方便人类阅读的格式</p>
<ul>
<li>编码（把人类字符翻译为byte数据的过程）：<ul>
<li>  ASCII：这里也简单的对ASCII编码进行介绍，每一个字符都被翻译为一个唯一与其对应的整数值，也就是一个byte（byte 的取值范围为 1000 0000 到 0111 1111）</li>
<li>  Unicode：为了解决ASCII码不能容积而产生的编码标准，通常占用两个字节</li>
<li>  UTF8：为了解决Unicode造成的空间浪费，UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，汉字通常是3个字节（所以UTF8天生兼容了远古时期的ASCII码数据）</li>
<li>  关于汉字的存储，在txt的格式下汉字其实也只是占用了一个字节，这里有一帮哥们为了节省空间为汉字做了一个汉字库（16*16库需求282.5KB磁盘空间），真正存储的时候是存储了汉字在该库里面的地址（内码）</li>
</ul>
</li>
<li>  计算机中数据的存储：所有的信息都是以一串byte方式进行的存储。</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>hello.c是高级语言（C语言），需要先转化为一系列低级机器语言指令（存储到hello文件中），这个过程叫编译，编译的工具叫编译器驱动程序。<br><img src="/img/17359.png" alt="image"><br>为何要了解编译过程和原理（<font color="red">细节本书第六章会讲</font>，这里受篇幅所限我就不展开讲了，就当我知道：）:</p>
<ul>
<li>  优化程序性能</li>
<li>  理解链接是出现的错误</li>
<li>  避免安全漏洞</li>
</ul>
<p>由于不同的语言有不同的运行环境，这个地方不好统一详尽的介绍，只对Java的运行过程有过一些探索，如果大家有兴趣，推荐《深入理解java虚拟机》</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行是指，处理器读取磁盘上编译后的文件hello到内存并逐一的解释内存中的指令的过程。</p>
<p>为了能解释运行的过程，我们要先了解下计算机的硬件组成</p>
<h2 id="1-4-计算机硬件组成"><a href="#1-4-计算机硬件组成" class="headerlink" title="1.4 计算机硬件组成"></a>1.4 计算机硬件组成</h2><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>用于连接计算机各个组件的通信管道，通常被设计为传输定长的字节块，系统中字长为4字节的就是我们所说的32位计算机，字长为8字节的是64位计算机。</p>
<h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p>输入输出设备，典型的IO设备：鼠标、键盘、显示器以及硬盘。（<font color="red">第六章会详细讲解IO设备的工作原理</font>）</p>
<h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><p>主存临时存储设备由一组动态随机存取存储器（RAM）芯片组成，我们所说的内存就是由主存（RAM）和只读存储器（ROM）组成。</p>
<h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><p>中央处理单元（CPU）简称处理器，是解释或执行存储在主存中指令的引擎。</p>
<ul>
<li>  程序计数器：CPU的核心是一个大小为一个字（字的长度决定了计算机是多少位的）的存储设备（寄存器）也称为程序计数器。</li>
<li>  在我个人所了解的模型里面程序是以栈的方式来存储指令，而程序计数器可以看做指向栈顶的指针，CPU会一直执行程序计数器所指向的指令（多线程切换的时候就是要记录下这个程序计数器的位置，再次获得CPU使用权的时候继续执行）</li>
<li>  <font color="red">本书第四章会详细讲解处理器是如何实现的，第五章会讲解处理器工作原理</font></li>
</ul>
<h2 id="1-5-再次运行hello"><a href="#1-5-再次运行hello" class="headerlink" title="1.5 再次运行hello"></a>1.5 再次运行hello</h2><p>在了解了计算机的大体组成后，我们已经极度膨胀，再次来探究hello的运行过程。于是我们在shell命令行执行：</p>
<pre><code>./hello
</code></pre>
<p><img src="/img/17499.png" alt="image"><br>简单描述：将hello指令从磁盘复制到寄存器、再从寄存器复制到主存、寄存器去执行主存上的指令、将“hello world\n”复制到寄存器再复制到显示设备上。</p>
<ul>
<li>  这个时候朋友们就要问了，为啥要复制来复制去，为什么寄存器不直接从磁盘上读“hello  world\n”然后丢给显示器</li>
</ul>
<pre><code>解：磁盘读写速度慢，很慢，非常慢；寄存器的读写速度大概是磁盘的10亿倍，相反的寄存器的存储空间非常小（几百字节），
所以我们需要先把需要用到的数据写到内存里面去（内存的读写比磁盘快1000w倍，比寄存器慢100倍），之后寄存器去内存
里面取指令进行执行。
</code></pre>
<ul>
<li><p>  其实在上面的流程里面有一部分是可以被优化的，就是一开始从磁盘读取到内存的过程还是经过了寄存器，这部分其实和我们的目标不符合，有一个技术叫直接存储器存取技术（DMA，第六章会详解），它可以直接将指令从磁盘读取到内存而不经过寄存器</p>
</li>
<li><p>  这个时候朋友们又要问了，既然是这样那我们把所有数据都存到内存甚至是寄存器不就好了吗？</p>
</li>
</ul>
<pre><code>这里给个出一个参考价格，一个3000左右CPU的三级缓存数据大概是8*32k、8*512k、2*16M，
一个8G内存条价格大概300，一个2T的机械硬盘大概350
</code></pre>
<ul>
<li>  所以在向生活低头之后，我们选择用缓存来解决CPU和磁盘之间日益增长的阶级矛盾。</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>目前大多数的CPU都会采用三级缓存的方式来降低CPU和内存之间数据交互的时间消耗，下面是一个典型的计算机系统中缓存层级图：<br><img src="/img/17576.png" alt="image"><br>所有上层的存储器都可以看做是下层存储器的高速缓存</p>
<h2 id="1-6-操作系统"><a href="#1-6-操作系统" class="headerlink" title="1.6 操作系统"></a>1.6 操作系统</h2><p>让我们回顾刚才hello程序运行的流程，我们直接是向shell程序发起运行的指令，这时候shell其实是不能直接访问磁盘和CPU之类的硬件设备的，它需要依赖操作系统提供的服务，以下是计算机系统的分层示意图：<br><img src="/img/17586.png" alt="image"><br>操作系统的作用：</p>
<ul>
<li>防止应用滥用硬件资源（这里把操作系统看做一个公正的裁判，但有时候裁判也会耍流氓）<br>  <img src="/img/17606.png" alt="image"></li>
<li>  向应用程序提供简单一致的底层驳杂硬件的调用接口（不同的硬件通过对应的驱动程序和操作系统达成统一，操作系统再将统一的标准接口面向应用程序）</li>
</ul>
<p>下面我们对操作系统的几个重要特性进行简单的介绍</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是对计算机上正在运行的程序的一种抽象，它使得程序（例如我们的hello）看上去是在独占计算机的硬件资源，是计算机科学中最重要和成功的概念之一。</p>
<p>一个CPU在一个时间上只能执行一个进程，并发的原理是处理器来回切换不同的进程，CPU离开时记录进程执行的上下文（寄存器PC、主存内容等）状态，进程再次获得CPU的调用时根据记录的状态继续任务</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>以前我们认为一个进程只有一个单一的控制流，但在现代计算机系统中，进程是由多个称为线程的单元组成的，线程都是运行在进程的上下文中，所以同一个进程下的线程间共享资源，在目前处理器普遍多核的情况下，多线程很更好的利用系统资源提高效率（在本书第12章会详解并发的概念）</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>“虚拟内存是一个抽象概念，它为每个进程提供一个假象，即每个进程都在独占地使用主存”</p>
<p>“基本思想是把一个进程虚拟内存的内存存储到磁盘上，然后用主存做为磁盘的高速缓存”</p>
<p>第九章会解释它如何工作，这里的细节不是很清楚，但个人猜测这个策略应该是导致电脑硬盘从机械升级到固态后能很好的缓解内存压力而大幅度提高电脑整体运行速度的原因。</p>
<p>这里有一个小建议，如果大家想要提高旧电脑的运行速度，绝大多数的情况下升级一个固态硬盘都是性价比最高的方案，不用扩展内存，一个128G的固态不到200块，可以带来好几倍的使用流畅度。</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>“文件就是字节序列，仅此而已”，前面有简单的描述过字节byte的一个情况。</p>
<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>到目前为止的介绍中，我们都把计算机看为一个孤岛，实际上今天的我们片刻都离不开网络，网络也可以视为计算机的一个IO设备。</p>
<p>就hello而言，我们可以通过telnet应用在远程主机上运行hello程序，示意图：<br><img src="/img/17706.png" alt="image"><br>在本书第11章中会介绍如何构建一个网络应用程序，搭建一个简单的web服务器。</p>
<h2 id="1-7-一些重要概念"><a href="#1-7-一些重要概念" class="headerlink" title="1.7 一些重要概念"></a>1.7 一些重要概念</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发：指一个同时具有多个活动的系统；并行：指通过并发来使系统运行更快。</p>
<ul>
<li>线程级并发：同进程下多个线程的并发<ul>
<li>  超线程：一个CPU核心同时处理多个控制流（线程或者进程），i7单核可以同时处理两个控制流。</li>
<li>  多核：由于单核模拟并发是在不断的切换控制流，这个过程是需要消耗资源的，所以多核心在并发上的效率提升不只是倍数。（其实在多核和超线程提出来之前，大家对并发的热情并不高，单个控制流执行下的并发成本高）</li>
</ul>
</li>
<li>  指令级并发：在较低的抽象层面上，处理器同时处理多条指令。（第四章中会讲解流水线pipelining模型中指令的调度来详细解释）</li>
<li>  单指令、多数据并行：在最低的层次上，处理器允许一条指令产生多个可以并行执行的操作，称为单指令、多数据并行，SIMD并行。</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统 -- 计算机操作系统</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><h4 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1. 并发和并行"></a>1. 并发和并行</h4><ul>
<li>并发：以前的计算机只有一个核心的时候，想要让多个任务同时执行，一般来说一个程序的运行都是把数据从磁盘写入内存，然后去cpu去取内存中的数据来做计算，计算完成后再输出结果，这个过程中磁盘的读写是相对慢的环节，如果所有的程序都顺序的执行的话，cpu和磁盘这块总有人的空着的，显然效率就很低了，所以要并发的执行，一个程序在读写磁盘的时候另一个程序去使用cpu做运算，一般我们不会去研究磁盘的并发情况，只是关注cpu的并发，并发是指在一段时间内多个程序同时运行，注意在一个时间节点上一定是只有一个程序在占用cpu的（单核），操作系统是通过进程和线程来调度程序的并发。（==为什么不关注磁盘的并发情况==）</li>
<li>并行：这是需要用多核处理器来实现的，即使是在多核的情况下并发也同样重要</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>数据持久化 -- 事务原理</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>事务是一组满足ACID特征的操作，可以通过commit提交或者Rollback回滚</p>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li>原子性（Atomicity）<ul>
<li>这个地方的原子性和物理里面的原子性是一个道理，事务被认为是对数据库操作的最小单元，为什么这么说呢，为了数据库的信息安全性，我们规定事务要么整个成功要么整个失败，不可能是执行了半个事务，那样开发者就无法确定数据库中信息的状态</li>
<li>回滚：事务在执行的过程中出现了错误可以进行回滚，有个东西叫做回滚日志，里面记录了事务所执行的修改操作，回滚的时候再反向执行这些操作</li>
</ul>
</li>
<li>一致性：数据在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的</li>
<li>隔离性：一个事务所做的修改在最终提交前，对其他事务是不可见的。</li>
<li>持久性：<ul>
<li>一旦事务提交，则其所作的修改将会永远保存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失，使用重做日志来保证持久性。</li>
<li>事务之所以有这么个性质就是为了能营地数据库崩溃的情况<h4 id="AUTOCOMMIT"><a href="#AUTOCOMMIT" class="headerlink" title="AUTOCOMMIT"></a>AUTOCOMMIT</h4>MySQL默认采用自动提交模式，如果不是显式使用start transaction语句来开始一个事务的话，每个查询都会被当做一个事务来自动提交；这会导致一个问题，用别的数据库的时候操作完成后也没有提交的习惯，需要注意的<h2 id="二、并发一致性问题（数据库面临的主要问题）"><a href="#二、并发一致性问题（数据库面临的主要问题）" class="headerlink" title="二、并发一致性问题（数据库面临的主要问题）"></a>二、并发一致性问题（数据库面临的主要问题）</h2>在没有并发的情况下，事务串行执行，原子性是在任何情况下都能保证的，这时候也不存在隔离性的问题，所以数据的一致性就能得到保证。</li>
</ul>
</li>
</ul>
<p>但是在并发的环境下，事务的隔离性就很难保证，因此会出现很多并发一致性问题</p>
<h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>t1和t2两个事务都对一个数据进行修改，t1先改，t2后改，t2的修改覆盖了t1的修改，比如ab两个售票点读取出了航班的余票是16，a卖了一张修改数据库余票-1为15，b也卖了一张修改数据库余票-1为15，这个时候就出问题了</p>
<h4 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h4><p>T1修改了一个数据，T2去读取了这个数据，T1回滚了这次修改，T2读到的数据是假数据</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>T1读取了一个数据，T2修改了这个数据，当T1再次去读这个数据的时候读取的结果第一次不一样</p>
<h4 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h4><p>T1读取了某个范围的数据，T2在这个范围内插入了新的数据，T1再次去读这个范围的数据，发现和第一次读取的数据不同</p>
<p>不难发现所有问题的产生主要因为事务的隔离性被破坏了，一个事务在操作的过程中另一个事务，解决方法是通过并发控制来保证隔离性，这类似于线程锁，要是让用户来实现会相当麻烦，数据库管理系统提供了事务的隔离级别，其实就是实现了不同程度的安全锁，让用户能直观的去选择一种实现方案来解决问题</p>
<h2 id="三、封锁（事务隔离级别的实现原理）"><a href="#三、封锁（事务隔离级别的实现原理）" class="headerlink" title="三、封锁（事务隔离级别的实现原理）"></a>三、封锁（事务隔离级别的实现原理）</h2><h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><p>MySQL来说提供了两种封锁粒度：行级锁、表级锁</p>
<p>这个和线程锁的思想差不多，不过数据库对效率的要求更高</p>
<p>尽量只锁定需要修改的那个部分（或者对修改会造成影响的部分），锁定的数据越少，发生锁争用的可能也就越小，系统的并发程度就越高</p>
<p>另一方面，锁定的资源越精确，那很可能需要的锁的数量就越多，而锁的各种操作（获取、检查状态、释放）都会增加系统的开销。所以精确度越高那系统开销就越大</p>
<p>结合着两个点来说，在选择的时候要根据服务器的性能来做权衡</p>
<h4 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h4><ul>
<li>读写锁：简单解释一下<ul>
<li>读锁：一个事务对数据的对象（可能是行可能是表，看决策是怎么做的）加了读锁之后，就可以对它进行读取了，此时别的事务最多只能对这个对象加读锁，也就是最多只能看看，不可能再修改了</li>
<li>写锁：一个事务对数据对象加了写锁之后，别的事务就不能再对它加任何锁了，也就是不能读写，这个时候一旦读写就可能出问题嘛</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础 -- DNS</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/DNS/</url>
    <content><![CDATA[<p>DNS（Domain Name System）</p>
<p>定义：</p>
<p>网络通信中通过ip确定主机的地址，但这个ip是一串数字，不便于记忆，所以有了dns解析，把这些ip地址包装成一个容易记忆的域名。</p>
<p>域名解析：</p>
<p>dns通过域名去定位真实ip的过程叫做域名解析，这个地方有两种方法，一种是在本机的host文件中配置相应的域名映射，这样在本机上即已可以通过域名去访问对应的ip；但是明显是不可能为每个客户端都去配置host文件的，所以需要在一台主机上搭建一个dns服务器，网络中没个请求都通过这个dns去做域名解析；</p>
<p>这个地方本地的域名对应配置叫做静态解析，dns叫做动态解析，本地发出的请求是先走静态解析再做dns解析，所以可以把常用的域名映射写入本地的静态映射中从而提高访问效率。</p>
<p>域名层级：</p>
<p>提供一个案例域名<a href="http://www.google.com/">www.google.com</a>   理论上说后面省略了根域名.root 也就是完整的应该是<a href="http://www.google.com.root/">www.google.com.root</a>  但我访问这个域名实际是访问不通的</p>
<p>.root  是根域名  .com  是顶级域名  .google  是次级域名  www  是三级域名</p>
<p>域名解析的原理是通过根域名服务器找到顶级域名服务器依次向下查找，那么dns如何知道根域名服务器的ip地址的，世界上现有13台根域名服务器，这个东西基本是不会发生改变的，所以被内置到了dns里面，每1000个小时才会重新做一次查询</p>
<p>DNS先查找根域名服务器ip，取13个服务器中第一个返回的作为缓存，后续的解析都向这台服务器发起请求</p>
<p>常见的顶级域名：表示工商企业的 .com，表示网络提供商的 .net，表示非盈利组织的 .org等</p>
<p>DNS污染：</p>
<p>一般来说，网站在互联网上一般都有可信赖的域名服务器，但为减免网络上的交通，一般的域名都会把外间的域名服务器数据暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有相关网域的局域域名服务器的缓存受到污染，就会把网域内的电脑导引往错误的服务器或服务器的网址。</p>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础 -- HTTP</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HTTP/</url>
    <content><![CDATA[<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>URI包含URL和URN（不是很明白这是什么，后面在看看）</p>
<ul>
<li>  URI（Uniform Resource Identifier，统一资源标识符）</li>
<li>  URL（Uniform Resource Locator，统一资源定位符）</li>
<li>  URN（Uniform Resource Name，统一资源名称）</li>
</ul>
<h3 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h3><ul>
<li>  请求</li>
<li>  响应</li>
</ul>
<h2 id="二、HTTP方法"><a href="#二、HTTP方法" class="headerlink" title="二、HTTP方法"></a>二、HTTP方法</h2><p>从上面的请求报文中能看到在第一行开头就是方法字段</p>
<ul>
<li>  GET：获取资源，目前使用最多的方法</li>
<li>  HEAD：获取报文首部，和GET类似，只是不返回报文实体主体部分，多用于确认url的有效性以及资源更新的日期等（大概意思是只返回了请求资源的描述信息而不要内容）</li>
<li>  POST：传输实体，主要用来传输数据，get主要用来获取资源，很多时候请求中包含了用户数据，当然也可以把数据都拼接到get的url中，但是这样会暴露用户信息，关于get和post后面还会详细说明</li>
<li>  PUT：上传文件，该方法自身不带验证机制，任何人都可以上传文件，存在安全问题，一般不会去使用</li>
<li>  PATCH:对资源进行部分修改，没见过</li>
<li>  DELETE:和put的作用相反，删除文件，同样不带验证机制</li>
<li>  OPTIONS：查询支持的方法，查询服务器接口支持的方法，以前写PHP的时候post类型的请求会先发起一个options然后才进行post的真正请求</li>
<li>  CONNECT:要求在与代理服务器进行通信时建立隧道</li>
<li>  TRACE:追踪路径</li>
</ul>
<h2 id="三、HTTP状态码"><a href="#三、HTTP状态码" class="headerlink" title="三、HTTP状态码"></a>三、HTTP状态码</h2><ul>
<li>1XX：信息性状态码，接受请求正在处理<ul>
<li>  100 Continue：一切正常，客户端可以继续发送请求或者忽略这个响应</li>
</ul>
</li>
<li>2XX：成功，请求正常处理完毕<ul>
<li>  200 OK</li>
<li>  204 No Content :请求已经处理成功，但返回的响应报文不包含实体的主体部分（字面意思，没有返回内容），有的请求只是需要像服务器发送一个信息而不需要服务器返回数据。</li>
<li>  206 Partial Content:客户端进行了范围请求，而服务器返回了对应内容。</li>
</ul>
</li>
<li>3XX : 重定向<ul>
<li>  301 Moved Permanently：永久性重定向</li>
<li>  302 Found：临时性重定向</li>
<li>  303 See Other : 相比302，303明确指出客户端应该使用get方法（据说大多数的浏览器在301和302下都会把post改成get，而http协议规定他俩是不能改请求方法的）</li>
<li>  304 Not Modified : 如果请求报文首部包含一些条件（If-Match,If-Modified-Since等），如果不满足条件，则服务器返回304（==这个好像是有关缓存策略的，后面应该会有详细的说明==）</li>
<li>  307 Temporary Redirect : 临时重定向，与302类似，要求浏览器不要把post改为get</li>
</ul>
</li>
<li>4XX：客户端错误<ul>
<li>  400 Bad Request：请求报文中存在语法错误（经常是请求方法不对post和get没和接口对应好）</li>
<li>  401 Unauthorized：缺乏身份认证信息或者认证失败</li>
<li>  403 Forbidden：身份认证成功了，但是对资源没有访问的权限</li>
<li>  404 Not Found</li>
</ul>
</li>
<li>5XX：服务器错误<ul>
<li>  500 Internal Server Error：这个可能就是服务器上对应的程序出错了</li>
<li>  503 Service Unavailable：服务器宕机，一般是暂时性的，不知道程序怎么判断是不是暂时性的</li>
</ul>
</li>
</ul>
<h2 id="四、具体应用"><a href="#四、具体应用" class="headerlink" title="四、具体应用"></a>四、具体应用</h2><ul>
<li>连接管理<ul>
<li>长连接和短连接<ul>
<li>  长连接就是一次连接里面可以进行多次的http通信，在http1.1版本开始默认都是长连接，如果要断开则有客户端或者服务器中的一方发出Connectioin : close;</li>
<li>  短连接就没什么好说的，基本是历史的尘埃了，在1.1以前如果需要使用长连接要标明Connection：Keep-Alive</li>
</ul>
</li>
<li>  流水线：默认情况下请求是要按顺序来的，上一个请求得到响应后新的请求才能被发出去，但考虑到现实情况下的网络延迟和带宽限制，这样效率可能会很低，流水线是指在同一个长链接中发出连续的请求而不用等待响应返回</li>
</ul>
</li>
<li>Cookie：<br>  为了让http协议尽可能的简单，他本身是没有状态的，1.1引入Cookie来保存状态信息。Cookie是服务器发送到客户端的部分保存在浏览器中的数据，后续的每次请求中都会带上Cookie数据，这样服务器和客户端之间实现了一对一，不然只有客户端知道服务器，而服务器不知道请求来自哪个客户端，Cookie解决这个问题的同时也导致请求消耗资源增多<ul>
<li>  用途：会话管理（登录状态、购物车）、个性化设置、浏览器行为跟踪</li>
<li>  创建过程：服务器发送的响应报文中包含Set-Cookie字段，客户端得到响应报文后将Cookie内容保存到浏览器中，之后客户端再对这个服务器发起请求的时候就会把Cookie数据带上</li>
<li>  生命周期：会话期cookie在浏览器关闭后就被删除，而设置了expires之后（有时候登录一个网站时会问你要不要记住登录信息）cookie会被写入硬盘</li>
<li>  JavaScript：通document.cookie属性可以在js中创建cookie和访问非HttpOnly标记的cookie</li>
<li>  HttpOnly：标记之后可以避免被通过js脚本的方式来窃取cookie信息，能一定程度上提高安全性</li>
<li>  Secure：标记Secure之后cookie信息只能通过HTTPS加密传输（反向来看就是走http协议的网站不能用这个属性），且即使加密之后也是不能保证信息安全的，总的来说敏感信息就不应该被放到cookie里面</li>
<li>  session：除了将用户信息通过cookie存在客户端以外，还可以利用session存到服务器端，比如用户登录完后就把信息存到redis里面，然后把key放到cookie中返回给客户端，之后的通信都只要传递这个key就行了，服务器拿到key就能从Redis里面找到对应的内容；这里要注意session ID的安全性，可以通过经常更新或者重新验证的方式来提高安全性</li>
<li>  浏览器禁用cookie：这个时候就不能用cookie了，只能通过上面说的session的方式，session的ID也不能通过cookie来传递了，使用URL重写技术，将ID作为URL参数进行传递</li>
<li>cookie和session的选择：<ul>
<li>  cookie只能存储ASCII码字符串，而session是可以存储任何类型的数据的（可以存储到任何的数据库或者内存中）</li>
<li>  cookie存在客户端容易被查看，解决方式是进行加密，然后到服务器端进行解密</li>
<li>  其实总的来说session在各个方面都是要优于cookie的，但是必须要考虑一个现实的问题，cookie占用的是用户的存储空间，而session占用服务器存储，对大型网站来说这个开销将非常大，所以要根据内容的敏感性来决定存储方式</li>
</ul>
</li>
</ul>
</li>
<li>缓存：<ul>
<li>  优点是能缓解服务器压力，而且一般缓存可能放到客户端或者分布式的缓存服务器，物理位置更近读取更快</li>
<li>实现方式：<ul>
<li>  代理服务器进行缓存</li>
<li>  客户端进行缓存</li>
</ul>
</li>
<li>Cache-Control:控制缓存<ul>
<li>  Cache-Control:no-store 完全禁止缓存</li>
<li>  no-cache:强制确认缓存，让缓存服务器必须先向服务器确认资源的有效性</li>
<li>  private和public：私有和公有，私有内容只能被单独的用户使用，一般存储在用户浏览器；而公有就是大家都能使用，一般存储到缓存服务器</li>
<li>  缓存过期机制：请求中加入一个max-age指令，告诉缓存服务器验证缓存存在的时间是否小于这个时间，如果成了那就能接受该缓存内容；如果是响应报文中的max-age则表示缓存在缓存服务器中保存的时间，客户端收到这个参数可以自己去判断是否接受这个缓存数据</li>
</ul>
</li>
<li>  缓存的验证机制：资源用一个唯一标识ETag来标记，缓存服务器向服务器验证缓存内容是否最新的时候就对比两个资源的ETag就行，这里如果两个资源的ETag是匹配的，服务器返回304 Not Modified就是前面讲状态码中说到的报文条件验证满足</li>
</ul>
</li>
<li>  内容编码：将返回数据的实体进行压缩再传输，浏览器发送的Accept-Encoding首部其中包含了他所支持的压缩算法以及各自的优先级，常见的内容编码：gzip、compress、deflate、identity</li>
<li>范围请求：如果出现网络中断，而服务器值发送了另一部分的数据，范围请求可以使得客户端只请求没有得到的那部分数据（估计这个是断点续传的底层实现原理）<ul>
<li>  range：在请求报文中添加Range指定请求的范围，请求成功服务器会返回206 Partial Content，不支持范围请求时服务器返回200</li>
</ul>
</li>
<li>  虚拟主机：HTTP/1.1使用虚拟主机可以使得一台服务器拥有多个域名，在逻辑上可以看成多个服务器</li>
<li>通信数据转发<ul>
<li>  代理：主要目的–缓存、负载均衡、访问控制、日志记录</li>
<li>  网关：网关服务器是将HTTP转化为其他协议进行通信，从而请求其它非HTTP服务器的服务</li>
<li>  隧道：使用SSL等加密手段在客户端和服务器之间建立一条安全的通信线路</li>
</ul>
</li>
</ul>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h2><ul>
<li>1.X的缺陷<ul>
<li>  对并发没有好的处理方案（通过使用多个连接来实现）</li>
<li>  不会压缩请求和响应的首部，浪费流量降低效率</li>
<li>  不支持有效的资源优先级，致使地城TCP链接的利用率低下</li>
</ul>
</li>
<li>  二进制分帧层：2.0将报文分成headers帧和DATA帧，他们都是二进制格式</li>
<li>  服务端推送：请求一个资源是，会把相关的资源一起发送给客户端（js、css之类的资源）</li>
<li>  首部压缩：1.1的时候首部含有大量信息，且每次都要重新发送；2.0要求客户端和服务器同时维护一个包含之前见过的首部字段表，避免重复传输，同时还使用Huffman编码对首部字段进行压缩</li>
</ul>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础 -- SSH原理</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/SSH%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>以前互联网的通讯都是明文的，被拦截了信息就泄露了，到了1995年的时候，有个芬兰学者不知道是啥名的设计了SSH协议，对登录信息进行加密，这个东西也是使用非对称加密的方式。</p>
<p>远程登录方法一：客户端向主机发起请求，主机就抛给你一个公钥，然后你把自己的用户名和密码用这个公钥进行加密，加密完成后再传输给主机，主机用自己当私钥进行解密，然后验证你的登录信息是否合法</p>
<p>这个地方有一个问题，要是有人在中间拦截了客户端发起的请求，然后将自己的公钥丢给了客户端，那客户端拿这个公钥去做加密并把数据给这个中间人的话信息就泄露了，整个安全系统也就崩溃了，这个SSH又不像https那样有一个证书认证，所以没有什么好办法，当主机第一次给你公钥的时候系统会警告你自己去核对这个公钥，公钥一般是那种2048位反人类的东西，只好又把他做下转换弄成一个指纹（其实就是一个短一点的字符串，容易做识别），拿到这个指纹就没有好办法了，自己去主机的官网上查询他的公钥去吧，对比完成后选择接受这个公钥，然后你就能做登录了，并且这个公钥还会被保存到本地的$HOME/.ssh/known_hosts这个地方，本地还有一个/etc/ssh/ssh_known_hosts保存了一些对于所有用户来说都可信的远程主机的公钥</p>
<p>远程登录方法二：这个是给自己生成一个私钥和公钥然后把公钥传输给远程主机，以后要做登录的时候就不用输入用户名和密码了，只要发起请求后远程主机会给你一份字符串，用私钥加密后发给主机，主机用公钥解密后对比信息就可以完成身份认证</p>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础 -- https加密通讯</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/https%E5%8A%A0%E5%AF%86%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<p>参考贴：<a href="https://blog.csdn.net/junehappylove/article/details/52288796">https://blog.csdn.net/junehappylove/article/details/52288796</a></p>
<p>https与http相比它的通讯是加密的安全的</p>
<p>服务器和客户端之间的信息传递需要做加密处理</p>
<p>这里我们要明确另一些概念</p>
<p>对称加密：加密和解密使用同一把钥匙，这个时候需要保存好这个密钥。</p>
<p>非对称加密：加密和解密是使用不同的密钥的，也就是非对称加密系统，通常一个密钥是公开的，大家都知道的，一个密钥是私有的，需要妥善的保存避免泄露，这样一方用公钥或者私钥进行加密，另一方用相反的钥匙做解密。</p>
<p>那么情景一：</p>
<p>服务器作为主体时，服务器拥有私钥，向客户端推送数据时，服务器用私钥做了加密，将加密后的数据发送给客户端，客户端拿到数据后用公钥做解密就能得到真实的信息了。</p>
<p>客户端通过一个服务器地址向服务器发起请求：</p>
<p>C to S:hello server222</p>
<p>S to C:hello , I’m server</p>
<p>C to S:证明自己是服务器</p>
<p>S to C:我是服务器 {我是服务器}[私钥|RSA]</p>
<p>客户端向服务器发出消息，但是地址这个东西是不可靠的，黑客可以冒充服务器，那么这个时候客户端就需要服务器证明自己的身份，前面说了服务器是会向客户端发布自己的公钥的，这里我们默认客户端已经得到了服务器的公钥（具体得到的方法后续说明），这个时候服务器只要发一段明文“我是服务器”和他对应的被加密之后的密文”我是服务器”(以服务器的密钥加密)给客户端,客户端用公钥解密密文与明文做对比,相同则证明服务器是真的;</p>
<p>这里规定一个加密的格式:  {表示加密之后的密文}[加密的钥匙类型|加密的算法]</p>
<p>数字证书</p>
<p>这里我们默认客户端已有服务器的公钥,但实际上公钥到底是怎么得到的呢</p>
<p>方法一:一开始的时候客户端就管服务器去要公钥,那样的话黑客也能通过模仿服务器将自己的公钥发给客户端,之后就能通过身份认证了</p>
<p>方法二:服务器们统一将公钥放到网站上,让客户端自己去取,但这种情况下黑客同样可以去模拟这个保存公钥的网站</p>
<p>所以这两种方法都是不可取的,为了解决这个问题数字证书就出现了,大体上说数字证书就是由一帮权威机构为服务器制作的一个身份证,这个证书里面的大概内容:</p>
<ul>
<li><p>所有者,也就是证书是哪个服务器的</p>
</li>
<li><p>公钥</p>
</li>
<li><p>有效期</p>
</li>
<li><p>各种算法</p>
</li>
</ul>
<p>这里只简单列出最重要的属性,那么现在当我们拿到一个证书时,只要该证书能证明自己是合法的(具体证明过程不做讨论,是那些颁发机构做的事)我们可以确定的信息就是该证书是哪个服务器所有的以及他对应的公钥</p>
<p>既然我们能通过数字证书的方式得到服务器正确的公钥了,那通讯的过程演变为了：</p>
<p>情景二:</p>
<p>C to S:hello server</p>
<p>S to C:hello , 这是我的数字证书(这时客户端通过数字证书确认了服务器和公钥)</p>
<p>C to S:证明自己是服务器</p>
<p>S to C:我是服务器 {我是服务器}[私钥|RSA]</p>
<p>C to S:我的余额 {我的余额}[公钥|RSA]</p>
<p>S to C:你的余额为100 {你的余额为100}[私钥|RSA]</p>
<p>这个时候如果是黑客冒充的服务器,那他最多是冒充了服务器的地址然后盗用了服务器的证书,但是黑客无法改写证书也没有服务器的私钥,是没法通过身份认证的</p>
<p>到了这一步我们的客户端已经确认和真实的服务器建立的连接,但是后续的问题来了,以后客户端向服务器发送信息说要查看自己的余额时只要用公钥加密就行了，因为密钥只有服务器才有，所以这个信息只有服务器能够解读，但是问题出现在服务器回答说你的余额为100时，如果再用RSA的方式进行加密的话，这个信息是所有人都能解读的，因为公钥是公开发布的。</p>
<p>这个时候，当客户端确认了服务器的真实性后，要在本地生成一个对称加密算法和密钥，然后将这两个东西用公钥加密发送给服务器，服务器得到对称加密算法和密钥后，后续的通话都将通过这个临时生成的对称算法和密钥来进行加密；</p>
<p>情景三：</p>
<p>C to S:hello server</p>
<p>S to C:hello , 这是我的数字证书</p>
<p>C to S:证明自己是服务器</p>
<p>S to C:我是服务器 {我是服务器}[私钥|RSA]</p>
<p>C to S: {我的对称算法和密钥}[公钥|RSA]</p>
<p>S to C:{收到算法和密钥，以后通讯使用这个对称算法和密钥进行加密}[密钥|对称算法]</p>
<p>C to S: {我的余额}[密钥|对称算法]</p>
<p>S to C:{你的余额为100}[密钥|对称算法]</p>
<p>现在这个通讯过程已经很接近https的通讯方式了，但仍有一些问题存在，黑客虽然无法破解加密的内容，但他可以故意修改加密内容，导致信息的接收方不能得到正确的信息。</p>
<p>数字签名：</p>
<p>这个时候我们需要依赖数字签名来确保数据在传输过程中没有被人恶意的修改，数字签名工作的原理是：发送方在发送信息之前先去得到信息的hash值，每个数据都有自己对应的hash值，这个值重复的几率趋近与零，所以我们可以认为任意一个数据的hash值都是唯一的，将这个hash值加密后作为数字签名附加到要发送的内容上（这个内容也是要加密的），接收方接收到数据后，先将真正的内容进行解密，然后计算解密后的内容的hash值，再对数字签名进行解密，对比两个hash值，如果不同，说明数据受到了篡改，那么将立即停止通讯。</p>
<p>这里有一个疑问：如果在验证服务器身份的时候，黑客拦截了客户端的验证请求，然后自己也向真正的服务器发起验证请求，然后将服务器给出的证明发给客户端，那是不是就能冒充服务器了</p>
<p>一些应用：git添加密钥    ssh连接的时候询问是否信任接的时候询问是否信任</p>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础 -- 互联网协议--五层模型</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE--%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p> 介绍网络的工作原理，物理设备到底是怎样与各种协议合作组成的信道网络。</p>
<p>原博客地址：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p>
<p>这里将按照分层的方式来了解网络组成，按照功能分成五个层次，这个不是一个标准的分层，也没有标准，方便理解的去模糊划分。</p>
<p><img src="/img/10969189AE4E4AED9A812AC38381020D.png"></p>
<ol>
<li><p> 实体层</p>
</li>
<li><p>实体层就是将电脑连入网络的网线， 像上面宽带、光纤、无线电波一类的东西，就是信号传输的线路。</p>
</li>
<li><p>链路层</p>
</li>
<li><p>首先在实体层中传输的数据本质上都是0和1，所以要规定出我们要如何去传输和识别这些01数据，这个层确定了这些0和1的分组方式。</p>
</li>
<li><p>一开始大家都有自己的分组方式，但是这样明显不方便，不能相互的沟通，后来叫“以太网“的协议占据了主导地位，这种协议规定一组电信号构成一个数据包，叫做帧，每个帧又分为”标头“和”数据“两个部分。标头里存储了发送者、接收者、数据类型等信息；数据里就是需要传输的数据。标头的长度固定为18个字节，数据部分的长度为46到1500之间，所以一个帧的最短长度为64字节，最长为1518字节；</p>
</li>
<li><p> MAC地址，上面有说标头里面包含了发送者和接收者的信息，那就要提取出每个发送和接收设备的身份标识，这个标识就是MAC地址，那这个地址是怎么来的呢，这个地方一个设备想要接入互联网，那一定要有一个叫做“网卡”的设备，这个设备在被生产的时候就为他分配了一个全世界唯一的MAC地址，长度为48位的二进制数，通常用12个十六进制数来表示，所以我们平时查找的MAC地址都是6对字符组成；</p>
</li>
<li><p>广播，当有了mac地址作为标识之后，我们已经能够区分出谁是谁了，相当于人有了名字，而当设备接入网络后就能相互通信了，也就相当于人们在同一个屋子里说话大家都能听到了，所以把帧数据丢到网络中去，大家都取来看看标头里的接收者是不是自己，是就将数据取出来，这样数据的传输就实现了。</p>
</li>
<li><p>网络层</p>
</li>
<li><p>存在原因：为什么要有网络层，链路层的时候不就已经是实现了数据的传输了吗，链路层传输数据的方法是把数据丢到网络中每个人的手里，所以导致一些问题，一个是每个人都要去接收数据看看是不是发给自己的，现在有几十亿网民，而网络设备数量更多，很难想象如果每个人发的数据都去接过来看看接收者，这个资源占有会有多大，另一个是整个互联网其实由大量的子网络构成，两台通讯设备不一定在同一个子网络中，这样的话就没法直接通过mac地址来找到对方了。</p>
</li>
<li><p>我们需要一种方法来判断通讯的mac地址是否在同一个子网络中，如果是就用广播的方式传输数据，如果不是就用路由的方式传输数据，路由这个概念很广泛，这里不详述，这种判断的依据就是网络层了，他是一套新的地址，用于区分两台计算机是否在同一个子网络中。这套地址叫“网络地址”简称–网址；</p>
</li>
<li><p>IP协议：规定网络地址的协议叫做IP协议，它所定义的地址叫做IP地址，目前广泛使用的是第四版协议，所以叫做IPv4，这个版本中网络地址有32位二进制构成，但使用中我们用4段的十进制来表示IP地址，从0.0.0.0一直到255.255.255.255；IP地址也被分为两个部分，前一部分代表了网络，后一部分代表了主机，但是这个地方两个部分的长度是不固定的所以无法区分，为了区分引入一个新的参数–子网掩码，它也是一个32位的二进制数字，他的网络部分全为1，主机部分全为0，比如11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0，通过子网掩码我们能够区分IP地址中的网络部分和主机部分，知道两个IP地址是否在同一个网络中；所以IP地址的主要作用有两个，一个是为每台设备分配IP地址，另一个是确认哪些地址是在同一个子网络中。</p>
</li>
<li><p>前面说了网络中数据传输的单元是以太网规范中的帧，但是帧的标头中只有mac地址的信息，现在我们加入了IP地址，这可咋整勒，人们决定将原本的帧的数据部分再分为两个部分，也就是包含了IP地址的标头和数据了，标头中包含了版本、长度、IP地址等信息，数据部分是IP数据内容，IP标头是20到60字节    ，整个数据包的最大总长度为65535字节，可以推出IP数据部分的最大长度可以为65515，但是前面说了这个东西整个就是放到了以太网的帧里面，而帧的最大长度是1500，当这个IP的数据包长度超过这个范围时，我们将它分成多个以太网的帧进行发送。</p>
</li>
<li><p>ARP协议：没看明白，后续补充</p>
<p>   4.传输层</p>
</li>
<li><p>在网络层中通过IP地址和mac地址就已经能让两台主机在网络中相互通信了，但是一个终端上会有很多的程序会同时的使用网络，那个我们为了区分这些不同程序使用的端口，端口是16位二进制数组成，从0到65535,0到1023的端口被系统占用，用户只能选择大于1023的端口，所以传输层的作用是端口到端口的通讯，而前面的网络层的作用是主机到主机的通讯；（在Unix系统中把主机+端口叫做套接字socket，基于他进行网络应用的开发）</p>
</li>
<li><p>UDP协议：这是一个基于端口的协议，与前面的在以太网的协议上加入IP协议相同，这个基于端口的协议也分为了标头和数据部分，整个协议被写入了IP协议的数据部分  ，UDP协议标头部分共8字节，总长度不超过65535，和IP协议的长度相同。</p>
</li>
<li><p>TCP协议：UDP协议有个缺点，没有可靠性保证，只是把数据包丢出去，不知道对方到底有没有接收到，所以有了TCP协议，这个协议每个数据包都要发出去之后都要确认对方有没有收到，要是没有收到那就要重新发送，TCP协议能够保证数据不会丢失，但是由于它的实现复杂，所以会占用较多的资源。在长度这块，TCP协议没有长度的约束，但是为了保证效率，通常长度也是不会超过IP协议长度的，超过了就需要分割了。</p>
</li>
</ol>
<p>5.应用层</p>
<p>应用程序收到具体的数据之后就要开始做解析了，由于来的数据可能是各种各样的数据，所以各个应用就要规定自己需要的数据的格式，所以有了邮件、网页之类的数据格式，由这些应用规定的数据标准组成了应用层。</p>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础 -- 网络基础</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h1><ul>
<li><p>概论：第一章 概论</p>
</li>
<li><p>因特网：第一章 计算机网络与因特网</p>
</li>
<li><p>应用层：第二章 应用层</p>
</li>
<li><p>运输层：第三章 运输层</p>
</li>
<li><p>网络层-数据平面：第四章 网络层-数据平面</p>
</li>
</ul>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul>
<li>WAN、LAN、ETH：WAN、LAN、ETH接口</li>
</ul>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul>
<li><p>HTTP：HTTP</p>
</li>
<li><p>HTTPS加密通讯：https加密通讯</p>
</li>
<li><p>ssh原理：SSH原理</p>
</li>
<li><p>五层模型（浅诉）：互联网协议–五层模型</p>
</li>
<li><p>DNS：DNS</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构--算法 -- 二叉排序树</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构--算法</category>
      </categories>
      <tags>
        <tag>数据结构--算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 -- java基础</title>
    <url>/2023/04/13/java/2019/java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul>
<li>  byte</li>
<li>  char</li>
<li>  short</li>
<li>  int</li>
<li>  long</li>
<li>  double</li>
<li>  float</li>
<li>  boolean</li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul>
<li>  Byte、Character、Short、Integer、Long、Double、Float、Boolean</li>
<li>  ==所有的包装类都是final修饰的，为什么？？？==</li>
<li>  ==基本类型存在的意义是什么，为什么不直接用包装类，万事万物皆对象，为什么还要有基本数据类型==</li>
<li>  基本数据类型除了Boolean以外都是可以相互转换的，但是由于各自占的空间大小不同，高精度转换为低精度时可能会丢失，而且他是直接通过位来截断的，可能会被转得面目全非，所以最好不要轻易进行降精度的转换</li>
<li>  int到Integer的转换</li>
</ul>
<!---->

<pre><code>Integer a = 1;
int b = a;
// 包装类转基本数据类型
int b = a.valueOf(1);

int c = 1;
Integer d = c;
// 基本数据类型转包装类
Integer d = c.intValue(1);
</code></pre>
<ul>
<li>  空指针</li>
</ul>
<!---->

<pre><code>Integer a = null;
int b = a;  //抛出NullPointException
</code></pre>
<ul>
<li>  两个包装类引用的相等性</li>
</ul>
<!---->

<pre><code>Integer a = 1;
Integer b = 1;
System.out.println(a==b);   //true

Integer c = 1000;
Integer d = 1000;
System.out.println(c==d);   //false

// 以下为Integer的源码
public static Integer valueOf(int i) &#123;
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) // 判断实参是否在可缓存范围内，默认为[-128, 127]
        return IntegerCache.cache[i + (-IntegerCache.low)]; // 如果在，则取出初始化的Integer对象
    return new Integer(i); // 如果不在，则创建一个新的Integer对象
&#125; 
</code></pre>
<h3 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h3><p>这个缓冲池是说的对于基本数据类型的缓存池</p>
<h4 id="new-Integer-123-和Integer-valueOf-123-的区别"><a href="#new-Integer-123-和Integer-valueOf-123-的区别" class="headerlink" title="new Integer(123)和Integer.valueOf(123)的区别"></a>new Integer(123)和Integer.valueOf(123)的区别</h4><p>其实就是上面的问题里面提过，使用valueOf的时候可以去访问缓存池，这个缓存池的大小是-128-127，如果在这个范围内的话会直接去取缓存池中的对象就不用新建对象了，而new这个关键字总是会创建新对象</p>
<h4 id="哪些基础数据类型拥有缓存池"><a href="#哪些基础数据类型拥有缓存池" class="headerlink" title="哪些基础数据类型拥有缓存池"></a>哪些基础数据类型拥有缓存池</h4><p>boolean、byte、short、int、char，Boolean就不用说了就俩值所以都在缓存池里面，byte类型大小和缓存池大小一样都可以缓存，而short和int都是-128-127，char的这个看不太懂\u0000 to \u007F，估计也是一样的大小只是表达方式问题</p>
<h2 id="二、String"><a href="#二、String" class="headerlink" title="二、String"></a>二、String</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>String被声明为final，因此他不可以被继承；java8中String通过char数组进行存储；java9中使用byte数据进行存储，同时使用char类型的coder参数来标识使用了哪种编码。</p>
<h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><ul>
<li>  可以缓存hash值</li>
<li>  String Pool需要：Sting对象被创建后会从String Pool中取得引用，只有String是不可变的，才可能使用String Pool</li>
<li>  安全性：String作为参数可以保证参数不变，例如在作为网络连接参数的时候</li>
<li>  线程安全：不存在线程安全问题，可以在多个线程中安全的使用</li>
</ul>
<h3 id="String，StringBuffer，StringBuilder"><a href="#String，StringBuffer，StringBuilder" class="headerlink" title="String，StringBuffer，StringBuilder"></a>String，StringBuffer，StringBuilder</h3><ul>
<li>  String不可变，另外俩都可变，可变带来一些好处，如果一个字符串被修改的频率很高的时候可以节省创建新对象的开支</li>
<li>线程安全性<ul>
<li>  String天生线程安全</li>
<li>  StringBuilder不是线程安全的</li>
<li>  StringBuffer是线程安全的，为此带来的是更高的资源消耗</li>
</ul>
</li>
</ul>
<h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池中保存着所有字符串字面量，这个所谓字面量就是指字符串字符本身被存放到了一个内存空间中，这些字面量在编译时期就确定了，此外也可以通过String的intern()方法在运行过程中将字符串添加到常量池中。</p>
<h4 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h4><p>关于这个intern()方法，当调用它的时候它去常量池中检查是否存在了相同的字面量，存在就直接返回这个字面量对象的引用；否则会再常量池中新建一个字面量对象然后返回它的引用。</p>
<pre><code>String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);
System.out.println(s1 == s2);   //false
String s3 = s1.intern();
String s4 = s2.intern();
System.out.println(s3 == s4);   //true

//如果是以下面的这种字面量的形式创建字符串，则会自动将字符串放入常量池中
String s = &quot;aaa&quot;;
</code></pre>
<h4 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h4><p>经常会问说这个过程中有几个对象被创建了，两个或者一个，堆上一定会创建一个字符串对象，而常量池中就要看是否有相同的字符串对象存在了，不存在就创建一个，存在就直接引用。</p>
<p>再详细了说，在String Pool中不存在abc字面量的时候，会创建一个字符串对象，这是一个对象，在常量池中分配一块内存存储abc这个字面量，然后将常量池上创建的字符串对象指向这个字面量。再将这个常量池中的字符串对象作为String构造函数的参数在堆中创建一个字符串对象，这时并不是要复制一份常量池中对象内容而是将引用指向它。</p>
<pre><code>String s1 = new String(&quot;he&quot;) + new String(&quot;llo&quot;);
String s2 = s1.intern();
</code></pre>
<p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/markdown/java_string.png" alt="image"></p>
<h2 id="三、运算"><a href="#三、运算" class="headerlink" title="三、运算"></a>三、运算</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>java中只有值传递，没有引用传递</p>
<p>==将不同类型的参数进行方法调用后，原来的参数是否会发生改变==</p>
<h3 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h3><p>这简直是大坑，总体上说两个类型都是浮点数，然后float属于的单精度，double是双精度，在内存上float占4个字节，double占用8个字节，float有效数字为8位（这里的有效数字是包含了小数点前的数字的，从小数点前向后计数），double有效数字为16位，通常来说cup处理单精度速度比处理双精度速度快；实际使用的时候好像很少会用到float</p>
<pre><code>//float的定义
float f = 1.1;  //会报错,默认1.1是double类型的
float f = (float) 1.1;
float f = 1.1f;
</code></pre>
<p>再看看java中浮点数的计算，结果很诡异</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 运算3*0.1</span><br><span class="line">System.out.println(3*0.1);</span><br><span class="line">//结果： 0.30000000000000004</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算机中所有的数最终都要转换成二进制表示，当浮点数参与了计算，那么浮点数的二进制与十进制之间的转换过程会变得不可预知且不可逆；这里说一下既然float和double其实都是在表示小数，为啥不直接说他们叫小数还要说是浮点数呢，这些数都是以科学计数法的形式进行存储的，一个数50.534转换成科学计数法形式5.053e1，不太清楚什么是科学计数法，但它的小数点移动到了一个新的位置（浮动了），这么说起来浮点数是服务于科学计算的，不适合用来进行精确计算；</p>
<p>==问题来了：java中到底该如何进行小数运算==</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">short s = 1;</span><br><span class="line">s = s + 1; //会报错，1这个字面量默认属于int，但不知道为什么在赋值的时候就可以，难道也是做了隐式的类型转换吗</span><br><span class="line">s = (short) (s + 1);</span><br><span class="line"></span><br><span class="line">// 通过下面的两种方法可以进行隐式的类型转换</span><br><span class="line">s += 1;</span><br><span class="line">s ++;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>枚举的关键字，枚举这个语法被用得好少，一般都直接使用判断语句了，其实还是有他的优点的，有机会试试；在java7之后可以在switch判断语句中使用String对象了</p>
<h2 id="四、继承"><a href="#四、继承" class="headerlink" title="四、继承"></a>四、继承</h2><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类和方法都用abstract进行修饰，抽象类里面一般都有抽象方法，当然一定包含也可以，但是抽象方法必须在抽象类中才能定义；抽象类和普通类最大的区别是抽象类不能被实现，需要通过继承后去实例化其子类。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是抽象类的延伸，在java8以前，可以把它看成是一个完全的抽象类，那时候它不能有任何的方法实现；但是从java8开始接口也可以有默认的方法实现了，因为完全抽象的维护成本太高了，在8之前要扩展一个接口方法时，就要修改所有实现了该接口的类；</p>
<p>接口的成员（方法和字段）都是public的，并且不允许被定义为private或者protected；</p>
<pre><code>public interface Man &#123;
    int i = 0;
    String name = &quot;11&quot;;
    default void show(String content)&#123;&#125;
    static void speak()&#123;&#125;
&#125;
</code></pre>
<ul>
<li>==接口的字段默认都是static和final的==<ul>
<li>  带来一些问题：接口是抽象类的延伸所以它也不能被实例化，所以它也没有构造函数，而字段又都是static final的，所以也不能留白，必须在定义的时候就实例化</li>
<li>  ==普通类里面static修饰的字段可以不初始化，final修饰的字段至少要在构造函数里面初始化，static final修饰的字段必须在定义的时候初始化==</li>
</ul>
</li>
</ul>
<h4 id="抽象类和接口对比"><a href="#抽象类和接口对比" class="headerlink" title="抽象类和接口对比"></a>抽象类和接口对比</h4><ul>
<li>  本质来说一个是类只是有了一些约束而另一个是接口是一个完全的契约，而具体的不同其实是由于接口成员都是public所以没有权限管理，类可以继承多个接口而抽象类只能单继承</li>
</ul>
<h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>其实大多数情况下都使用了接口，抽象类使用场景很少，一方面是抽象类严格的类层次要求，另一方面是java8之后接口可以默认实现方法后维护成本变低</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>==super大概就是一个父类的实例引用，对应this关键字是自身的一个实例引用==不知道为什么没把这俩哥们放到一起讲，然后super就是用来帮助访问父类的被重写了的方法（构造方法和普通方法都可以）的，不然被重写了就没法用了有的时候还是不科学的</p>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><h4 id="重写（override）"><a href="#重写（override）" class="headerlink" title="重写（override）"></a>重写（override）</h4><p>在继承中子类定义了和父类中声明上完全相同的一个方法，而为了满足里式替换原则，最好是用@Override注解来让编译器帮忙检查是否满足这些条件：</p>
<ul>
<li>  访问权限</li>
<li>  返回类型</li>
<li>  抛出异常</li>
</ul>
<h4 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h4><p>==方法名相同，参数类型、个数、顺序不同，不知道返回值类型不同算不算，而且返回值如果是父子类或者接口与实现关系时候怎么说==</p>
<h2 id="五、Object通用方法"><a href="#五、Object通用方法" class="headerlink" title="五、Object通用方法"></a>五、Object通用方法</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><pre><code>public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class&lt;?&gt; getClass()

protected void finalize() throws Throwable &#123;&#125;

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException
</code></pre>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><ul>
<li>  等价关系</li>
</ul>
<!---->

<pre><code>//自反性
x.equals(x)
//对称性
x.equals(y) == y.equals(x); // true
//传递性
if (x.equals(y) &amp;&amp; y.equals(z))
    x.equals(z); // true;
//一致性：多次调用结果不变
x.equals(y) == x.equals(y); // true
//与null比较:这个才是重点，任何不是null的对象x调用equals(null)都是false，什么叫对象为null呢，就是对象被声明后没有被初始化
x.equals(null)
</code></pre>
<ul>
<li>作用<ul>
<li>与==的区别<ul>
<li>  对于基本类型： ==判断两个值是否相等，基本类型没有equals方法</li>
<li>  对于非基本类型：equals判断值是否相等，==判断两个变量是否指向相同的对象</li>
</ul>
</li>
<li>  ==判断是否是同一个对象的引用？不知道这里说的是什么意思==</li>
</ul>
</li>
</ul>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>返回hash值</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>==拷贝，内容挺多的，有时间看看==</p>
<h2 id="六、关键字"><a href="#六、关键字" class="headerlink" title="六、关键字"></a>六、关键字</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>声明数据为常量，如果在定义的时候就赋值了那就是一个编译时常量，也可以是留白了等到运行时才赋值，赋值之后就不能改变</p>
<ul>
<li>  对基本类型，final使得数值不变</li>
<li>  对于引用，final使得引用不能在改变指向的对象，只是相当于指针被锁死，但是引用的对象的内容是可以发生变化的</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>声明方法的时候该方法不能被子类重写，其实private修饰方法的时候就是把方法指定为了final，这个时候当子类中再出现相同的方法签名也不会是重写，而是在子类中定义了一个新的方法</p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>声明类不可以被继承，==什么时候需要说一个类不要被继承呢==</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h4><p>叫做静态变量，意思说这个变量是类所有实例所共有的，静态变量在内存中只存储一份；别的变量都叫做实例变量，也就是说每个实例都会有一份，它与所在的实例是同生共死</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><ul>
<li>  静态方法在类加载的时候就存在了，它不依赖与任何实例，所以静态方法必须有实现，导致它不能是抽象方法</li>
<li>  只能访问所属类的静态方法和静态字段，因为别的字段不一定初始化了（==但是当年鸣哥说过另外一个概念，有点忘了==），方法中也不能有super和this关键字（这两哥们大概都是在类的对象初始化的时候才会生成的）</li>
</ul>
<h4 id="静态语句块"><a href="#静态语句块" class="headerlink" title="静态语句块"></a>静态语句块</h4><p>在类初始化的时候运行一次</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>非静态内部类需要依赖于外部类的实例，儿静态内部类不需要，同时它也不能去访问外部类的非静态的成员</p>
<h4 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h4><ul>
<li>  静态变量和静态语句块由于实例变量和普通语句块，而它俩的优先级是相同的也就是说谁在前面谁先执行</li>
<li>  实例变量和普通语句块，这两哥们优先级也是一样的</li>
<li>  构造函数</li>
<li>存在继承的情况下<ol>
<li> 父类（静态内容）</li>
<li> 子类（静态内容）</li>
<li> 父类（实例变量、普通语句块）</li>
<li> 父类（构造函数）</li>
<li> 子类（实例变量、普通语句块）</li>
<li> 子类（构造函数）</li>
</ol>
</li>
</ul>
<h2 id="七、反射"><a href="#七、反射" class="headerlink" title="七、反射"></a>七、反射</h2><h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h2 id="九、泛型"><a href="#九、泛型" class="headerlink" title="九、泛型"></a>九、泛型</h2>]]></content>
      <categories>
        <category>java</category>
        <category>2019</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 -- why</title>
    <url>/2023/04/13/java/2019/why/</url>
    <content><![CDATA[<ul>
<li><p>断言</p>
</li>
<li><p>aop ioc spring</p>
</li>
<li><p>位运算：2&lt;&lt;3 将2左移3位相当于2<em>8 2乘2的3次方，这也是2</em>8的最优效率的计算方式，同样的任何数乘上2的倍数的时候都可以使用位运算来进行</p>
</li>
<li><p>数据库中日期类型的默认值该如何设置</p>
</li>
<li><p>在创建表的时候考虑字段取最能节省空间的类型</p>
</li>
<li><p>字段中存储特殊字符（表情）要调整表的编码格式</p>
</li>
<li><p>数据库通过两个字段进行查询的时候可否只给第一个字段建立索引</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>2019</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 -- 并发</title>
    <url>/2023/04/13/java/2019/%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="一、线程状态转换"><a href="#一、线程状态转换" class="headerlink" title="一、线程状态转换"></a>一、线程状态转换</h1><h2 id="以前记录的状态"><a href="#以前记录的状态" class="headerlink" title="以前记录的状态"></a>以前记录的状态</h2><p>创建、可运行、运行中、阻塞、死亡；这几个很好理解，创建就是线程对象被创建，但是还没有调用start方法来开启，而开启之后也不是立马就能得到执行的，是否执行取决于CPU调度，这时就是可运行状态，得到CPU调度之后叫做运行中，而线程在运行中因某些原因不能继续运行时叫做阻塞，当线程执行完run方法后认为它死去</p>
<h2 id="更详细的版本"><a href="#更详细的版本" class="headerlink" title="更详细的版本"></a>更详细的版本</h2><ul>
<li>  新建：创建后尚未启动</li>
<li>  可运行：可能在在运行也可能在等待CPU时间片</li>
<li>  阻塞：等待获取一个排它锁，如果其他线程释放了锁就会结束此状态(阻塞和等待的区别在于，阻塞是被动的在程序运行的时候出现不被开发者控制的，等待是主动的编码的时候就已经确定了)</li>
<li>无限期等待：等待其他线程显式的唤醒，否则不会被分配CPU时间片，下面整理了会进入这个状态的情形和退出的方法(关于这些内容的详细解释留在下面的内容中)<ul>
<li>  没有设置Timeout参数的Object.wait()方法，退出Object.notify()/Object.notifyAll()</li>
<li>  没有设置Timeout参数的Thread.join()方法，被调用的线程执行完毕</li>
<li>  LockSupport.park()方法，LockSupport.unpark(Thread)</li>
</ul>
</li>
<li>期限等待：无需等待其他线程的显示唤起，在一定时间之后会被系统自动唤起<ul>
<li>  Thread.sleep()方法，时间结束时退出</li>
<li>  设置了参数的Object.wait(),时间结束、Object.notify()、Object.notifyAll()</li>
<li>  设置了参数的Thread.join()，时间结束、被调用的线程执行完成</li>
<li>  LockSupport.parkNanos(),LockSupport.unpark(Thread)</li>
<li>  LockSupport.parkUntil(),LockSupport.unpark(Thread)</li>
</ul>
</li>
<li>  死亡：线程结束或者因为出现异常结束</li>
</ul>
<h1 id="二、使用线程"><a href="#二、使用线程" class="headerlink" title="二、使用线程"></a>二、使用线程</h1><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h2 id="实现runnable接口"><a href="#实现runnable接口" class="headerlink" title="实现runnable接口"></a>实现runnable接口</h2><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><p>与Runnable相比，Callable可以有返回值，是通过FutureTask进行封装的</p>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><h2 id="对比接口和继承"><a href="#对比接口和继承" class="headerlink" title="对比接口和继承"></a>对比接口和继承</h2><p>总体来说实现接口会更好一些，其一java不支持多继承，其二继承Thread类可能会造成不必要的开销</p>
<h1 id="三、基础线程机制"><a href="#三、基础线程机制" class="headerlink" title="三、基础线程机制"></a>三、基础线程机制</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>管理多个异步任务的执行，<font color="red">不清楚到底是干啥的</font></p>
<h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p>守护线程是线程的保姆，<font color="red">后续补充相应内容</font></p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><p>sleep方法会休眠当前执行的线程，单位为毫秒，注意一下有时候会问sleep和wait方法谁是object的谁是Thread的，sleep是Thread自己写的方法，sleep可能会抛出InterruptedException</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>是个静态方法，准确的说是Thread的静态方法，所以调用就是Thread.yield(),这哥们大概就是说我重要的逻辑都处理完了，CPU可以选择先执行别的线程，至于CPU接不接受那就不知道了</p>
<h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><p>线程会在执行完毕之后自动结束，运行中出现异常也会提前结束，也就是说程序在执行又没有异常的时候想要中断它就得执行一些操作了，而下面说的几个方法都是为了中断程序的</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>很明显前面的interrupt方法生效是有前提的（阻塞等待），要是run里面是个无限循环但又没有sleep之类的操作，可以在循环条件中加入interrupted(),这时如果线程丢下去调用了interrupt方法，interrupted就能接收到这个信号，将自己的返回值变为true，从而跳出循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// InterruptExample.java</span><br><span class="line">public class InterruptExample &#123;</span><br><span class="line"></span><br><span class="line">    private static class MyThread2 extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!interrupted()) &#123;</span><br><span class="line">                // ..</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;Thread end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用方法</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    Thread thread2 = new MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Executor的中断操作"><a href="#Executor的中断操作" class="headerlink" title="Executor的中断操作"></a>Executor的中断操作</h2><p><font color="red">和前面线程机制里面说的Excutor有关，再补充</font></p>
<h1 id="五、互斥同步"><a href="#五、互斥同步" class="headerlink" title="五、互斥同步"></a>五、互斥同步</h1><p>其实java有两种方式来实现互斥访问，一种是常见的synchronized，另一个ReentrantLock，反正不知道后面这个是干啥的</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>作用于对象，只有当不同线程中使用同一个对象时才会对修饰的代码块进行同步</p>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>和同步代码块一样</p>
<h3 id="同步一个类"><a href="#同步一个类" class="headerlink" title="同步一个类"></a>同步一个类</h3><p>这个应该也叫类锁,这时不同线程调用不同的对象也会对这部分语句进行同步</p>
<pre><code>public class SynchronizedExample &#123;

    public void func2() &#123;
        synchronized (SynchronizedExample.class) &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                System.out.print(i + &quot; &quot;);
            &#125;
        &#125;
    &#125;
&#125;



public static void main(String[] args) &#123;
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func2());
    executorService.execute(() -&gt; e2.func2());
&#125;
</code></pre>
<h3 id="同步一个静态方法"><a href="#同步一个静态方法" class="headerlink" title="同步一个静态方法"></a>同步一个静态方法</h3><p>作用于整个类</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>是java.util.concurrent包中的锁</p>
<pre><code>public class LockExample &#123;

    private Lock lock = new ReentrantLock();

    public void func() &#123;
        lock.lock();
        try &#123;
            for (int i = 0; i &lt; 10; i++) &#123;
                System.out.print(i + &quot; &quot;);
            &#125;
        &#125; finally &#123;
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        &#125;
    &#125;
&#125;



public static void main(String[] args) &#123;
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; lockExample.func());
    executorService.execute(() -&gt; lockExample.func());
&#125;
</code></pre>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul>
<li>  实现：synchronized是JVM实现的，ReentrantLock是JDK实现的</li>
<li>  性能：两者差不多</li>
<li>  等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情；对于这件事情ReentrantLock是可以的，而synchronized不行（不知道r是通过什么方式去处理所谓其他的事情，要是其他的事情依赖于同步代码中的数据那也没法去执行啊）</li>
<li>  公平锁：是指多个线程在等待同一个锁时，安装申请的时间顺序来获得锁，这件事儿上synchronized是不行的，ReentrantLock默认也不行，但是可以设置为公平锁</li>
<li>  锁绑定多个条件：<font color="red">一个ReentrantLock可以同时绑定多个Condition对象</font></li>
</ul>
<h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><p>其实从上面的对比中可以看出，ReentrantLock的功能是比synchronized要强大的，但实际使用中synchronized就足够了，而且synchronized属于是JVM亲生的，ReentrantLock来说的话不一定所有版本的JVM都支持，而且synchronized锁不需要手动释放</p>
<h1 id="六、线程间的协作"><a href="#六、线程间的协作" class="headerlink" title="六、线程间的协作"></a>六、线程间的协作</h1><p>当多个线程要一起去处理问题时，由于CPU对线程的调用是随机的，当我们想要他们有一定的执行顺序时就需要对他们进行协调</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>在一个线程中调用另一个线程的join()，当前线程将会挂起直到目标线程结束</p>
<pre><code>public class JoinExample &#123;

    private class A extends Thread &#123;
        @Override
        public void run() &#123;
            System.out.println(&quot;A&quot;);
        &#125;
    &#125;

    private class B extends Thread &#123;

        private A a;

        B(A a) &#123;
            this.a = a;
        &#125;

        @Override
        public void run() &#123;
            try &#123;
                a.join();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(&quot;B&quot;);
        &#125;
    &#125;

    public void test() &#123;
        A a = new A();
        B b = new B(a);
        b.start();
        a.start();
    &#125;
&#125;

//创建JoinExample类的对象调用test方法即可
</code></pre>
<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() notify() notifyAll()"></a>wait() notify() notifyAll()</h2><p>同步代码中调用wait()时将线程挂起，当其他的线程去调用了notify()或者notifyAll()时唤醒挂起的线程</p>
<ul>
<li>  他们都是Object的方法，而不是Thread的方法</li>
<li>  只有在被同步的代码中使用，否则会在运行时抛出IllegalMonitorStateException<font color="red">为什么不能在非同步的代码中调用呢</font></li>
<li>  使用wait挂起期间，线程会释放锁，这个就比较明确了，不释放锁别的线程就无法执行同步代码，<font color="red">看起来notify和notifyAll方法也都只能在同步代码中执行</font>，基于这个原因的话，不释放锁就永远无法唤醒也就死锁了</li>
<li>  案例：</li>
</ul>
<pre><code>public class WaitNotifyExample &#123;

    public synchronized void before() &#123;
        System.out.println(&quot;before&quot;);
        notifyAll();
    &#125;

    public synchronized void after() &#123;
        try &#123;
            wait();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;after&quot;);
    &#125;
&#125;



public static void main(String[] args) &#123;
    ExecutorService executorService = Executors.newCachedThreadPool();
    WaitNotifyExample example = new WaitNotifyExample();
    executorService.execute(() -&gt; example.after());
    executorService.execute(() -&gt; example.before());
&#125;
</code></pre>
<h2 id="和sleep方法的区别"><a href="#和sleep方法的区别" class="headerlink" title="和sleep方法的区别"></a>和sleep方法的区别</h2><ul>
<li>  wait是Object的方法，sleep是Thread的静态方法</li>
<li>  wait会释放锁，sleep不会</li>
</ul>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h2><p>前面的的wait是synchronized里面的，而这一套方法是ReentrantLock的</p>
<pre><code>public class AwaitSignalExample &#123;

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void before() &#123;
        lock.lock();
        try &#123;
            System.out.println(&quot;before&quot;);
            condition.signalAll();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public void after() &#123;
        lock.lock();
        try &#123;
            condition.await();
            System.out.println(&quot;after&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = new AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="七、J-U-C-AQS"><a href="#七、J-U-C-AQS" class="headerlink" title="七、J.U.C-AQS"></a>七、J.U.C-AQS</h1><p>java.util.concurrent(J.U.C)其实也就是前面说的ReentrantLock，这个东西提供了比synchronized更多的对线程的控制，能大大的提高并发的性能，而这个AQS被认为是J.U.C的核心</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来控制一个线程等待多个线程，内部维护了一个计数器cnt，每次调用countDown()方法的时候计数器值减一，减到0的时候那些因为调用了await方法而在等待的线程会被唤醒</p>
<pre><code>public class CountdownLatchExample &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        final int totalThread = 10;
        CountDownLatch countDownLatch = new CountDownLatch(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++) &#123;
            executorService.execute(() -&gt; &#123;
                System.out.print(&quot;run..&quot;);
                countDownLatch.countDown();
            &#125;);
        &#125;
        countDownLatch.await();
        System.out.println(&quot;end&quot;);
        executorService.shutdown();
    &#125;
&#125;
</code></pre>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>控制多个线程相互等待，就是只有当多个线程都执行到这个await方法时大家才能继续往下执行，内部同样是一个计数器，没当一个线程执行到await方法时计数器值减一，当计数器为0时，大家又能一起开开心心的往下执行了</p>
<pre><code>public class CyclicBarrierExample &#123;

    public static void main(String[] args) &#123;
        final int totalThread = 10;
        CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalThread; i++) &#123;
            executorService.execute(() -&gt; &#123;
                System.out.print(&quot;before..&quot;);
                try &#123;
                    cyclicBarrier.await();
                &#125; catch (InterruptedException | BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.print(&quot;after..&quot;);
            &#125;);
        &#125;
        executorService.shutdown();
    &#125;
&#125;
</code></pre>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>类似于操作系统中的信号量，可以控制对互斥资源的访问线程数</p>
<pre><code>public class SemaphoreExample &#123;

    public static void main(String[] args) &#123;
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalRequestCount; i++) &#123;
            executorService.execute(()-&gt;&#123;
                try &#123;
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + &quot; &quot;);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    semaphore.release();
                &#125;
            &#125;);
        &#125;
        executorService.shutdown();
    &#125;
&#125;
</code></pre>
<h1 id="八、J-U-C-其他组件"><a href="#八、J-U-C-其他组件" class="headerlink" title="八、J.U.C-其他组件"></a>八、J.U.C-其他组件</h1><p>实在没啥耐心看了，哈哈，以后要是需要用了再看看</p>
<ul>
<li>  FutureTask</li>
<li>  BlockingQueue</li>
<li>  ForkJoin</li>
</ul>
<h1 id="九、线程不安全示例"><a href="#九、线程不安全示例" class="headerlink" title="九、线程不安全示例"></a>九、线程不安全示例</h1><p>就是不对共享资源的访问操作进行同步操作的时候，结果会和预期不一致</p>
<pre><code>public class ThreadUnsafeExample &#123;

    private int cnt = 0;

    public void add() &#123;
        cnt++;
    &#125;

    public int get() &#123;
        return cnt;
    &#125;
&#125;



public static void main(String[] args) throws InterruptedException &#123;
    final int threadSize = 1000;
    ThreadUnsafeExample example = new ThreadUnsafeExample();
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; threadSize; i++) &#123;
        executorService.execute(() -&gt; &#123;
            example.add();
            countDownLatch.countDown();
        &#125;);
    &#125;
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());
&#125;
</code></pre>
<p>期望中得到的结果是1000，但实际可能得到的是998、997之类的不确定的数值</p>
<h1 id="十、java的内存模型"><a href="#十、java的内存模型" class="headerlink" title="十、java的内存模型"></a>十、java的内存模型</h1><p>也不知道为啥这突然就讲起了java的内存模型</p>
]]></content>
      <categories>
        <category>java</category>
        <category>2019</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 -- 摘录</title>
    <url>/2023/04/13/java/2019/%E6%91%98%E5%BD%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="面试摘录"><a href="#面试摘录" class="headerlink" title="面试摘录"></a>面试摘录</h1><h2 id="java平台的理解"><a href="#java平台的理解" class="headerlink" title="java平台的理解"></a>java平台的理解</h2><ul>
<li>  一次书写，到处运行，跨平台性</li>
<li>  垃圾收集</li>
<li>  解释执行，通常是javac编译为字节码文件，虚拟机将字节码转换为机器码；但是常见的虚拟机都提供了动态编译器运行时将热点代码编译成机器码，这个时候是解释执行</li>
<li>  语言特性：泛型、IO、网络、并发安全等基础类库</li>
<li>  JVM的一些概念，常见的垃圾收集器</li>
<li>  这里很好奇PHP是怎么做到的热更新</li>
</ul>
<h2 id="exception和error的区别"><a href="#exception和error的区别" class="headerlink" title="exception和error的区别"></a>exception和error的区别</h2><ul>
<li>  都继承了Throwable类</li>
<li>  尽量不要直接捕捉Exception这样的通用异常，给出明确的异常和处理更清晰</li>
<li>  异常信息的打印一定要有明确的日志</li>
<li>  大家认为java的异常设计存在缺陷，第一是大多数情况下我们捕获异常后都不可能恢复程序运行，第二是不兼容functional编程</li>
<li>  try catch会有额外的性能消耗影响JVM对代码的优化，所以尽量不要直接包含一大段代码；第二是不要用来做流程控制，因为性能远低于if else</li>
<li>  java没实例化一个exception都要对栈做快照，这个过程性能消耗很大</li>
</ul>
<h2 id="final、finally、-finalize的不同"><a href="#final、finally、-finalize的不同" class="headerlink" title="final、finally、 finalize的不同"></a>final、finally、 finalize的不同</h2><ul>
<li>final用来修饰类、方法、变量<ul>
<li>  final用来强调某些行为是不可更改的，避免意外赋值带来的编程错误，对于接口来说可以保证平台安全性</li>
<li>  并发编程中final可以减少性能消耗（也说了现在的JVM会有自己的判断，对final的依赖不大，大多数时候不用从性能方面进行考虑）</li>
<li>  另外，很多小技巧用来提升性能其实都有局限性，编程应该更偏于语意本身</li>
</ul>
</li>
<li>  finally是用于保证某些动作一定会得到执行，资源释放、连接关闭之类的</li>
<li>  finalize保证对象被回收之前某些资源是否要释放</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>2019</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>2019</tag>
      </tags>
  </entry>
  <entry>
    <title>十年一剑 -- Java版本迭代</title>
    <url>/2023/04/13/java/%E5%8D%81%E5%B9%B4%E4%B8%80%E5%89%91/Java%E7%89%88%E6%9C%AC%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h1 id="Java版本更新历史以及内容"><a href="#Java版本更新历史以及内容" class="headerlink" title="Java版本更新历史以及内容"></a>Java版本更新历史以及内容</h1><p>Java的前身叫oak在1991年代时候创建，并不成功，在1995年的时候改名为Java，并提出了write once，run anywhere</p>
<h2 id="1991-JDK1-0"><a href="#1991-JDK1-0" class="headerlink" title="1991-JDK1.0"></a>1991-JDK1.0</h2><p>Sun Class JVM、Applet、AWT</p>
<h2 id="1997-JDK1-1"><a href="#1997-JDK1-1" class="headerlink" title="1997-JDK1.1"></a>1997-JDK1.1</h2><p>JAR、JDBC、JavaBeans、RMI、Inner Class、Reflection</p>
<h2 id="1998-JDK1-2"><a href="#1998-JDK1-2" class="headerlink" title="1998-JDK1.2"></a>1998-JDK1.2</h2><ul>
<li>J2SE</li>
<li>j2ee</li>
<li>j2me</li>
<li>jit</li>
<li>collections</li>
<li>jfc</li>
<li>swing1.0</li>
<li>java2d</li>
<li>java plug-in</li>
<li>ejb</li>
<li>java idl</li>
<li>字符串常量做内存映射</li>
<li>对打包的Java文件进行数字签名</li>
<li>控制授权访问系统资源的策略工具</li>
</ul>
<h2 id="2000-JDK1-3"><a href="#2000-JDK1-3" class="headerlink" title="2000-JDK1.3"></a>2000-JDK1.3</h2><ul>
<li>数学运算</li>
<li>Timer api</li>
<li>java sound api</li>
<li>corba iiop实现rmi的通信协议</li>
<li>jar文件索引<h2 id="2002-JDK1-4"><a href="#2002-JDK1-4" class="headerlink" title="2002-JDK1.4"></a>2002-JDK1.4</h2></li>
<li>正则表达式</li>
<li>nio</li>
<li>logging</li>
<li>xml解析器</li>
<li>断言</li>
<li>jdbc3.0</li>
<li>ipv6<h2 id="2004-JDK1-5"><a href="#2004-JDK1-5" class="headerlink" title="2004-JDK1.5"></a>2004-JDK1.5</h2></li>
<li>自动装箱拆箱</li>
<li>泛型</li>
<li>注解</li>
<li>instrumentation</li>
<li>枚举</li>
<li>foreach（增强循环）</li>
<li>并发<h2 id="2006-JDK1-6"><a href="#2006-JDK1-6" class="headerlink" title="2006-JDK1.6"></a>2006-JDK1.6</h2></li>
<li>锁与同步</li>
<li>垃圾收集</li>
<li>类加载</li>
<li>Java compiler</li>
<li>web services</li>
<li>LDAP<h2 id="2011-JDK1-7（公司被甲骨文收购，很多计划拖延到了1-8）"><a href="#2011-JDK1-7（公司被甲骨文收购，很多计划拖延到了1-8）" class="headerlink" title="2011-JDK1.7（公司被甲骨文收购，很多计划拖延到了1.8）"></a>2011-JDK1.7（公司被甲骨文收购，很多计划拖延到了1.8）</h2></li>
<li>switch语句块中允许以字符作为分支条件</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
        <category>十年一剑</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>十年一剑</tag>
      </tags>
  </entry>
  <entry>
    <title>十年一剑 -- 基本数据类型</title>
    <url>/2023/04/13/java/%E5%8D%81%E5%B9%B4%E4%B8%80%E5%89%91/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>java的8中基本数据类型</p>
<p>byte            -127 - 127    8位1个字节   </p>
<p>short                    16位2个字节</p>
<p>int                        32位4个字节</p>
<p>long                        64位8个字节</p>
<p>float                        32位</p>
<p>double                    64位</p>
<p>char</p>
<p>boolen</p>
<p>byte为什么只能表示-127到127，一个byte是8位第一位用来表示正负数，所以是2的7次方</p>
<p>原码：计算机表示数字的代码</p>
<p>反码：正数的反码是自己本身，负数的反码是除符号位（第一位）以外的取相反值</p>
<p>补码：正数的补码是自己本身，负数的补码是它的反码加1</p>
<p>原码            反码            补码</p>
<p>1    0000 0001    0000 0001    0000 0001</p>
<p>-1    1000 0001    1111 1110    1111 1111</p>
]]></content>
      <categories>
        <category>java</category>
        <category>十年一剑</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>十年一剑</tag>
      </tags>
  </entry>
  <entry>
    <title>十年一剑 -- 面向对象思想</title>
    <url>/2023/04/13/java/%E5%8D%81%E5%B9%B4%E4%B8%80%E5%89%91/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h2 id="一、三大特性"><a href="#一、三大特性" class="headerlink" title="一、三大特性"></a>一、三大特性</h2><ul>
<li>  封装：利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</li>
<li>  继承：继承应该遵循里氏替换原则，自雷对象必须能够替换掉所有父类对象。</li>
<li>多态<ul>
<li>  编译时多态：主要指方法的重载</li>
<li>  运行时多态：程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
</li>
</ul>
<h2 id="二、类图（这里只简单介绍）"><a href="#二、类图（这里只简单介绍）" class="headerlink" title="二、类图（这里只简单介绍）"></a>二、类图（这里只简单介绍）</h2><ul>
<li>  泛化关系：Java中的继承</li>
<li>  实现：Java中对接口的实现</li>
<li>  聚合：表示整体由部分组成，但不是强依赖，整体不存在了部分还是会存在，比如电脑由显示器、主机、键盘鼠标等聚合在一起</li>
<li>  组合：强依赖，整体不存在了，部分也就不存在了，比如公司和部门</li>
<li>  关联关系：一对一、一对多、多对多</li>
<li>  依赖：依赖是在运行过程中起作用，比如a类是b类的一个局部变量</li>
</ul>
<h2 id="三、设计原则"><a href="#三、设计原则" class="headerlink" title="三、设计原则"></a>三、设计原则</h2><ul>
<li>  单一责任原则</li>
</ul>
<!---->

<pre><code>修改一个类的原因应该只有一个
</code></pre>
<p>就是一个类只负责做一件事情，如果一个类承担了过多的职责会增加耦合</p>
<ul>
<li>  开放封闭原则</li>
</ul>
<!---->

<pre><code>对扩展开放，对修改关闭
</code></pre>
<p>扩展就是添加新功能的意思，该原则要求在添加新功能或者需求发生变化时，通过添加新的代码来扩展模块的行为，而不是去修改那些已经存在的可以工作的代码。对这一原则的实现是使用抽象，把功能定义为一个抽象基类，它可以衍生出不同的子类来实现不同的功能，当需要扩展时只要添加新的实现就可以。</p>
<ul>
<li>  里氏替换原则:子类对象必须能替换所有父类对象（貌似java的继承语法默认实现了这一原则）</li>
<li>  接口分离原则：不应该强迫客户端依赖于它们不使用的方法，大概也是一对一的想法，一个接口就是一个功能，不要把与这个功能无关的内容写到里面</li>
<li>  依赖倒置原则</li>
</ul>
<!---->

<pre><code>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
抽象不应该依赖于细节，细节应该依赖于抽象。
</code></pre>
<p>本质的意思是说一个类a不要直接依赖另一个确切的类b，这种情况下如果后续的b的功能要发生变化的时候a会直接的受到影响，如果a需要依赖b那把b抽象出来成为接口，a去依赖于接口，后续b的需求发生了变化那就扩展接口，a的源码不需要发生变化</p>
<h2 id="自我解读"><a href="#自我解读" class="headerlink" title="自我解读"></a>自我解读</h2><p>这一个笔记的内容比较抽象，都是一些设计结构的思想，有一些东西需要明确。下面举一个栗子</p>
<p>母亲每天都要为小孩讲睡前故事</p>
<ul>
<li>  复杂的说（觉得很有意思）：这个事情是这样的本质是为了孩子入睡，所以这里有两个对象一个是母亲一个是孩子他们都是人的子类，孩子有一个变量叫懵逼值和一个状态值叫做入睡或者清醒，母亲有一个方法叫讲故事，讲故事这个方法需要一个参数–故事的内容来源，当母亲调用讲故事这个方法时孩子的懵逼值会上升，当懵逼值上升到一个点的时候状态由清醒变为入睡。</li>
<li>  简单的说：母亲有一个方法叫讲故事，我们要调用这个方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Book&#123;</span><br><span class="line">	public String getContent()&#123;</span><br><span class="line">		return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Mother&#123;</span><br><span class="line">	public void narrate(Book book)&#123;</span><br><span class="line">		System.out.println(&quot;妈妈开始讲故事&quot;);</span><br><span class="line">		System.out.println(book.getContent());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Mother mother = new Mother();</span><br><span class="line">		mother.narrate(new Book());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显一般妈妈脑瓜子里也不会记那么多的故事，也是要照着书念的，所以妈妈讲故事这个方法得依赖于一个对象故事书，在上面的模型里面如果妈妈哪天故事书上的故事讲完了，要讲这个报纸上的故事，但是很尴尬妈妈居然只会读书不会读报纸，这很明显和现实是不吻合的，所以得改一下</p>
<pre><code>interface IReader&#123;
    public String getContent();
&#125;
</code></pre>
<p>这是一个抽象的接口–读物，妈妈是可以读任何读物的</p>
<pre><code>class Newspaper implements IReader &#123;
    public String getContent()&#123;
        return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;
    &#125;
&#125;
class Book implements IReader&#123;
    public String getContent()&#123;
        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;
    &#125;
&#125;
 
class Mother&#123;
    public void narrate(IReader reader)&#123;
        System.out.println(&quot;妈妈开始讲故事&quot;);
        System.out.println(reader.getContent());
    &#125;
&#125;
 
public class Client&#123;
    public static void main(String[] args)&#123;
        Mother mother = new Mother();
        mother.narrate(new Book());
        mother.narrate(new Newspaper());
    &#125;

&#125;
</code></pre>
<p>现实的模型就应该是这样，哪天妈妈想给孩子读别的东西就去买回来，然后读就行了，这里有一个概念IReader、Newspaper、Book、Mother这些都是已经存在的，不应该被修改，只是添加新的模块（买一份海报），而修改Client这个类是应该的，它怎么说呢和上面别的类是不一样的，属于是对逻辑的处理，而不是一个对象实体</p>
]]></content>
      <categories>
        <category>java</category>
        <category>十年一剑</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>十年一剑</tag>
      </tags>
  </entry>
  <entry>
    <title>Show Me The Code -- break和continue</title>
    <url>/2023/04/13/java/Show%20Me%20The%20Code/break%E5%92%8Ccontinue/</url>
    <content><![CDATA[<p>以下为源代码：</p>
<ol>
<li><p>package test;</p>
</li>
<li><p>public class BreakTest {</p>
</li>
<li><pre><code>public static void main(String[] args) &#123;
</code></pre>
</li>
<li><pre><code>    System.out.println(&quot;-------------break-------------&quot;);
</code></pre>
</li>
<li><pre><code>    for(int i = 0 ; i&lt;10 ; i++)&#123;
</code></pre>
</li>
<li><pre><code>        if(i==5) break;
</code></pre>
</li>
<li><pre><code>        System.out.println(&quot;number : &quot;+ i);
</code></pre>
</li>
<li><pre><code>    &#125;
</code></pre>
</li>
<li><pre><code>    System.out.println(&quot;-------------continue-------------&quot;);
</code></pre>
</li>
<li><pre><code>    for(int i = 0 ; i&lt;10 ; i++)&#123;
</code></pre>
</li>
<li><pre><code>        if(i==5) continue;
</code></pre>
</li>
<li><pre><code>        System.out.println(&quot;number : &quot;+ i);
</code></pre>
</li>
<li><pre><code>    &#125;
</code></pre>
</li>
<li><pre><code>&#125;
</code></pre>
</li>
<li><p>}</p>
</li>
</ol>
<p>下为输出：</p>
<p><img src="/img/E105BCCA81C3466E9FC5B7D42D25E8EF.png"></p>
<p> </p>
<p>结果为：break是跳出了整个循环，而continue的作用是终止本次循环，开始下一次循环；</p>
]]></content>
      <categories>
        <category>java</category>
        <category>Show Me The Code</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Show Me The Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Show Me The Code -- excel解析的两种方法</title>
    <url>/2023/04/13/java/Show%20Me%20The%20Code/excel%E8%A7%A3%E6%9E%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>概述</p>
<p>java对excel进行解析有两种常见的方法：jxl和POI</p>
<p>jxl：java Excel api 是一个开放源码的项目，它本身是由java编写的，所有对平台没有要求。</p>
<p>POI：Apache的一个开源项目，POI存在一些小的bug，并且对图片的处理并不友好，其优势在于对公式的支持比较完善。</p>
<p>对比两者的一些结论：jxl对于java开发者来说还是更合适一些，它在图片处理方面也具有优势，并且当所处理的excel文档本身比较小时它在性能上也优于POI，只是在对公式或者宏的兼容上不如POI，POI在excel文档体积大时具有性能上的优势。</p>
<p>下面展示两种方法对excel文件的基本读写功能</p>
<p>所需jar</p>
<p><img src="/img/A0A0BBA56EB54381BF9734FD4611C6F0.png"></p>
<p>jxl只需要一个jar，剩下的三个都是对POI的支持，所以真正使用的时候，jxl的jar包更容易被导入项目，对POI来说最好的方法是到Apache官网上下载他的完整资源包，然后得到三个版本匹配的jar，不同版本的jar可能出现兼容性问题</p>
<p>code</p>
<p>jxl</p>
<p>package com.firefly.jxl;</p>
<p>import java.io.File;</p>
<p>import java.io.IOException;</p>
<p>import jxl.Sheet;</p>
<p>import jxl.Workbook;</p>
<p>import jxl.read.biff.BiffException;</p>
<p>import jxl.write.Label;</p>
<p>import jxl.write.WritableSheet;</p>
<p>import jxl.write.WritableWorkbook;</p>
<p>import jxl.write.WriteException;</p>
<p>import jxl.write.biff.RowsExceededException;</p>
<p>public class JXLTest {</p>
<pre><code>private static String EXCEL_PATH = &quot;D://excel//TestExcel.xls&quot;;

public static void main(String[] args) &#123;
</code></pre>
<p>//        writeExcel();</p>
<pre><code>    ReadExcel();

&#125;



public static void ReadExcel() &#123;

    System.out.println(&quot;  ---------  read start  ---------&quot;);

    System.out.println(&quot;  ---------  check file exists  ---------&quot;);

    File excel = new File(EXCEL_PATH);

    if(!excel.exists()) &#123;

        System.out.println(&quot;  read excel exception case the excel file not exsits  &quot;);

        return;

    &#125;

    File xlsFile = excel;

    try &#123;

        // 获得工作簿对象

        Workbook workbook = Workbook.getWorkbook(xlsFile);

        // 获得所有工作表

        Sheet[] sheets = workbook.getSheets();

        // 遍历工作表

        if (sheets != null)&#123;

             for (Sheet sheet : sheets)&#123;

                // 获得行数

                int rows = sheet.getRows();

                // 获得列数

                int cols = sheet.getColumns();

                // 读取数据

                for (int row = 0; row &lt; rows; row++)&#123;

                   for (int col = 0; col &lt; cols; col++)&#123;

                      System.out.printf(&quot;%10s&quot;, sheet.getCell(col, row)

                            .getContents());

                   &#125;

                   System.out.println();

                &#125;

             &#125;

          &#125;

          workbook.close();

    &#125; catch (BiffException e) &#123;

        e.printStackTrace();

    &#125; catch (IOException e) &#123;

        e.printStackTrace();

    &#125;

      

&#125;



public static void writeExcel() &#123;

    System.out.println(&quot;  ---------  write start  ---------&quot;);

    System.out.println(&quot;  ---------  check file exists  ---------&quot;);

    File excel = new File(EXCEL_PATH);

    //判断该文件以及该路径是否存在，不存在则创建

    if(!excel.exists()) &#123;

        System.out.println(&quot;  ---------  excel file not exists  ---------&quot;);

        if(!excel.getParentFile().exists())

            System.out.println(&quot;  ---------  folder not exists  ---------&quot;);

            excel.getParentFile().mkdirs();

        try &#123;

            excel.createNewFile();

        &#125; catch (IOException e) &#123;

            e.printStackTrace();

        &#125;

    &#125;

    

    File xlsFile = excel;

    try &#123;

        // 创建一个工作簿

        WritableWorkbook workbook = Workbook.createWorkbook(xlsFile);

        // 创建一个工作表

        WritableSheet sheet = workbook.createSheet(&quot;sheet1&quot;, 0);

        for (int row = 0; row &lt; 10; row++)&#123;

           for (int col = 0; col &lt; 10; col++)&#123;

              // 向工作表中添加数据

              sheet.addCell(new Label(col, row, &quot;data&quot; + row + col));

           &#125;

        &#125;

        System.out.println(&quot;  ---------  write success  ---------&quot;);

        workbook.write();

        workbook.close();

    &#125; catch (RowsExceededException e) &#123;

        e.printStackTrace();

    &#125; catch (WriteException e) &#123;

        e.printStackTrace();

    &#125; catch (IOException e) &#123;

        e.printStackTrace();

    &#125;

&#125;
</code></pre>
<p>}</p>
<p>POI</p>
<p>package com.firefly.poi;</p>
<p>import java.io.File;</p>
<p>import java.io.FileNotFoundException;</p>
<p>import java.io.FileOutputStream;</p>
<p>import java.io.IOException;</p>
<p>import org.apache.poi.EncryptedDocumentException;</p>
<p>import org.apache.poi.hssf.usermodel.HSSFRow;</p>
<p>import org.apache.poi.hssf.usermodel.HSSFSheet;</p>
<p>import org.apache.poi.hssf.usermodel.HSSFWorkbook;</p>
<p>import org.apache.poi.openxml4j.exceptions.InvalidFormatException;</p>
<p>import org.apache.poi.ss.usermodel.Row;</p>
<p>import org.apache.poi.ss.usermodel.Sheet;</p>
<p>import org.apache.poi.ss.usermodel.Workbook;</p>
<p>import org.apache.poi.ss.usermodel.WorkbookFactory;</p>
<p>public class POITest {</p>
<pre><code>private static String EXCEL_PATH = &quot;D://excel//TestExcelForPoi.xls&quot;;

public static void main(String[] args) &#123;

    // TODO Auto-generated method stub
</code></pre>
<p>//        writeExcel();</p>
<pre><code>    ReadExcel();

&#125;



public static void ReadExcel() &#123;

    System.out.println(&quot;  ---------  read start  ---------&quot;);

    System.out.println(&quot;  ---------  check file exists  ---------&quot;);

    

    File excel = new File(EXCEL_PATH);

      if(!excel.exists()) &#123;

          System.out.println(&quot;  ---------  excel file not exists  ---------&quot;);

          return;

      &#125;

    File xlsFile = excel;

      // 获得工作簿

      Workbook workbook;

    try &#123;

        workbook = WorkbookFactory.create(xlsFile);

        // 获得工作表个数

        int sheetCount = workbook.getNumberOfSheets();

        // 遍历工作表

        for (int i = 0; i &lt; sheetCount; i++)&#123;

           Sheet sheet = workbook.getSheetAt(i);

           // 获得行数

           int rows = sheet.getLastRowNum() + 1;

           // 获得列数，先获得一行，在得到改行列数

           Row tmp = sheet.getRow(0);

           if (tmp == null)&#123;

              continue;

           &#125;

           int cols = tmp.getPhysicalNumberOfCells();

           // 读取数据

           for (int row = 0; row &lt; rows; row++)&#123;

              Row r = sheet.getRow(row);

              for (int col = 0; col &lt; cols; col++)&#123;

                 System.out.printf(&quot;%10s&quot;, r.getCell(col).getStringCellValue());

              &#125;

              System.out.println();

           &#125;

        &#125;    

    &#125; catch (EncryptedDocumentException e) &#123;

        e.printStackTrace();

    &#125; catch (InvalidFormatException e) &#123;

        e.printStackTrace();

    &#125; catch (IOException e) &#123;

        e.printStackTrace();

    &#125;

      

      

&#125;



public static void writeExcel() &#123;

    System.out.println(&quot;  ---------  write start  ---------&quot;);

    // 创建工作薄

    HSSFWorkbook workbook = new HSSFWorkbook();

    // 创建工作表

    HSSFSheet sheet = workbook.createSheet(&quot;sheet1&quot;);



    for (int row = 0; row &lt; 10; row++)&#123;

         HSSFRow rows = sheet.createRow(row);

         for (int col = 0; col &lt; 10; col++)&#123;

            // 向工作表中添加数据

            rows.createCell((short) col).setCellValue(&quot;dataPoi update&quot; + row + col);

         &#125;

      &#125;

    

    //判断该文件以及该路径是否存在，不存在则创建

    System.out.println(&quot;  ---------  check file exists  ---------&quot;);

    File excel = new File(EXCEL_PATH);

      if(!excel.exists()) &#123;

          System.out.println(&quot;  ---------  excel file not exists  ---------&quot;);

          if(!excel.getParentFile().exists())

              System.out.println(&quot;  ---------  folder not exists  ---------&quot;);

              excel.getParentFile().mkdirs();

          try &#123;

              excel.createNewFile();

          &#125; catch (IOException e) &#123;

              e.printStackTrace();

          &#125;

      &#125;

    File xlsFile = excel;

    FileOutputStream xlsStream;

    try &#123;

        xlsStream = new FileOutputStream(xlsFile);

        workbook.write(xlsStream);

        System.out.println(&quot;   --------  excel write  success   -------&quot;);

    &#125; catch (FileNotFoundException e) &#123;

        // TODO Auto-generated catch block

        e.printStackTrace();

    &#125; catch (IOException e) &#123;

        // TODO Auto-generated catch block

        e.printStackTrace();

    &#125;

   

&#125;
</code></pre>
<p>}</p>
<p>sFile);</p>
<pre><code>        workbook.write(xlsStream);

        System.out.println(&quot;   --------  excel write  success   -------&quot;);

    &#125; catch (FileNotFoundException e) &#123;

        // TODO Auto-generated catch block

        e.printStackTrace();

    &#125; catch (IOException e) &#123;

        // TODO Auto-generated catch block

        e.printStackTrace();

    &#125;

   

&#125;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>java</category>
        <category>Show Me The Code</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Show Me The Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Show Me The Code -- 设计模式--单例</title>
    <url>/2023/04/13/java/Show%20Me%20The%20Code/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<p>简述：单例指一个类只允许拥有一个对象，而且这个对象是它自己进行实例化然后向整个系统提供出来，这样我们把它称为单例类。</p>
<p>结构和特点：只有一个实例；这个实例必须自己创建；为其他的所有对象提供这个实例；</p>
<p>使用场景：计数器、加载配置文件信息的类</p>
<p>饿汉式：</p>
<hr>
<p>package com.firefly.singleton;</p>
<p>public class EagerSingleton {</p>
<pre><code>private static EagerSingleton es = new EagerSingleton();



private EagerSingleton()&#123;

    System.out.println(&quot; eager singleton&quot;);

&#125;



public static EagerSingleton getInstance()&#123;

    return es;

&#125;
</code></pre>
<p>}</p>
<hr>
<p>懒汉式：</p>
<hr>
<p>package com.firefly.singleton;</p>
<p>public class LazySingleton {</p>
<pre><code>private static LazySingleton ls = null;



private LazySingleton()&#123;

    System.out.println(&quot; lazy singleton&quot;);

&#125;



public static synchronized LazySingleton getInstence()&#123;

    if(ls == null)&#123;

        ls = new LazySingleton();

    &#125;

    return ls;

&#125;
</code></pre>
<p>}</p>
<hr>
<p>枚举式：</p>
<hr>
<p>package com.firefly.singleton;</p>
<p>public enum Single{</p>
<pre><code>uniqueInstence;



public void singleOperation()&#123;

    System.out.println(&quot;I&#39;m a singleton by enum !&quot;);

&#125;
</code></pre>
<p>}</p>
<hr>
<p>小结：懒汉模式就是上来就直接初始化实例，但这带来的问题就是浪费了资源；饿汉模式呢等到要用的时候再去初始化，但是要考虑到多线程带来的影响做了同步处理，这样每次创建的时候都要去判断同步锁会降低效率； 枚举是现在最完美的单例实现方式，因为它是通过jvm自己去做的同步处理，且枚举本身就绝对防止多次初始化；</p>
]]></content>
      <categories>
        <category>java</category>
        <category>Show Me The Code</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Show Me The Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Show Me The Code -- 设计模式--代理</title>
    <url>/2023/04/13/java/Show%20Me%20The%20Code/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>简述：代理模式的实现是，被代理的类和代理类同时继承一个抽象类，代理类拥有被代理类的对象在重写的方法中调用被代理类的方法，这个过程中加上一些需要的操作</p>
<p>抽象类：</p>
<p>package com.firefly.proxy;</p>
<p>public abstract class Father {</p>
<pre><code>public abstract void operation();
</code></pre>
<p>}</p>
<p>被代理类：</p>
<p>package com.firefly.proxy;</p>
<p>public class User extends Father{</p>
<pre><code>@Override

public void operation() &#123;

    System.out.println(&quot; user do it !!!&quot;);

&#125;
</code></pre>
<p>}</p>
<p>代理类：</p>
<p>package com.firefly.proxy;</p>
<p>public class Proxy extends Father{</p>
<pre><code>@Override

public void operation() &#123;

    System.out.println(&quot;something proxy want do !!!&quot;);

    User u = new User();

    u.operation();

    System.out.println(&quot;another thing proxy want do !!!&quot;);

&#125;
</code></pre>
<p>}</p>
<p>调用类：</p>
<p>package com.firefly.proxy;</p>
<p>public class RunTest {</p>
<pre><code>public static void main(String[] args) &#123;

    Proxy p = new Proxy();

    p.operation();

&#125;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>java</category>
        <category>Show Me The Code</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Show Me The Code</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记10--XML解析</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B010--XML%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Java笔记10–XML解析</p>
<p>2016年1月20日</p>
<p>15:56</p>
<p>几个常见名词间的关系图</p>
<p><img src="/img/BBAFA667B0854D569A2531D742FD09E1.png"></p>
<p>DOM和SAX是模型、JAXP实现了他们两的接口、JDOM和DOM4J是DOM的分支、Xerces和Crimson是继承自JAXP的实现。</p>
<p>DOM–文档对象模型（document object module）</p>
<p>基于树和节点的文档对象模型称为DOM。</p>
<p>DOM解析器吧XML文档转化为一个包含内容的树，并可以对树进行遍历。</p>
<p>优缺点：编程容易，调用建树指令，可以很容易的添加和修改树中的元素。处理大型文件是其性能下降的非常厉害，因为它在解析文件之前把整个文档装入内存，可以想象其面对大文件时的尴尬。</p>
<p>SAX–事件驱动模型</p>
<p>基于事件的xml简单API称为sax（simple API for xml）</p>
<p>Sax不需要一次全部装载整个文件，当遇到一个像文件开头、结尾或者是标签的开头与结束时，它会触发一个事件，适合对xml的顺序访问。</p>
<p> </p>
<p>JAXP–DOM和SAX接口的实现</p>
<p>Sun公司提供了JAXP（java API for xml parsing）来实现DOM 和SAX接口，同时具有了他们两的解析能力，其实是完成了堆他们两的包装，采用了设计模式中的工厂模式。</p>
<p> </p>
<p>DOM的分支发展–JDOM和DOM4J</p>
<p>JDOM和DOM4J是DOM的两种变体，他们并不完全符合W3C的规范。</p>
<p>JDOM是一种面向java的读、写和操作XML文档的API。实现了sax和dom标准兼容，为java程序员提供了一个简单、轻量的xml文档操作方法；它其实是专门为java程序员开发的，采用了许多java语言的优秀特征，比如方法的重载、集合和类映射。（这个东西由于是专门为了java为设计的，相当于是官方的儿子，所以一生出来就受到了大力的推广）</p>
<p>DOM4J是一个易用的、开源的库，用于XML、XPth和XSLT。应用于java平台，采用了java集合框架并完全支持DOM、SAX和JAXP。（这个东西是开源的，相当于是人民的儿子，所以近年来发展得越来越好了）</p>
<p> </p>
<p>Xerces和Crimson</p>
<p>Xerces是有Apache组织所推动的一项xml文档解析开源项目，它目前有多种语言版本（java、c++、perl、com等），号称是地球上最快的xml解释器。</p>
<p>Crimson是一个基于java的xml解析器。</p>
<p> </p>
<p>流式操作库StAX</p>
<p>StAX（streaming API for xml）是一个基于java语言处理xml的最新标准，作为一种面向流的方法，无论从性能还是可用性上都优于其他方法，好像只是对dom和sax而言的（那两种方法本来就是很原始的，这句话就像是废话一样）</p>
<p> </p>
<p>总结：jdom和dom在性能测试中表现不佳，在测试10mb的文档是内存溢出。</p>
<p>Sax表现较好。</p>
<p>Dom4j性能最好，hibernate中就是用它来读取xml配置问价的，在不考虑可移植性的条件下推荐使用它。</p>
<p><img src="/img/C9B493D0C7AB40599B1CD2C7CCA43BDC.png"></p>
<p><img src="/img/7A17C4E60158430E87D909EEBF264722.png"></p>
<p><img src="/img/930AAE0576CC49049CE43B01A5D0A3F6.png"></p>
<p><img src="/img/ADB7B2A280DF427CBABE37C99C379CDB.png"></p>
<p><img src="/img/4A0AA9D0C2EC45A493D9AC8D2B2CE3A6.png"></p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记1--类反射</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B01--%E7%B1%BB%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>Java笔记1–类反射</p>
<p>2016年1月20日</p>
<p>13:32</p>
<p>什么是类反射？为什么要有类反射？类反射能做什么？</p>
<p>        首先java是一种静态的语言，即它在编译后便不会再作出改变，这让它有了很高的安全性，但这也会降低它的灵活性。</p>
<p>        类反射机制是让一个java类在运行时还能对它的状态进行调整的机制，这在一定程度上弥补了它灵活性不足的缺点。</p>
<p>        类反射能对类进行各种操作：</p>
<p>        1.获取一个对象的类型：</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31</td>
<td>package com.firefly.classreflect.pojo;<br> <br>public class Student {<br>    private int id;<br>    public String name;<br>    public int getId() {<br>        return id;<br>    }<br>    public void setId(int id) {<br>        this.id = id;<br>    }<br>    public String getName() {<br>        return name;<br>    }<br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>    public Student(int id, String name) {<br>        super();<br>        this.id = id;<br>        this.name = name;<br>    }<br>    public Student(String name) {<br>        super();<br>        this.name = name;<br>    }<br>    public Student() {<br>        super();<br>    }<br> <br>}</td>
</tr>
</tbody></table>
<p>以上的Student.java是一个普通的java类</p>
<p> </p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22</td>
<td>package com.firefly.classreflect.test;<br> <br>public class Main {<br>    public static void main(String[] args) {<br>        try {<br>            Class c = Class.forName(“com.firefly.classreflect.pojo.Student”);<br>            System.out.println(c);<br>        } catch (ClassNotFoundException e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br> <br>        String s = “abc”;<br>        Class c1 = s.getClass();<br>        System.out.println(c1);<br> <br>        Class c2 = String.class;<br>        System.out.println(c2);<br> <br> <br>    }<br>}</td>
</tr>
</tbody></table>
<p>以上为三种常见获取对象类型的方法</p>
<p>Class类是整个Java反射机制的源头，Class类本身表示Java对象的类型，我们可通过一个Object对象的getClass()方法取得一个对象的类型，此函数返回的就是一个Class类。</p>
<p>注意Class是一个类，而class是一种类型，如同String，int</p>
<p> </p>
<p>如何获得一个类的构造方法，并用来创建一个对象：</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24</td>
<td>package com.firefly.classreflect.test;<br> <br>import java.lang.reflect.Constructor;<br> <br>import com.firefly.classreflect.pojo.Student;<br> <br>public class AccessConstructor {<br>    public static void main(String[] args) {<br>        try {<br>            Class c = Class.forName(“com.firefly.classreflect.pojo.Student”);<br>            //返回一个装有该类所有构造方法的数组<br>            Constructor[] con1 = c.getDeclaredConstructors();<br>            //通过参数获得特定的构造方法，并创建对象<br>            Constructor con = c.getConstructor(String.class);<br>            Student s = (Student)con.newInstance(“test”);<br>            System.out.println(s.getName());<br> <br>        } catch (Exception e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br> <br>    }<br>}</td>
</tr>
</tbody></table>
<p>以下演示如何获得成员变量，并改变它的值：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45</td>
<td>package com.firefly.classreflect.test;<br> <br>import java.lang.reflect.Constructor;<br>import java.lang.reflect.Field;<br> <br>import com.firefly.classreflect.pojo.Student;<br> <br>public class AccessField {<br>    public static void main(String[] args) {<br>        try {<br>            Class c = Class.forName(“com.firefly.classreflect.pojo.Student”);<br>            //获得指定的构造方法，创建对象<br>            Constructor con = c.getConstructor(int.class,String.class);<br>            Student s = (Student)con.newInstance(1,”test”);<br>            //重新得到Class类对象，为了以下演示获得成员变量需要，该方法无法使用Student类型<br>            Class c1 = s.getClass();<br>            //获得了所有的成员变量<br>            Field[] f = c1.getDeclaredFields();<br>            for(Field field : f){<br>                System.out.println(“名为：”+field.getName());<br>                System.out.println(“类型：”+field.getType());<br>                //如果该变量无访问权限，则给予权限<br>                if(!field.isAccessible()){<br>                    field.setAccessible(true);<br>                }<br>                //改变该变量的值<br>                if(field.getType().equals(int.class)){<br>                    System.out.println(“原来值为：”+field.get(s));<br>                    field.setInt(s, 2);<br>                    System.out.println(“修改后的值为：”+field.get(s));<br>                }<br>                if(field.getType().equals(String.class)){<br>                    System.out.println(“原来值为：”+field.get(s));<br>                    field.set(s, “旭哥”);<br>                    System.out.println(“修改后的值为：”+field.get(s));<br>                }<br>            }<br> <br> <br>        } catch (Exception e) {<br>            // TODO Auto-generated catch block<br>            e.printStackTrace();<br>        }<br>    }<br>}</td>
</tr>
</tbody></table>
<p>如何获得类的方法并调用：</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37</td>
<td>package com.firefly.classreflect.test;<br> <br>import java.lang.reflect.InvocationTargetException;<br>import java.lang.reflect.Method;<br> <br>import com.firefly.classreflect.pojo.Student;<br> <br>public class AccessMethod {<br>    public static void main(String[] args) {<br>        Student s = new Student(“firefly”);<br>        Class c = s.getClass();<br>        //获得所有的方法<br>        Method[] method = c.getDeclaredMethods();<br>        for(Method m : method){<br>            System.out.println(“方法名为：”+m.getName());<br>            //获得所有的参数<br>            Class[] parameterType = m.getParameterTypes();<br>            for(Class p : parameterType){<br>                System.out.println(“方法的参数为：”+p);<br>            }<br>            System.out.println(“返回值类型为：”+m.getReturnType());<br>            if(!m.isAccessible()){<br>                m.setAccessible(true);<br>            }<br>            //获得指定方法并调用<br>            if(“show”.equals(m.getName())){<br>                try {<br>                    m.invoke(s);<br>                } catch (Exception e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br>            }<br> <br>        }<br>    }<br>}</td>
</tr>
</tbody></table>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记13--虚拟机之类文件</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B013--%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%B1%BB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<ol>
<li><p>类文件结构</p>
</li>
<li><p>概述：计算机发明的时候它只认识0和1，经过这么多年的高速发展，它仍然只认识0和1，但我们将编写的程序编译成二进制本地机器码已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式；Java就是为了跨平台而诞生的，而现在，Java虚拟机更加强调语言无关性，因为平台无关性已经成为语言的共性而不能作为Java存活的保证了，语言无关性值Java虚拟机接受执行非Java语言程序；也许日后虚拟机的语言无关性会超越它在平台无关性上的优势；</p>
</li>
<li><p>class类文件结构–以下为一个简单类的class文件：（Class文件是采用一种类似于c语言结构体的伪结构来存储数据的，这种结构中只有两种数据类型：无符号数和表；无符号数以u1、u2、u4、u8分别表示1、2、4、8个字节的无符号数，无符号数是可以表示数字、引用、数量值或者按照UTF-8编码构成的字符串值的基本数据类型；表是有多个无符号数或者其他表构成的复合数据类型）</p>
</li>
</ol>
<p><img src="/img/2A41AF1D120D44729C940037B350EA57.png"></p>
<ol>
<li><p>魔数：每个class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的class文件，很多文件的存储标准中都采用魔数来进行身份认证，比如gif或者JPG等在头文件中都存有魔数，使用魔数而不是扩展名来进行识别主要是基于安全方面考虑，显然扩展名容易受到修改；而Java的魔数标识是CAFEBABE（咖啡宝贝，有毒，Java是一种什么咖啡的生产地，这些程序员是多喜欢咖啡）；</p>
</li>
<li><p>class文件版本：紧接着魔数的4个字节存储的是Class文件的版本号；第4和第5个字节存储的是副版本号，这个例子中的编号为：00 00 00 34；为16进制数，转换为十进制为50，所谓副版本号的意思是这样的：00 03 00 34，这个编号为：50.3；jdk高版本可处理低版本文件，却不能处理高版本文件；每个版本的jdk具体能处理多少版本号这里就不列举了；</p>
</li>
<li><p>常量池：在主次版本号之后的是常量池入口，常量池是占用Class文件空间最大的数据项目之一；由于常量池中常量的数量的不固定的，所以在常量池人入口需要放置一项u2类型的数据来代表常量池的计数器；案例中的00 16即十进制中的22，代表常量池中有21个常量，从1开始计算，0表示“不引用任何一个常量池项目”常量池中主要存放的两大类常量：字面量和符号引用（类的接口的权限定名、字段的名称和描述符、方法的名称），Java代码在编译的时候不会把字段、方法等信息存储在Class文件中，而是在常量池中保存相应的符号引用，在类创建或是运行时解析、翻译到具体的内存地址中去；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记11--虚拟机</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B011--%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<p>Java发展趋势</p>
<p>模块化：将一个庞大的系统分为若干个子模块；人们不愿意为了系统中一个小块的功能而下载安装一套庞大的系统；</p>
<p>混合语言：当单一的Java开发已经无法满足当前软件的复杂需求时，将系统划分出层次，每个应用层将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言间不存在交互上的困难；通过特定的语言区解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向；</p>
<p>多核并行：计算机CPU的发展方向从高频率转变为多核心，为了适配计算机的性能编程语言也要进入多核时代；</p>
<p>进一步丰富的语法</p>
<p>64位的虚拟机：主流CPU支持64位架构了，Java虚拟机在很早以前就推出了64位系统的版本，但问题是现在64位的虚拟机将比32位的虚拟机多消耗内存且性能更低；Java正在试图通过压缩堆内对象的指针来改善这一情况；</p>
<p>解析jdk</p>
<p>自动内存管理机制</p>
<p>java内存区域与内存溢出异常</p>
<p>概述：java与c++的区别，java为编程者写好了内存管理和垃圾回收，使用者不用关注这方便的问题，但是当出现内存溢出时，同样也很难找出问题发生的地方；c++则是把这个东西全部交给了程序员，人们要去写自己的内存管理，会非常繁杂，但是出现问题时容易解决</p>
<p>运行时数据区域:</p>
<p>程序计数器：是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器；虚拟机的字节码解释器在工作是就是通过改变这个计数器的值来选取下一条需要执行的字节码指令；分支、循环、跳转、异常处理、线程恢复等基础的功能都是需要依赖这个计数器来完成的；一个内核在一个时刻只能处理一个线程的指令，但是它不一定是要把这个线程里面的所有指令执行完了才跳转到另一个线程的，所以每一个线程都有自己的一个程序计数器，用来记录刚才cpu执行这个线程的位置，当这个线程能再次执行的时候恢复进度；这个内存区域是java虚拟机中唯一一个没有规定任何OutOfMemoryError情况的区域；</p>
<p>java虚拟机栈：线程私有，生命周期与线程相同；描述java方法执行的内存模型，每个方法在执行的时候就会创建一个栈帧用于存储方法内的数据，每个方法的执行对应了方一个栈帧的入栈到出栈；（人们常说的java内存分为堆和栈，这个地方的栈只是java虚拟机栈中的一个部分–局部变量表部分，这个部分存放的是编译期可知的各种基本类型包括8中基本类型和对象引用reference,局部变量表所需的内存空间在编译期间分配完成，当一个方法进入时，这个方法需要在帧中分配多大的局部变量空间是确定的，在方法运行期间不会改变局部变量表的大小）；这个区域规定了两种异常情况：线程请求深度大于了虚拟机允许的深度抛出StackOverflowError异常，大多数的虚拟机是可以动态扩展的，当扩展无法申请到足够的内存，就会抛出OutOfMemoryError异常</p>
<p>本地方法栈：本地方法栈与虚拟机栈的区别只是在于它是用于处理Native方法服务的；</p>
<p>java堆：堆的故事好像是很多的，还是退个行写吧</p>
<p>首先呢， 在java一开始的定义中，堆是对象实例存放的地方，java虚拟机规范中是这样说的：所有的对象实例以及数组都要在堆上分配；但是随着什么jit编译器和逃逸分析技术的逐渐成熟，栈上分配和标量替换优化技术导致这个东西也变得不那么的绝对；它是各个线程共享的，必须是啊，对象都在这个地方存着的，你还能不给人对象了不成；</p>
<p>其次呢，java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”（Garbage Collected Heap），国内要是把它翻译成“垃圾堆”才好呢；</p>
<p>最后呢，这个区域被分为了‘新区’、’老区‘什么的，在后面还会详细的说明；记得以前看jvm优化时有分配内存的大小，当一个堆的内存太大超过给定的最大值时，抛出OutOfMemoryError异常；</p>
<p>方法区：也是线程共享的；它用于存储已被虚拟机加载的类的信息数据；在java虚拟机规范中把它描述为堆的一个逻辑部分，但是它有一个别名叫做Non-Heap（非堆），目的应该是与java堆区分开来；这个区域的管理可受用户的调节，可以选择不实现垃圾回收，相对堆，垃圾收集行为在这个区域出现较少，但并不意味着数据进入后会永久保存；这个区域的内存回收主要针对常量池的回收和对类型的卸载；这个区域同样会抛出OutOfMemoryError异常</p>
<p>运行时常量池：</p>
<p>这个东西是上面所说的方法区的一部分；Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table,这些东西好像在英文中都是什么什么table，所以在上面讲一个区域的时候在后面加一个表字），用于存放编译期生成的字面量和符号引用，通常翻译出来的直接引用也会放到这，这部分内容将在类加载后进入方法区的运行时常量池中存放；</p>
<p>还记得以前说一个java文件运行的过程时，有一个步骤是讲虚拟机检查Class文件的格式是否正确，这里说一下，java虚拟机对Class文件的每一个部分的格式都有严格的规定，不然它是不会认可和装载你的，但是呢对于运行时常量池，java虚拟机规范没有做任何细节的要求；</p>
<p>要注意的是，这个区域的数据不是只有Class文件中常量池的内容才能进入的，也就是说在运行的时候也可以将新的常量放进去；这个特性在String的intern（）方法中体现特别明显；</p>
<p>注意Integer这样的包装类的缓存池（-128-127）是包装类自己实现了一个内部类来进行了对象缓存是代码层面的设计模式，而这里说的常量池是JVM层面的，Java里面类在运行的时候类名、方法名等描述类的内容会放到这里</p>
<p>直接内存：这个东西其实并不属于虚拟机的一部分，但是它是作为一个缓冲区来沟通本机内存和java虚拟机内存的机制，来提高效率，有的时候，管理员在配置jvm时忽略了这一个部分，导致几个区域的大小加起来呢超过了本机的内存，从而出现outofMemoryError异常；</p>
<p>HotSpot虚拟机对象探秘：在上面呢我们大致的了解了java虚拟机的运行时数据区，下面呢就详细的看一看HotSpot虚拟机在java堆中对象分配、布局和访问的全过程；</p>
<p>对象的创建：下面大致的说明一个普通的java对象的创建过程</p>
<p>当虚拟机遇到一条new指令时，首先它回去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，就是说看一看这个想要用来创建对象的类是否存在，是否被加载、解析和初始化；如果没有那就要执行这些步骤，这里就不详细的说，后面再说吧；</p>
<p>经过上面的步骤后，虚拟机就会着手创建对象了，首先是为新生的对象分配内存；所需内存的大小在类被加载完成后就可以确定了，那么现在要做的就是在堆中划分出来这么一块大小的内存给这个对象，这个时候有两种情况，第一是堆中内存是绝对规整的，意思是用过的内存是连续的一部分和没有用过的内存是用一个指针分开的，那么就只要把指针向着没有用过的内存方向移动对象大小的一段就行了，这种方法叫做指针碰撞，另一种是内存空间是不规整的，就是已使用的内存和未使用的内存是相互交错的，这时虚拟机就需要用一个列表来记录那些内存是用过了的，那些是没用用过的，分配一块足够大的空间给对象实例，并跟新列表记录，这种方法叫做空闲列表；而选择那种方式是由堆是否规整决定的，堆是否规整是由所采用的垃圾回收器是否带有压缩整理功能决定的，使用带Compact过程的收集器是用的是指针碰撞，使用者种基于Mark-Sweep算法的收集器是，通常采用空闲列表；</p>
<p>除了上面说的如何划分空间外，还有就是并发的问题，如果两个对象同时创建，都要移动指针就尴尬了，有两种解决办法，一种是将这个过程做成线程安全的，另一种是给每个线程在java堆中预先分配一块内存，称为本地线程分配缓存（TLAB)，给他们独立分配，只是在分配TLAB时才需要同步锁，虚拟机是否使用这种技术可以通过一个参数设定；</p>
<p>接下来，虚拟机要对对象进行必要的设置，诸如这个对象是哪个类的实例、如何才能找到类的元数据、对象的GC分代年龄等；这些信息存放在对象的对象头中，对象头的故事下面会讲；</p>
<p>上面的工作完成后，在虚拟机看来创建对象已经完成了，但是明显还不是我们要的对象，在执行完new指令后会执行init方法，把对象按照我们的意愿来进行初始化；这时一个我们所需要的对象就创建完成了；</p>
<p>对象的内存布局:对象在内存中的布局分为3块区域–对象头、实例数据、对齐填充</p>
<p>对象头：包括两部分信息–第一部分是存储了对象的运行时数据：什么哈希码、gc分代年龄、锁状态之类的关于这个对象生存状态的信息，不是对象的类信息；这个部分在虚拟机规范中叫做“Mark Word”；第二部分是一个指针，指向该对象的类的元数据，虚拟机通过这个指针来确定这个对象是哪个类的对象，但是虚拟机还有别的方法来确定这一点，如果对象是一个数组，那么对象头中还要有一块区域来存储数组的长度，虚拟机在装载类的时候就会确定该类对象的大小，但是数组的大小是不能通过这个过程确定的；</p>
<p>实例数据：对象真正存储的有效信息；这里不仅是存储了对象指向的类的字段还有父类的信息，且父类定义的变量会在子类之前；</p>
<p>对齐填充：这个部分不是必然存在的，HotSpot虚拟机的自动内存管理系统要求对象起始地址必须的8字节的整数倍，但实际上并不是每个对象占用的空间大小都是8的倍数，这时候就需要这个部分类填充把不到8字节的部分补上；</p>
<p>对象的访问定位：对象在使用的时候Java程序需要通过栈上的reference数据来操作堆中的对象；但是Java虚拟机规范中并没有规定reference该通过什么方式去定位、访问堆中的对象；具体的方法是取决于虚拟机实现；主流的访问方式有两种</p>
<p><img src="/img/3E3E8691F03A4F48843429F8A6D4FB08.png"></p>
<ol>
<li><p>句柄访问：这种方式访问时，Java堆中将会划分出一块内存来作为句柄池，reference中存储对象的句柄地址，在句柄中包含了对象实例数据域类型数据各自的具体地址；</p>
</li>
<li><p>直接指针访问：reference中存储的直接就是对象的地址；</p>
</li>
<li><p>两种方法的区别：一个对象的实例数据是在堆中存储的，而它的对象类型数据是在方法区中存储的；句柄访问是由一个空间来存储分别指向这两个数据的指针；直接指针访问时就不同了，因为这时的reference中只是存放了指向Java堆中实例数据的指针，所以在这个实例数据部分中还应该有一个指向方法区中对象类型数据的指针；句柄访问在定位对象时多出一次指针查找，但是当对象发生迁移时，reference只要指向句柄就行，不用去改变reference的值；由于在Java程序中对对象的调用频率很高，所以HotSpot选择了第二种方法；</p>
</li>
<li><p>垃圾收集器与内存分配策略</p>
</li>
<li><p>对象已死？    在回收对象之前，肯定要先判断这个对象是否还有人在使用，也就是确定哪些对象还“活着”，哪些对象已经“死去”；判断一个对象是否死亡的方法有以下几种：</p>
</li>
<li><p>引用计数法：用一个计算器记录对象引用的个数，当引用个数为0时，我们认为这个对象已经死亡，这个方法有一个缺陷是，当两个对象互相引用的时候，在这种方法判断中，他们两都会永远的活着，即使我们不再使用这两个对象；</p>
</li>
<li><p>可达性分析算法：在这个体系里面有一系列的“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索的路径叫引用链，当一个对象不能连接到这些引用链上时，我们认为这个对象已经死掉了；</p>
</li>
<li><p>再说引用：单纯的引用难以满足我们的实际需求，我们需要有这样的引用，当我们内存不足时能够抛弃一些对象，通过引用自己做到，因此，引用有了4种扩充分类：</p>
</li>
<li><p>强引用：只要这种引用还存在，GC就不会回收它的对象；</p>
</li>
<li><p>软引用：一些还有用但非必须的对象，在发生内存溢出前，将把这些对象进行GC，如果这个步骤之后内存还是不足，系统将会抛出内存溢出；</p>
</li>
<li><p>弱引用：强度低于软引用，只能生存到下一次GC，当GC发生时不管内存是否足够，这一类对象都会被回收；</p>
</li>
<li><p>虚引用：该机制的唯一作用是在对戏被回收是会发出一个系统通知；</p>
</li>
<li><p>生存还是死亡：即使是在可达性分析中处于不可达的对象也不是立即就会死亡的，一个对象的真正死亡还要经历两个标记过程，一个对象被发现不可达时，会进行第一次标记，这时会做一次筛选，当一个对象没有覆盖finalize（）方法或者是该方法已经被虚拟机调用了，这两种情况被视为“没有必要再执行finalize方法”；如果一个对象被认为需要执行finalize方法，那么这个对象会被放置到一个叫F-Queue的队列中，然后虚拟机其实就要开始清理了，但在这段时间类若果这些个对象还可以重新与引用链上的任何一个对象建立关联即可，在第二次标记时它将被移出“即将回收”的集合，那它就能完成自救；</p>
</li>
<li><p>回收方法区：相对于堆中的垃圾回收来说，方法区（HotSpot虚拟机中叫做永久代）中垃圾回收效率非常低，很多人认为方法区中没有垃圾回收，方法区中的垃圾回收主要有两部分内容–废弃常量和无用的类，当常量池中有一个常量没有任何的String对象引用它，那么内存回收时这个字面量就会被清理出常量池，常量池中其他类、方法、字段的符号引用也是与此类似；判断一个类是否是“无用”的类要满足一下三点：该类的所有实例都被回收，java堆中不存在该类的任何实例；加载该类的ClassLoader已经被回收；该类的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法；</p>
</li>
<li><p>垃圾收集算法</p>
</li>
<li><p>标记-清除算法：首先标记出需要回收的对象，在标记完成后统一回收被标记的对象；它主要有两个不足的地方–其一标记会清除两个过程的效率都不高，其二标记清除后会产生大量不连续的内存碎片；</p>
</li>
<li><p>复制算法：把内存分为两个大小相等的空间，每次只使用其中的一块，当一块的内存用完了，就将还存活着的对象复制到另一块去，将用过的那部分一次清理掉；这种方法实现简单，运行高效，但是代价是将内存缩小了一半，太高昂了；现代虚拟机都采用这个方法来管理新生代，IBM公司研究表明，新生代的对象98%都是”朝生夕死“，所以并不需要按照1:1来分配空间，虚拟机将新生代按8:1:1分为三块，一块较大的Eden和两块较小的Survivor；每次使用Eden和一块Survivor；这样只有10%的空间是被浪费的；当然了，我们并不能保证每次回收都只有不多于10%的对象是存活着的，这种时候我们的做法是依赖老年代进行分配担保，后面还会详细的说明；</p>
</li>
<li><p>标记-整理：复制算法在处理对象存活率较高时效率将会变低；根据老年代的特点我们用到标记-整理算法：与标记-清除不同的是，在回收时，让存活的对象向同一个方向移动，那么空出来的空间就是连续的了；</p>
</li>
<li><p>分代收集算法：当前商业虚拟机采用的垃圾收集算法，将内存划分为几块根据对象的存活周期；一般是吧java堆分为新生代和老年代，这样在不同的分代采用各自合适的算法，同常在新生代采用复制算法，在老年代采用标记-清理或者标记-整理；</p>
</li>
<li><p>垃圾收集器：上面的垃圾收集算法是理论，收集器则是具体的实现，以下列举常见的垃圾收集器，省略具体实现：</p>
</li>
<li><p>Serial：单线程，它工作时”Stop The World“，别的线程都要停下来；</p>
</li>
<li><p>ParNew：Serial的多线程版本；</p>
</li>
<li><p>Parallel Scavenge：一个新时代收集器，使用复制算法；</p>
</li>
<li><p>Serial Old：Serial的老年代版本，同样是单线程，使用”标记-整理“算法；</p>
</li>
<li><p>Parallel Old：Parallel Scavenge的老年代版本，使用多线程”标记-整理“算法；</p>
</li>
<li><p>CMS</p>
</li>
<li><p>G1：基本属于最先进的收集器；能同时管理新老代；</p>
</li>
<li><p>GC日志：记录垃圾回收的日志，有统一的格式要求；</p>
</li>
<li><p>内存分配与回收策略</p>
</li>
<li><p>对象优先在Eden分配–当Eden没有足够空间时虚拟机会发起一场Minor GC；（Minor GC发生在新生代的垃圾回收，非常频繁，回收速度快，Major/Full GC，发生在老年代，频率低，速度一般比Minor慢10倍以上）</p>
</li>
<li><p>大对象直接进入老年代–当虚拟机需要为一个大对象分配一个连续的大的内存空间时不得不提前触发垃圾回收来获取足够的空间，所以对虚拟机来说遇到一群大对象是一个坏消息，更坏的消息是遇到一群“朝生夕死”的大对象；这时我们可以通过设置参数规定大于某个值的对象直接在老年代中分配空间来避免新生代过于频繁的垃圾回收；</p>
</li>
<li><p>长期存活的对象将进入老年代：当对象在新生代的gc中每存活一次就长一岁；到达一个我们可以设置的值之后就可以进入老年代；</p>
</li>
<li><p>动态对象年龄判定：为了能更好的适应不同程序的内存状况，虚拟机运行当Survivor中相同年龄的所有对象的大小总和大于了Suvivior空间的一半时，年龄大于或者等于该年龄的对象可以直接进入老年代，不用继续在新生代中徘徊；</p>
</li>
<li><p>空间分配担保：在发生Minor GC之前，虚拟机会先检查老年代中是否还有足够的空间来装下新生代的所有对象；如果能，当然就让Minor GC顺利的进行了；如果不能，则要看用户是否允许担保失败，通过HandlePromotionFailure设置，如果允许，那么继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行Minor GC，尽管这次GC是有风险的；如果小于或者是根本不允许担保，那就要改为进行一次Full GC； 这里的风险是指，如果该Minor GC后晋升到老年代的对象大小超过了老年代可用的空间大小，则老年代还是要进行一次Full GC；不过显然开启风险担保是一种可行的做法；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记2--故事汇</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B02--%E6%95%85%E4%BA%8B%E6%B1%87/</url>
    <content><![CDATA[<p>Java笔记2–故事汇</p>
<p>2016年1月20日</p>
<p>14:49</p>
<p>java储存数据的空间：</p>
<p>    寄存器（registers）：读取速度最快的地方，位于处理器内部。</p>
<p>    栈（stack）：位于RAM（random-access memory 随机访问内存）</p>
<p>    堆（heap）：位于RAM，对象存储的位置。    </p>
<p>    静态存储空间：静态属性的数据</p>
<p>    常量存储空间：常量数据</p>
<p> </p>
<p>this的故事：</p>
<p>    this相当于是一个对自己的引用，当该类的第一个对象在被创建后，this便会指向这个对象，于是当该类还没有创建对象之前我们不能去调用this，所以在静态的方法中不能出现this。</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25</td>
<td>package com.firefly.javatest.pojo;<br> <br>public class Student {<br>    public int id;<br>    public String name;<br>    public Student(String name) {<br>        super();<br>        this.name = name;<br>    }<br> <br>    public Student(int id) {<br>        super();<br>        this.id = id;<br>    }<br> <br>    public Student(int id,String name){<br>        this(name);//必须写在第一行，不然会报错<br>        //this(id);不能调用两次构造函数<br>        this.id=id;<br>    }<br> <br>    void print(String name){<br>        //this(name);也不能在非构造函数的地方调用<br>    }<br>}</td>
</tr>
</tbody></table>
<p>以上展示this调用构造函数的实例：</p>
<p>    1.必须在构造函数的第一行用this调用别的构造函数</p>
<p>    2.同一个构造函数里不能用this掉用别的构造函数两次，基于第一点衍生出来的</p>
<p>    3.不能在非构造函数中用this调用构造函数</p>
<p> </p>
<p>equals的故事：</p>
<p>     equals在用于比较包装类的类型时，是去比较其内部存储的值，但是当它用于比较，普通的类的时候只是比较对象引用指向的地址是否相同，没有什么意义，与“==”是一样的。</p>
<p> </p>
<p>java只会为成员变量赋初值，但是如果是局部变量，java是不会管它的，所以在方法里面定义的变量必须要为它赋值。</p>
<p> </p>
<p>package的命名规则：所有字母小写，包括首字母和中间单词的首字母。</p>
<p> </p>
<p>finall的故事：</p>
<p>         1.final类：final类不能被继承，因此会产生很多美丽的故事，诸如它的方法不可能被覆盖，即它的方法都默认为fianl类型，它不会有子类，会相对独立。什么时候我们会想要去用到final修饰方法呢，当你确定你写的这个类不需要扩展，写完就完了，更是不想被人修改。</p>
<p>         2.final方法：</p>
<p>                使用原因：第一、把方法锁定，防止任何继承类修改它的意义和实现。</p>
<p>                   第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。</p>
<p>        3.final变量（ 常量）：</p>
<p>                final修饰的变量一经赋值便不会改变，也就是常量了，java允许我们先定义一个final常量并且不立即赋值，这叫做final空白，但你得记住，你必须要在构造函数中为你所有的final空白赋初值。因为编译器必须确保它在使用前被初始化。这种机制允许你有多个构造函数，也就是说你能为不同的对象给予常量以不同的值。</p>
<p> </p>
<p>        4.fianl参数：当参数为final修饰时，你无法再去改变这个参数的值。</p>
<p> </p>
<p>static 的故事：</p>
<p>        将数据或者方法独立于对象之外，使其变成一个所有人都可以使用的公共属性的东西。与面向对象的想法是相违背的。</p>
<p> </p>
<p>方法的重写（overriding）和重载（overloading）</p>
<p>        重写是重写了父类的方法，参数和返回值都要相同，会覆盖父类的方法。</p>
<p>        重载是一个类中出现方法名相同的方法。</p>
<p> </p>
<p>接口的故事：</p>
<p>            接口是一个存粹的抽象类。实现多继承。</p>
<p>            继承实现多个类向上转型为一个父类型，而接口实现一个类向上转型为多个接口。</p>
<p>            接口和抽象类的选用：当你没有要求该类一定要对堆中数据进行操作是就可以用接口，有一个准则为优先使用接口。</p>
<p>                                               接口中不用对数据进行操作，所以不用对堆进行操作。 </p>
<p>            接口中的成员变量会自动成为public static final类型。</p>
<p> </p>
<p>常量在java中用大写字母表示，中间用下划线隔开。</p>
<p> </p>
<p>？？？内隐类（inner class）将一个类的定义置于另一个类中。</p>
<p>将一个字符串的首字母转       换为大写的代码： str.replaceFirst(str.substring(0, 1),str.substring(0, 1).toUpperCase()) ；//str是我们要的字符串</p>
<p>instanceof 是java中的一个保留字，用于检测一个对象是不是由某个类来创建的 </p>
<p> </p>
<p>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记3--.class文件的流程</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B03--.class%E6%96%87%E4%BB%B6%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>Java笔记3–.class文件的流程</p>
<p>2016年1月20日</p>
<p>14:51</p>
<p>JAVA运行过程：</p>
<p>        关于装载：</p>
<p>            java文件经过编译会形成一个class文件，class程序代码只有在初次被使用时才会被装载。</p>
<p>            首次使用class的时间点是静态初始化的进行时机，static对象或者程序区被装载时，是依据他们在程序代码中的次序。</p>
<p>    </p>
<p>        1.找到main方法，故事由这个类开始展开</p>
<p>        2.装载这个类的父类（如果父类仍有父类，则总是先装载父类，递归装载）</p>
<p>        3.装载该类    1）static修饰的代码块，变量，方法依次执行</p>
<p>                             2）执行main方法中的代码</p>
<p>                （成员变量的赋值是在对象的创建后完成的）</p>
<p> </p>
<p>class生命周期：</p>
<p>        </p>
<p> </p>
<p>    1.装载：将.class文件加载进入jvm的运行时数据区的方法区中以二进制数据流的方式存储，同时在堆中创建java.lang.Class对象，这个对象封装了类在方法区中的数据结构，作为方法区中这个类的信息入口。</p>
<p>    2.连接：1）验证：验证文件格式和各种细节与jvm是否兼容之类的事。</p>
<p>                 2）准备：为类的静态变量分配内存并设为jvm默认的初值，对于非静态的变量，则不会为它们分配内存。注意，静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。</p>
<p>                 3）解析：把常量池中的符号引用转换为直接引用，符号引用就是一个类中对另一个类的方法的调动语句。直接引用是指向对象的指针。</p>
<p>    3.初始化：        类的初始化   实例化对象</p>
<p>    4使用：主动引用–会引起类的初始化</p>
<p>                被动引用–不会引起类的初始化</p>
<p>    5.卸载：</p>
<p>                在类使用完之后，如果满足下面的情况，类就会被卸载：</p>
<p>                       1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</p>
<p>                       2. 加载该类的ClassLoader已经被回收。</p>
<p>                       3. 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>                        如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记4--集合框架</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B04--%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<ol>
<li><p>Collection：最基本的集合接口；有一个帮助类叫做Collections用于表示任何对象或元素组，想要尽可能以常规方式处理一组元素师，就使用这一类，实际上使用很少；</p>
</li>
<li><p>List：继承了Collection接口以定义一个允许重复项的有序集合；该接口是连续的所以面向位子的操作对它来说很方便，也就是对第几个位子上的元素进行操作；</p>
</li>
<li><p>LinkedList：它是链表结构，它添加了一些处理列表两端的元素的方法；这个就是应为它的结构导致了它在插入元素方面有优势，而在遍历方便有缺陷；Java中这个类提供了对首尾元素的获取和修改和删除的方法；使用这些方法我们可以把它当做一个堆栈、队列或其他一些面向端点的数据结构；</p>
</li>
<li><p>ArrayList：封装了一个动态再分配的Object[]数组；它是线性结构决定它在对某个位置的元素的操作上有优势，但是在插入元素上有缺陷，因为你如果向第一个位置插入元素，那么后面的所有元素都要移动，明显是很浪费资源的；</p>
</li>
<li><p>Vector：类似于ArrayList只不过它是线程安全的；</p>
</li>
<li><p>Set：继承Collection接口，而且它不允许集合中存在重复项，它是依赖对象的equal方法来检查独一性的；它没有引进新方法，所以它其实就是一个Collection，只不过其行为不同；</p>
</li>
<li><p>HashSet：无序的存储不重复自由集合，可以允许存在一个null；</p>
</li>
<li><p>TreeSet：使用二叉树结构；有序的存取元素，为此呢，你添加到TreeSet中的元素必须是可排序的，在你添加元素时它就自动按照某种规则排好了顺序；</p>
</li>
<li><p>LinkedHashSet：扩展HashSet，它可以按元素插入的顺序来访问各个元素；提供了一个可以快速访问各个元素的有序集合；它增加了实现的代价，因为它要以双向链表的方式将哈希表元中的元素链接在一起；</p>
</li>
<li><p>Map：不是继承 Collection了，它是用于维护键值对的；键和值都可以是null，但是只能有一个键为null，且不能把map作为一个键或者值添加给自己；</p>
</li>
<li><p>HashMap：便于在map中插入、删除、和定位元素，访问速度快，最常用；</p>
</li>
<li><p>HashTable：与HashMap相似，线程安全，不允许键或值为null；</p>
</li>
<li><p>TreeMap：需要按照自然的顺序或自定义顺序遍历map时使用，所以遍历时得到的是有序的结果；</p>
</li>
<li><p>LinkedHashMap：也是为了以插入的顺序遍历map，也双向链表结构；</p>
</li>
<li><p>Iterator：在Collection和List接口中都有一个iterator（）方法返回一个itreator，它能以迭代的方式逐个的访问集合中的各个元素</p>
</li>
<li><p>Boolean hasNext（）；判断是否存在另一个可访问的元素</p>
</li>
<li><p>Object next（）；返回要访问的下一个元素；如果到达集合结尾则抛出NoSuchElementException异常；</p>
</li>
<li><p>void remove（）；删除上次访问返回的对象；本方法必须紧跟在一个元素的访问后面，如果上次访问后集合已被修改，那么僵抛出IllegalStateException异常；</p>
</li>
<li><p>Hash表：是一种数据结构，用来查找对象；它为每个对象计算出一个整数，称为HashCode（如果我记得没错的话这里的计算在不同的地方所用的计算方法也不同）。</p>
</li>
<li><p>Comparable接口和Comparator接口：集合框架中的两种毕节接口；Java中的想String啊Integer之类的内建类实现了Comparable接口以提供一定的排序方式；自己编写的类可以通过实现Comparator接口来定义自己的比较方式；</p>
</li>
<li><p>在java.lang包中Comparable接口适用于一个类有自然顺序的时候，假定对象集合是同一类型，该接口允许你把集合排序成自然顺序；什么意思呢，就是说啊，在java2SDK版本1.4中有二十四个类实现了这个接口，BigDecimal,BigInteger,Byte, Double, Float,Integer,Long,Short 按数字大小排序 </p>
</li>
</ol>
<p>Character  按 Unicode 值的数字大小排序  String  按字符串中字符 Unicode 值排序 即可对对象进行排序了；</p>
<p><img src="/img/3AA1B7A3863D4EE5A36805F47D1BFDC3.png"></p>
<p>6个接口、5个抽象类、8个实现类</p>
<p><img src="/img/C43D1FFB9C974987854C32B49A302DC3.png"></p>
<p>本笔记的学习于：<a href="http://doc.okbase.net/DavidIsOK/archive/94766.html">http://doc.okbase.net/DavidIsOK/archive/94766.html</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记5--多线程</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B05--%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>1.进程与线程：dos系统有一个非常明显的特点，一旦有一种病毒之后，系统就会立刻死机，因为dos系统是单进程的。</p>
<p>            线程间共享资源，而每个进程都有自己独立的内存，且难以共享和切换。</p>
<p>            线程是在进程基础上的进一步划分。而且线程是在进程上并发执行的。</p>
<p>            如果有多个任务同时执行，则所有的系统资源是共享的，被所有的线程公用，但是程序的执行需要cpu，当我们只有一个CPU时，在一个时间点上就只会有一个程序运行。</p>
<p>2.java中多线程的实现的两种方法：</p>
<p>            继承thread类：</p>
<p>               thread类是java.lang包中的，而这个包是在程序运行时自动导入的，所以我们不需要手动的导入包。</p>
<p>                继承了thread后这个类就有了开启多线程的能力，我们必须去复写run方法，将我们希望每个线程中执行的代码写到里面。</p>
<p>                然后我们创建这个类的对象，用对象调用start方法就可以了，关于start方法：start方法中有相关的判断，如果我们把一个对象调用两次start方法，也就是重复开启线程，start方法中会抛出异常。上面已经说过线程涉及到要抢占CPU，则需要调用系统底层的函数来计算那个多个线程如何占用cpu，所以在start方法中还有一个native关键字。它的意思就是去调用操作系统的函数完成相关的功能。</p>
<p>         实现runnable接口：</p>
<p>               让一个类实现runnable接口，这个类复写run方法，与上面的方法相同。</p>
<p>                创建该类的对象，让后将对象给Thread实例化，new Thread(myRunnable).start();    注意我们只要创建一次myRunnable对象，可以把后面的语句看成是开启一个线程，写几次就是开启几个线程。具体代码如下：</p>
<p>   那么两种多线程的实现方法有什么区别呢：</p>
<p>   如果你的类已经继承了别的类，那就只好去实现runnable接口了，java的单继承属性。</p>
<p>3.常见的问题      </p>
<p>    线程的名字：可以自己命名，虚拟机会自动分配名字，主线程的名字是mian，非主线程的名字不确定；线程的名字是可以获取的；</p>
<p>    获取当前线程对象的方法是：Thread.currentThread();</p>
<p>    线程使用start方法来启动但是执行时候并不是按照启动的顺序来的；</p>
<p>    当目标run()方法结束时该线程完成；</p>
<p>4.java线程栈模型：存储了内存中线程调度的栈信息，当前调用的方法总是位于栈顶；每个线程私有的；       </p>
<p>5.线程的生命周期</p>
<p>        线程有    创建、可运行、运行中、阻塞、死亡5 中状态。</p>
<p>                新建：线程对象已经创建，但是没有调用start方法来开启多线程；</p>
<p>                可运行状态：使用start（）方法启动一个线程后，系统为该线程分配了除CPU外的所有资源。线程不是启动就一定会被运行的，在等待运行的这段时间久是可运行状态；</p>
<p>                运行状态：java运行系统通过调度选中一个线程，使其占有CPU并转为运行中状态，此时系统真正执行线程的run（）方法。</p>
<p>                阻塞、等待、睡眠状态：一个正在运行的线程因某种原因不能继续运行时，进入阻塞状态。</p>
<p>                死亡状态：当线程的run方法执行完成后就认为它死去；这个线程的对象也许还是活着的，但是他已经不是一个单独执行的线程了；线程一旦死亡就不能复生；如果在一个死去的线程的对象上调用start方法或抛出异常；</p>
<p>6.阻止线程的运行</p>
<p>    除了io阻塞外，考虑下面的三种情况：</p>
<p>        睡眠：Thread对象中有一个静态的sleep方法，它可以强制当前正在执行的线程休眠；原因可能是线程执行太快了或者需要强制进入下一轮，java中没有保证合理的轮换；将该方法写入到run方法中就可以实现线程的睡眠；线程睡眠是帮助所有线程获得允许机会的好方法；线程睡眠时间到期后，会回到可运行状态而不是运行状态，也就是它不是一定会在苏醒后就立马得到运行机会；</p>
<p>        等待、对象锁；</p>
<ol start="7">
<li>线程的优先级和线程让步yield()</li>
</ol>
<p>    优先级：JVM基于优先级来调度线程；大多数情况下当前运行的线程的优先级将大于或等于线程池中任何线程的优先级的，但这不是绝对的；优先级为我们提供一个调度线程执行顺序的方法；编程的时候不能过多的依赖优先级，因为它没有保障只是作为一种提高程序效率的方式；优先级范围是1-10；设置方法：线程对象.setPriority(n);默认为5；</p>
<p>    Thread.yield()方法的作用是让当前执行的进程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会；实际使用中它也不是一定能做到轮换的作用，因为有可能这个线程回到可运行状态后立即又被线程调度再次选中了；</p>
<p>    Thread的非静态方法join();使用方法：a线程对象.join();将当前线程加入到a线程对象的后面，直到a线程结束后才会执行当前的线程，这个地方我也不知道别的线程会不会受到影响，按照逻辑来说对别的线程是没有影响的；这个方法的实现其实是等待，该方法还可以传入等待的时间，这时就是等待a线程结束或者到达了等待的时间后当前的线程会回到可运行状态；</p>
<p>8.小结会导致线程离开运行状态的情况：</p>
<p>    线程的run方法运行完成了；    线程调度决定将线程由运行状态转移到可运行状态；    调用sleep方法使线程睡眠；    在对象上调用wait方法使线程等待；    调用yield方法使线程让步；    调用join方法使线程等待另一个线程先完成；    线程不能在对象上获得锁定，它正试图运行该对象的方法代码；</p>
<p>9.线程的同步锁</p>
<p>    线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏；</p>
<p>    锁：java中每个对象都有一个内置锁，当程序运行到非静态synchronized同步的方法时，自动获得于正在执行代码类的当前实例有关的锁（为什么是有关的，因为你的这个对象可能又指向了另一个对象，从而调用了些个关联的对象的同步方法或是代码块时它的锁也会被当前进程获得），这时别的线程不能进入该对象上的同步方法或代码块了（注意是对象，而不是类），直到该锁被释放，释放锁指的是持有锁的线程退出了同步方法或代码块；持有锁的线程封锁了该对象的所有同步方法，而非同步方法是可以自由访问的；</p>
<p>    synchronized：可以修饰一个方法，也可以修饰一个代码块，在修饰代码块是必须指定是要与哪个对象进行同步；不可以直接修饰一个变量；</p>
<p>    静态方法同步：由于在调用静态方法时，对象实例不一定被创建，因此，就不能使用this来同步静态方法，而必须使用Class对象来同步静态方法。</p>
<p>    阻塞：调用同一个对象的非静态的同步方法时会发生阻塞，调用同一个类中的静态同步方法的线程将阻塞，静态和非静态的同步方法不会彼此阻塞，对于同步代码块来说一定要看清指定的对象是否是同一个，不同对象上持有锁的线程是不会相互阻塞的；</p>
<p>10.线程安全类：当一个类已经很好的同步以保护了它的数据时我们称这个类是线程安全的；</p>
<p>11.线程死锁：两个线程相互阻塞，产生死锁；下面为死锁的一个例子：</p>
<p>    </p>
<ol>
<li><p>publicclass DeadlockRisk {</p>
</li>
<li><pre><code>private static class Resource &#123;
</code></pre>
</li>
<li><pre><code>    public int value;
</code></pre>
</li>
<li><pre><code>&#125; 
</code></pre>
</li>
<li><pre><code>private Resource resourceA =new Resource(); 
</code></pre>
</li>
<li><pre><code>private Resource resourceB =new Resource(); 
</code></pre>
</li>
<li><pre><code>public int read() &#123;
</code></pre>
</li>
<li><pre><code>    synchronized (resourceA) &#123;
</code></pre>
</li>
<li><pre><code>        synchronized (resourceB) &#123;
</code></pre>
</li>
<li><pre><code>            return resourceB.value + resourceA.value;
</code></pre>
</li>
<li><pre><code>        &#125; 
</code></pre>
</li>
<li><pre><code>    &#125; 
</code></pre>
</li>
<li><pre><code>&#125; 
</code></pre>
</li>
<li><pre><code>public void write(int a,int b) &#123; 
</code></pre>
</li>
<li><pre><code>    synchronized (resourceB) &#123;
</code></pre>
</li>
<li><pre><code>        synchronized (resourceA) &#123;
</code></pre>
</li>
<li><pre><code>            resourceA.value = a; 
</code></pre>
</li>
<li><pre><code>            resourceB.value = b; 
</code></pre>
</li>
<li><pre><code>        &#125; 
</code></pre>
</li>
<li><pre><code>    &#125; 
</code></pre>
</li>
<li><pre><code>&#125; 
</code></pre>
</li>
<li><p>}</p>
</li>
</ol>
<p>    如果一个线程调用了read，另一个线程调用的write，那么它们可能会一个持有一个A的锁另一个持有B的锁，那个它们就产生了死锁，其实上面的代码中产生死锁的概率是很小的，但毕竟有可能产生；</p>
<p> </p>
<p>  ；</p>
<p> </p>
<p>  </p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记6--内嵌类</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B06--%E5%86%85%E5%B5%8C%E7%B1%BB/</url>
    <content><![CDATA[<p>Java笔记6–内嵌类</p>
<p>2016年1月20日</p>
<p>14:58</p>
<p>6    java中的几种典型类：</p>
<p>   6.1   java静态类：</p>
<p>            特性：静态类不能实例化（静态类在运行时静态的加载到内存中，不需要初始化，没有实例，不能用this），类的成员都要是静态成员和静态方法。</p>
<p>                      静态方法不需要实例调用，类名.方法名（静态方法存在的意义就是为该程序中的其他类提供一些工具，为了方便使用）</p>
<p>                      静态变量是存在了常量池中。</p>
<p>                      静态代码块是在一个类第一次装载时运行，且只运行一次。</p>
<p>                      静态内部类：通常普通类是不允许用static修饰的，只有一个内部类才可以，静态内部类不需要实例化一个外部类，只要通过  外部类.内部类   引用就行了</p>
<p>   6.2   java匿名类：</p>
<p>             应用场景：当我们想要一个对象但却不值得为它而创建一个全新的对象（所需要的类过于简单，或者是我们只是要在一个方法内部使用）</p>
<p>                              通常在开启多线程和Swing应用程序中创建快速时间处理程序</p>
<p>                              把匿名类作为一个方法的返回值，返回一个接口的实现类对象，只是这个实现类没有名字。</p>
<p>   6.3   java内部类：</p>
<p>                定义：在一个类里面声明另一个类。</p>
<p>                特性：可以使用包含它的类的静态和实例成员变量，也可以使用它所在的方法的局部变量。</p>
<p>                           可以定义为abstract  可以声明为private或protected</p>
<p>                           若被声明为了static，就变成顶层类，不能再使用局部变量了</p>
<p>                           若想在Inner Class中声明任何的static成员，则这个InnerClass必须声明为static。</p>
<p>                           在创建非静态的内部类对象时，哟啊先创建相应的外部类对象，因为它有指向外部类对象的引用（当外部内和内部类的变量名重复时，其实这时有两个this指针，外部类.this.外部变量名）</p>
<p>                使用实例：    首先我们要有一个接口（外部的，正常的）</p>
<p>                                      我们在一个类中想要获得这个接口实现类的对象，就可以写一个方法getXXX（）；这个方法的返回值为该接口，在这个方法中写一个局部内部类，最后方法返回时创建一个局部内部类的对象。这时我们在外部调用这个方法时就可以得到接口的实现类的对象了，而且我们不会看到实现类的名字，这样就完成了封装。（注意局部内部类不能用private、protected和public修饰，因为这时我们只是要在该局部代码块可见，不需要对外部开放可视权限）</p>
<p>   6.4   java异常类：</p>
<p>                概念：java把异常当做对象来处理，并定义了一个基类java.lang.Throwable作为所有异常的超类。它有两个子类Error和Exception，分别表示错误和异常。</p>
<p>                          Error 是程序无法处理的错误，如：outofmemoryError、threaddeath等</p>
<p>                          Exception分为：RuntimeException    常见的NullPointerException、IndexOutOfBoundsException</p>
<p>                                                     非运行时异常：只那些不处理程序就没有办法编译通过  常见的IOException、SQLException,以及用户自定义异常。</p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记7--IO流</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B07--IO%E6%B5%81/</url>
    <content><![CDATA[<p>Java笔记7–IO流</p>
<p>2016年1月20日</p>
<p>14:59</p>
<p>7    IO流</p>
<p>    7.1  标准设备输入/输出</p>
<p>            标准输出：System.out.println();</p>
<p>                    System是java的系统类，它包含了许多的静态方法和变量。</p>
<p>                            System的常用功能：</p>
<p>                                    标准输入 输出和错误输出流、</p>
<p>                                    对外部定义的属性和环境变量的访问、</p>
<p>                                    加载文件和库、快速复制数组、</p>
<p>                                    取得系统时间即System.currentTimeMillis();  </p>
<p>                                    系统推出命令：System.exit();</p>
<p>                            System的3个静态成员变量：</p>
<p>                                    out 标准输出流–输出消息到控制台</p>
<p>                                    err  标准错误输出</p>
<p>                                    in    接收键盘输入</p>
<p> </p>
<p>        7.2  文件操作类File</p>
<p>                file类的操作对象分为两类：目录和文件</p>
<p>                file的常见操作：</p>
<p>                        </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55</td>
<td>package com.firefly.javatest.io;<br> <br>import java.io.File;<br>import java.io.IOException;<br> <br>public class FileTest {<br> <br>    public static void main(String[] args) {<br>        //创建file对象的四种方法———————–<br>        //方案一    File(String pathname)<br>        File path = new File(“D:/IoTest”);<br>        File file1 = new File(“D:/IoTest/test1.txt”);<br>        //方案二   File(String parent,String child)<br>        File file2 = new File(“D:/IoTest”,”test2.txt”);<br>        //方案三   File(URI uri)<br>        File file3 = new File(“file://D:/IoTest/test3.txt”);<br>        //方案四   File(File parent,String child)<br>        File file4 = new File(path,”test4.txt”);<br> <br>        //———————————–<br> <br> <br>        //检查路径是文件还是目录<br>        System.out.println(“路径是否为文件：”+path.isFile());<br>        System.out.println(“路径是否为文件夹：”+path.isDirectory());<br>        //检查文件或目录是否存在<br>        System.out.println(“路径是否存在：”+path.exists());<br>        if(!path.exists()){ // judge the path is exists<br>            path.mkdir();   //  创建已存在的目录下的一个子目录<br>            path.mkdirs();  //  创建所有的子目录<br>        }<br> <br>        System.out.println(“文件是否存在：”+file1.exists());<br>        if(!file1.exists()){ //如果文件不存在，则创建文件，这个地方要抛出一个异常<br>            try {<br>                file1.createNewFile();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br>        }<br> <br>        //查看目录下的文件<br>        File[] arrayFile = path.listFiles();<br>        for(File f : arrayFile){<br>            System.out.println(f);<br>        }<br> <br>        //重命名文件   renameTo(File file)<br>        if(file1.isFile()){<br>            file1.renameTo(file2);<br>        }<br>    }<br> <br>}</td>
</tr>
</tbody></table>
<p>            7.3  文件搜索类FileFilter与FilenameFilter</p>
<p>                    概述：这是两个接口，我们通过实现这两个接口中的一个便可以完成对文件的搜索，他们的区别是，FileFilter能允许我们对文件对象进行操作，即我们得到的本身是一个文件对象，我们在传的参数是一个对象；而在FilenameFilter中我们得到的是文件目录和文件名，我们传的参数是一个String。</p>
<p>            7.4  文件随机读写类RandomAccessFile                            </p>
<p> </p>
<p> </p>
<p>            7.5  输入输出流</p>
<p>                    概述：流是数据的有序排列，java的输入输出有4个关键父类，一下会详细说明，前两个是对byte数据进行操作，后两个是对character数据进行操作。</p>
<p>                    java IO最关键的4个父类为：</p>
<p>                            InputStream（输入字节流）</p>
<p>                                    常见的子类：FileInputStream</p>
<p>                                                         StringBufferInputStream</p>
<p>                                                         BufferedInputStream</p>
<p>                            OutputStream（输出字节流）</p>
<p>                            Reader（输入字符流）</p>
<p>                            Writer（输出字符流）</p>
<p>                    </p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记8--常见的实体类</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B08--%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E4%BD%93%E7%B1%BB/</url>
    <content><![CDATA[<p>Java笔记8–常见的实体类</p>
<p>2016年1月20日</p>
<p>15:01</p>
<p>8    常见的实体类</p>
<p>        8.1  系统类 System</p>
<p>                它的重要功能：</p>
<p>                    1.访问系统属性：系统属性是系统固有的属性，是在操作系统安装和软件安装后就已存在的属性。</p>
<p>                                两种方法获取系统属性，方法一：使用System.getProperties（）函数取得一个Properties对象，该对象包含了所有的系统属性的键值对。</p>
<p>                                                                      方法二：直接使用System.getProperties（key）来取得对应的属性。如果我们输入的键不存在，则返回一个null。</p>
<p>                                当我们查询的键不存在时我们可以直接通过System.getProperties(key,value);来给这个键赋值。我们也可以通过System.setProperties(key,value);来设置一个属性。</p>
<p>                                我们也可以移除一个指定键的系统属性：System.clearProperty(key);    (通常我们只查询而不做修改和删除操作）</p>
<p>                    2.访问环境变量</p>
<p>                                环境变量分为两类：系统变量和用户变量</p>
<p>                                两种访问环境变量的方法：</p>
<p>                                        方法一：使用System.getenv()函数将取得一个Map对象，该对象包含了所有环境变量的键值对。</p>
<p>                                        方法二：使用System.getenv(key)直接取得该键的值。</p>
<p>                    3.加载文件和库</p>
<p>                    4.快速复制数组</p>
<p>                            void arraycopy(数组源，源数组中的起始位置，目标数组，目标数组中的起始位置，要复制的数组元素的数量）；</p>
<p>                            不得不说在这个方法中有很多的冗余的属性，比如，你给的两个数组的类型同，那它们明显是没有办法相互复制的；又比如，让你给数组的形参你偏要给他一个非数组的实参，那它也是没有办法干活的；还比如，让你给位置参数的时候你给个负数，它就崩溃了。</p>
<p>                    5.取得系统时间</p>
<p>                            System.currenTimeMillis();该函数返回一个当前系统时间，是一个long类型的数据，精确到毫秒。</p>
<p>                            当我们想要计算一些代码执行的时间的时候，也可以用上面的函数获得两个时间来计算；此外我们还有一种更为精确的计算方法，System.nanoTime()将返回毫微秒级的精确度。</p>
<p>                    6.系统推出命令</p>
<p>                            System.exit(int status)用来终止当前正在运行的java虚拟机，status用做状态码，根据惯例，非0的状态码表示异常终止。</p>
<p>                            简单的应用方法为，我们在系统不正常运行时在控制台中输入数据，通过输入流转换后被代码块识别，通过预先的设置，完成终止虚拟机运行的目的。</p>
<p>    </p>
<p>                    7.执行垃圾回收</p>
<p>                            System.gc();调用gc（）方法暗示虚拟机做一些努力来对未回收的对象进行回收，这个地方很麻烦，并不是我们调用这个方法后虚拟机就会立即执行回收，但是我们有不能频繁的在一个程序中调用这个方法，因为虚拟机会作出反应，而每一次垃圾回收都会消耗大量的系统资源。只有当我们在短时间内创建了大量的对象，占用了太多的资源时，才合适调用这个函数。</p>
<p>                                        </p>
<p>            8.2  运行时类 Runtime</p>
<p>                    其实，上面的System类的许多函数都等价于Runtime.getRuntime,实际上System是依赖于Runtime类的。</p>
<p>                    Runtime类不同于System类，它的函数大部分都不是静态的，只有一个静态函数getRuntime().没一个java应用程序都有一个Runtime的实例，应用程序不能创建自己的Runtime类实例。</p>
<p>                    1.查看系统内存(查看当前运行的虚拟机）</p>
<p>                            long freeMemory();        空闲内存量</p>
<p>                            long maxMemory();        虚拟机试图使用的最大内存量</p>
<p>                            long totalMemory();        内存总量</p>
<p>                    2.终止虚拟机</p>
<p>                            Runtime.getRuntime().exit(n);</p>
<p>                            Runtime.getRuntime().halt(int status);   强行终止当前正在运行的java虚拟机；与上一个方法不同的地方是，这个方法属于是强制性的不安全的，不管其他因素的终止，只在迫不得已的情况下使用。</p>
<p>                    3.运行系统程序</p>
<p>                            Runtime.getRuntime().exec(“notepad”);    打开记事本</p>
<p>                    4.关闭钩子（没明白是干个啥）</p>
<p>        </p>
<p>        8.3   java字符串处理类</p>
<p>                    String字符串类：String字符串是常量，他们的值在创建之后不能更改。</p>
<p>                            String的方法：</p>
<p>                                    1.提取单个字符串：    char charAt( int index);        //index从0开始，放回指定索引处的char值</p>
<p>                                    2.提取子字符串：    String substring(int beginIndex);    String substring(int beginIndex, int endIndex);        //注意endIndex不能越界</p>
<p>                                    3.比较字符串：    boolean equals（Object anObject）；    </p>
<p>                                                                boolean equalsIgnoreCase(String Str);        //忽略大小写</p>
<p>                                                                int compareTo(String anotherString);</p>
<p>                                                                int compareToIgnoreCase(String str);        //按字典大小比较两个字符串的大小，没有明白到底是干啥的</p>
<p>                                    4.定位字符串</p>
<p>                                            int indexOf(char c);        //返回c在字符串中的位置，不包含则返回-1，也可以是String字符串</p>
<p>                                            int lastIndexOf(char c);        //返回c在字符串中最后一次出现的位置</p>
<p>                                    5.拆分字符串</p>
<p>                                            String[] split(String regex);        //根据给定的正则表达式的匹配拆分字符串，返回一个字符串数组</p>
<p>                                    6.替换字符串</p>
<p>                                            String replace(String oldString,String newString);</p>
<p>                                    7.转化大小写</p>
<p>                                            String toLowerCase();</p>
<p>                                            String toUpperCase();</p>
<p>                                    8.格式化输出</p>
<p>                                            str  = String.format(“%1$tY年%1$tm月”,new Date());    //格式化输出时间，这个方法是静态的</p>
<p>                字符串分隔类StringTokenizer（出于兼容性的原因而被保留的遗留类，不鼓励使用，建议使用split()方法）</p>
<p>                线程安全的可变字符串类StringBuffer</p>
<p>                可变的字符串StringBuilder(它与StringBuffer类似，只是不是线程安全的，当我们不需要把字符串用于多线程时，使用它的效率要高于StringBuffer）</p>
<p>        8.4  java日期处理类</p>
<p>                日期类Date</p>
<p>                        日期转换成字符串：String format(Date date);</p>
<p>                        字符串转换成日常：Date parse(String source);</p>
<p>                日历类Calender</p>
<p>                      </p>
<p>        8.5  数字处理类</p>
<p>                数学函数类Math</p>
<p>                        绝对值函数：static int abs(int a);        //也可以是为Double 、float、long取绝对值</p>
<p>                        最大最小值函数：static int max(int a,int b);</p>
<p>                                                    static int min(int a,int b);    //也可以是为Double 、float、long比较</p>
<p>                        取整函数、弦与切函数、幂与开方函数、对数函数、角度函数、随机函数、</p>
<p>        8.6  随机数类Random</p>
<p>                                </p>
<p>         </p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。    </p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- Java笔记9--正则表达式</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/Java%E7%AC%94%E8%AE%B09--%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>Java笔记9–正则表达式</p>
<p>2016年1月20日</p>
<p>15:33</p>
<p>正则表达式（regular expression）：描述一种字符串匹配的语法规则</p>
<p>语法：有一系列的匹配字符、通过各种匹配规则组成，其核心就是匹配字符和匹配规则。</p>
<p>起源：有两位神经生理学家研究出一种数学方式来描述神经网络的–神经时间的表示法，其中一个”正则集的代数“的表达式，采用了”正则表达式“这个术语。</p>
<p> </p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>基础 -- java笔记12--设计模式</title>
    <url>/2023/04/13/java/%E5%9F%BA%E7%A1%80/java%E7%AC%94%E8%AE%B012--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ol>
<li><p>设计模式概述：前人总结的一些解决问题的思想，设计模式不是技术而是思想；</p>
</li>
<li><p>23种设计模式：</p>
</li>
<li><p>创建型模式：</p>
</li>
<li><p>工厂方法</p>
</li>
<li><p>单例 ：设计模式–单例.note</p>
</li>
<li><p>抽象工厂、建造者、原型</p>
</li>
<li><p>结构型模式：</p>
</li>
<li><p>适配器</p>
</li>
<li><p>装饰器</p>
</li>
<li><p>代理 ：设计模式–代理.note</p>
</li>
<li><p>桥接、组合、外观、享元</p>
</li>
<li><p>行为型模式：责任链接、命令、解释器、迭代、中介者、备忘录、观察者、状态、策略、模板方法、访问者</p>
</li>
</ol>
<p>参考<a href="https://www.cnblogs.com/magee-khl/p/7491813.html">https://www.cnblogs.com/magee-khl/p/7491813.html</a></p>
]]></content>
      <categories>
        <category>java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架 -- ArrayList</title>
    <url>/2023/04/13/java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>底层封装了一个Object[]，长度可变，如果未指定长度默认为10，当新增的元素没有空间存放的时候，扩容为原本的1.5倍，线程不安全;</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><pre><code>ArrayList(int initialCapacity);
ArrayList(); 
ArrayList(Collection&lt;? extends E&gt; c);
</code></pre>
<p>三种方式进行初始化，第二种一开始是创建的空数组在添加元素的时候才会初始化为长度10</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>两种扩容方法，上面构造方法中说了一种，第二种在add方法中，判断数组长度不足调用grow方法进行扩容，在newCapacity方法中，会将数组长度扩展1.5倍，然后将老数组复制过来</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>从源码上可以看到增减操作都没有做任何安全性限制</p>
<p>那么如何实现线程安全呢：</p>
<ul>
<li>  通过synchronized关键字</li>
<li>  创建ArrayList对象的时候采用Collections类中的静态方法synchronizedList(new ArrayList&lt;&gt;())，推荐使用这个</li>
<li>  还有一个叫Vector线程安全类，不过已经不怎么使用了，11里面已经找不到了</li>
</ul>
<h2 id="ConcurrentModificationException异常"><a href="#ConcurrentModificationException异常" class="headerlink" title="ConcurrentModificationException异常"></a>ConcurrentModificationException异常</h2><p>ArrayList不能在迭代的过程中进行修改，不然会报ConcurrentModificationException，原因是ArrayList的修改方法中都会对modCount+1，在构建迭代器的时候将modCount传给了迭代器，next方法中进行检查modCount发生变化就会抛出异常</p>
<h2 id="Arrays-copy-和System-copy"><a href="#Arrays-copy-和System-copy" class="headerlink" title="Arrays.copy()和System.copy()"></a>Arrays.copy()和System.copy()</h2><p>前者会创建一个新的数组，后者调用了c++只进行了拷贝</p>
]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架 -- HashMap</title>
    <url>/2023/04/13/java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashMap/</url>
    <content><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>描述一下java中HashMap的实现，HashMap是用来存储键值对的，实际存储的时候通过key算出hash值，内部有一个数组将数据都存储在这个数组上，如果同一个位置有多个数据需要存储的时候用链表进行存储，链表长度达到8会转为红黑树</p>
<h2 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h2><pre><code>public class HashMap&lt;k,v&gt; extends AbstractMap&lt;k,v&gt; implements Map&lt;k,v&gt;, Cloneable, Serializable &#123;
    private static final long serialVersionUID = 362498820763181265L;
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//最大容量
    static final float DEFAULT_LOAD_FACTOR = 0.75f;//填充比
    //当add一个元素到某个位桶，其链表长度达到8时将链表转换为红黑树
    static final int TREEIFY_THRESHOLD = 8;
    static final int UNTREEIFY_THRESHOLD = 6;
    static final int MIN_TREEIFY_CAPACITY = 64;
    transient Node&lt;k,v&gt;[] table;//存储元素的数组
    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;
    transient int size;//存放元素的个数
    transient int modCount;//被修改的次数fast-fail机制
    int threshold;//临界值 当实际大小(容量*填充比)超过临界值时，会进行扩容 
    final float loadFactor;//填充比（......后面略）
&#125;
</code></pre>
<ul>
<li>  ==数据存储在table数组中，这里是Node数组，也就是自定义的链表，那要是红核数的时候怎么处理呢==</li>
<li>  有一个填充比默认为0.75，还有一个threshold临界值，这个临界值就是在初始化的时候通过数组长度和填充值计算出来的，如果数组存放的个数超过了这个临界值就会进行扩容</li>
<li>  默认的数组长度为16，且长度只能是2的倍数，扩容的时候也是翻倍，这样可以维护数据均匀分布是数组中</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>共有四种初始化的方式</p>
<h3 id="不指定任何参数"><a href="#不指定任何参数" class="headerlink" title="不指定任何参数"></a>不指定任何参数</h3><pre><code>public HashMap() &#123;                                                       
   this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted 
&#125;                                                                        
</code></pre>
<p>这个时候数组长度为16，填充因子为0.75，也就是临界值为12，从源码可以看出，这个时候其实没有做任何初始化，仅仅是将填充因子进行了赋值</p>
<h3 id="指定数组长度"><a href="#指定数组长度" class="headerlink" title="指定数组长度"></a>指定数组长度</h3><pre><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

public HashMap(int initialCapacity) &#123;          
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
&#125;                                              
    
public HashMap(int initialCapacity, float loadFactor) &#123;                     
    if (initialCapacity &lt; 0)                                                
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +   
                                           initialCapacity);                
    if (initialCapacity &gt; MAXIMUM_CAPACITY)                                 
        initialCapacity = MAXIMUM_CAPACITY;                                 
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))                         
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +        
                                           loadFactor);                     
    this.loadFactor = loadFactor;                                           
    this.threshold = tableSizeFor(initialCapacity);                         
&#125;            

static final int tableSizeFor(int cap) &#123;
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= 100) ? 100 : n + 1;
&#125;
</code></pre>
<ul>
<li>  指定了长度，填充因子还是取默认，会对指定的长度进行判断不能小于0，大于最大值会被置为最大值，==这里的最大值设定为2的30次方，不知道为啥==</li>
<li>  来看一下tableSizeFor方法，它的作用是取到比指定长度大的最小一个2的次方数（说过了数组的长度需要是2的次方），比如3就给出4，6给出8，当然如果给到的就是4那也返回4，看看是怎么实现的</li>
</ul>
<img src="https://raw.githubusercontent.com/fireflyso/Img/master/markdown/cifang.png" width="400" alt="图片名称">

<h3 id="指定长度且指定填充因子"><a href="#指定长度且指定填充因子" class="headerlink" title="指定长度且指定填充因子"></a>指定长度且指定填充因子</h3><p><code>public HashMap(int initialCapacity, float loadFactor) &#123; &#125;</code><br>这个没什么好说的，调用的构造函数上面说过了</p>
<h3 id="通过一个Map类型数据初始化"><a href="#通过一个Map类型数据初始化" class="headerlink" title="通过一个Map类型数据初始化"></a>通过一个Map类型数据初始化</h3><p>==这个以后有机会再看吧==</p>
<h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><pre><code>public V put(K key, V value) &#123;                        
    return putVal(hash(key), key, value, false, true);
&#125;                                                     

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else &#123;
        Node&lt;K,V&gt; e; K k;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else &#123;
            for (int binCount = 0; ; ++binCount) &#123;
                if ((e = p.next) == null) &#123;
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                &#125;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            &#125;
        &#125;
        if (e != null) &#123; // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        &#125;
    &#125;
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
&#125;

final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) &#123;
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    &#125;
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else &#123;               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    if (newThr == 0) &#123;
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    &#125;
    threshold = newThr;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) &#123;
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123; // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do &#123;
                        next = e.next;
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
</code></pre>
<p>这个看起来就长了，如果这个table也就是数组还没有初始化，或者长度为0，这个时候需要先扩容，也就能解释为什么构造函数中没有进行初始化了，用的时候才进行的初始化</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><h3 id="数据平衡分布在数组table上"><a href="#数据平衡分布在数组table上" class="headerlink" title="数据平衡分布在数组table上"></a>数据平衡分布在数组table上</h3><p><code>(n - 1) &amp; hash</code>需要特别注意这个处理方式，<a href="https://blog.csdn.net/hbtj_1216/article/details/76623754">参考这个帖子</a>，这个就是需要存储的数据的key的hash映射到数组中位置的处理，hash是key的hash是一个数字，n是数组长度是2的倍数，n-1是偶数二进制中所有位都为1与hash进行与操作，得到一个小于数组长度的值且不同的hash值会均匀的分布（理论上）</p>
<p>通过这个方式为存入的数据找到它在table上的位置，如果这个位置上还没有数据，那就直接初始化一个node进行存储即可</p>
<p>如果已经有了数据，那要判断一下这个节点上的key是不是我们要存入的key，如果是那就标记然后将value进行更新<br>如果不是那就要判断一下当前的节点数据是通过链表存储的还是红黑树，然后分别遍历看能否找到key进行更新，如果没有找到那就要添加一个新的节点来存储key和value，且对于链表来说还要判断一下当前链表的长度如果新增数据后长度达到了8，那就要转变为红黑树</p>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><pre><code>    public V get(Object key) &#123;
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    &#125;

    /**
     * Implements Map.get and related methods.
     *
     * @param hash hash for key
     * @param key the key
     * @return the node, or null if none
     */
    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) &#123;
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) &#123;
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do &#123;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                &#125; while ((e = e.next) != null);
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<p>get相对简单，同样通过hash映射找到table上的位置，当然没找到就返回null，找到之后先判断首节点上的数据是不是，不是的话再根据节点类型（链表或者红黑树）进行迭代查找</p>
]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架 -- HashTable</title>
    <url>/2023/04/13/java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashTable/</url>
    <content><![CDATA[<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>和HashMap相似，不过HashTable是线程安全的</p>
<h2 id="与HashMap的区别"><a href="#与HashMap的区别" class="headerlink" title="与HashMap的区别"></a>与HashMap的区别</h2><ul>
<li>  HashTable线程安全</li>
<li>  HashMap允许key和value为空，HashTable不允许保存null</li>
<li>  HashMap的迭代器是fail-fast（不允许迭代的过程中出现数据的修改），HashTable的迭代器是enumerator，允许迭代器本身的remove方法（同样不支持别的线程进行修改操作）</li>
</ul>
<h2 id="基础源码"><a href="#基础源码" class="headerlink" title="基础源码"></a>基础源码</h2><pre><code>public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;
    private transient Entry&lt;?,?&gt;[] table;  //用于存储数据的数组桶
    private transient int count;    //entry数量
    private int threshold;  //扩容阈值
    private float loadFactor;   //填充因子
    private transient int modCount = 0;
&#125;
</code></pre>
<p>相比HashMap来说HashTable就没有再定义那么多的默认值了（默认长度之类的）</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>public Hashtable() &#123;
    this(11, 0.75f);
&#125;
public Hashtable(int initialCapacity, float loadFactor) &#123;
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                           initialCapacity);
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);

    if (initialCapacity==0)
        initialCapacity = 1;
    this.loadFactor = loadFactor;
    table = new Entry&lt;?,?&gt;[initialCapacity];
    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
&#125;
</code></pre>
<ul>
<li>  如果不指定长度的话，默认的数组长度是11</li>
<li>  这里的table数组会在构造函数中就初始化</li>
<li>  这里的threshold会真正的取数组长度*填充因子</li>
</ul>
<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><pre><code>public synchronized V put(K key, V value) &#123;
    // Make sure the value is not null
    if (value == null) &#123;
        throw new NullPointerException();
    &#125;

    // Makes sure the key is not already in the hashtable.
    Entry&lt;?,?&gt; tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    @SuppressWarnings(&quot;unchecked&quot;)
    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];
    for(; entry != null ; entry = entry.next) &#123;
        if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;
            V old = entry.value;
            entry.value = value;
            return old;
        &#125;
    &#125;

    addEntry(hash, key, value, index);
    return null;
&#125;

private void addEntry(int hash, K key, V value, int index) &#123;
    modCount++;

    Entry&lt;?,?&gt; tab[] = table;
    if (count &gt;= threshold) &#123;
        // Rehash the table if the threshold is exceeded
        rehash();

        tab = table;
        hash = key.hashCode();
        index = (hash &amp; 0x7FFFFFFF) % tab.length;
    &#125;

    // Creates the new entry.
    @SuppressWarnings(&quot;unchecked&quot;)
    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];
    tab[index] = new Entry&lt;&gt;(hash, key, value, e);
    count++;
&#125;
</code></pre>
<ul>
<li>  这里的put方法用synchronized进行了修饰以确保线程安全</li>
<li>  对数据进行数组桶位映射使用的方法是<code>(hash &amp; 0x7FFFFFFF) % tab.length</code>和HashMap不同，这里的hash是直接算出来的hash值，而HashMap的hash还进过了特殊处理，这里<code>hash &amp; 0x7FFFFFFF</code>是如果hash为负转为正数，然后对table长度取模， <a href="https://blog.csdn.net/zhoucheng05_13/article/details/79815803">两种方式的特点</a>，简单的说位运算销量比数学运算效率高，HashMap的优化度更高</li>
<li>  HashTable看起来没有使用红黑树而只有链表的方式</li>
<li>  如果key已存在则进行更新，如果key不存在则插入新的数据（entry），且每次插入一个entry的时候count累加1，当count数量大于阈值的时候进行刷新（扩容）</li>
</ul>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><pre><code>protected void rehash() &#123;
    int oldCapacity = table.length;
    Entry&lt;?,?&gt;[] oldMap = table;

    // overflow-conscious code
    int newCapacity = (oldCapacity &lt;&lt; 1) + 1;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;
        if (oldCapacity == MAX_ARRAY_SIZE)
            // Keep running with MAX_ARRAY_SIZE buckets
            return;
        newCapacity = MAX_ARRAY_SIZE;
    &#125;
    Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];

    modCount++;
    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
    table = newMap;

    for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;
        for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;
            Entry&lt;K,V&gt; e = old;
            old = old.next;

            int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;
            e.next = (Entry&lt;K,V&gt;)newMap[index];
            newMap[index] = e;
        &#125;
    &#125;
&#125;
</code></pre>
<p>这个很简单，判断一下扩容后的大小不能超过最大长度（具体控制条件看一下上面代码就行），扩展数组长度后将数据重新通过映射算法进行分发（数组长度边了，映射到的位置也就发生了变化）</p>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><pre><code>public synchronized V get(Object key) &#123;
    Entry&lt;?,?&gt; tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;
            return (V)e.value;
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p>get方法就很简单了，直接进行遍历</p>
]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架 -- LinkedHashMap</title>
    <url>/2023/04/13/java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedHashMap/</url>
    <content><![CDATA[<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p>继承自HashMap，加上了链表的结构来实现顺序迭代，有两种迭代顺序，一种是按照数据插入的顺序，一种是按照数据访问的顺序</p>
<h2 id="基础源码"><a href="#基础源码" class="headerlink" title="基础源码"></a>基础源码</h2><pre><code>public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;
    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;
        Entry&lt;K,V&gt; before, after;
        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
            super(hash, key, value, next);
        &#125;
    &#125;
    
    transient LinkedHashMap.Entry&lt;K,V&gt; head;
    transient LinkedHashMap.Entry&lt;K,V&gt; tail;
    final boolean accessOrder;  //true 访问顺序遍历，false 插入顺序遍历（默认）
</code></pre>
<p>继承了HashMap，Entry类中添加了before和after对象</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code>public LinkedHashMap() &#123;
    super();
    accessOrder = false;
&#125;
public LinkedHashMap(int initialCapacity) &#123;
    super(initialCapacity);
    accessOrder = false;
&#125;
public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123;
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
&#125;
public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
    super();
    accessOrder = false;
    putMapEntries(m, false);
&#125;
</code></pre>
<p>调用了HashMap的构造函数，给accessOrder赋值</p>
<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><pre><code>public V put(K key, V value) &#123;                                           
    return putVal(hash(key), key, value, false, true);                   
&#125;       

Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;
    LinkedHashMap.Entry&lt;K,V&gt; p =
        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    linkNodeLast(p);
    return p;
&#125;

private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;
    LinkedHashMap.Entry&lt;K,V&gt; last = tail;
    tail = p;
    if (last == null)
        head = p;
    else &#123;
        p.before = last;
        last.after = p;
    &#125;
&#125;

void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    if (accessOrder &amp;&amp; (last = tail) != e) &#123;
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        p.after = null;
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
        else
            last = b;
        if (last == null)
            head = p;
        else &#123;
            p.before = last;
            last.after = p;
        &#125;
        tail = p;
        ++modCount;
    &#125;
&#125;

void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;
        K key = first.key;
        removeNode(hash(key), key, null, false, true);
    &#125;
&#125;

protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;
    return false;
&#125;
</code></pre>
<p>直接调用了HashMap的put方法，但是HashMap的put方法中留出了afterNodeAccess和afterNodeInsertion方法</p>
<h3 id="newNode方法"><a href="#newNode方法" class="headerlink" title="newNode方法"></a>newNode方法</h3><p>重写了newNode方法，维护了一个双向链表，可以用来记录数据插入的顺序</p>
<h3 id="afterNodeInsertion方法"><a href="#afterNodeInsertion方法" class="headerlink" title="afterNodeInsertion方法"></a>afterNodeInsertion方法</h3><p>这个方法里面只是做一个判断，默认removeEldestEntry返回false，如果是通过改变accessOrder来实现LRUcatch的时候将返回值改为true，可以实现数据超过缓存阈值时对最老的数据进行删除</p>
<h3 id="afterNodeAccess方法"><a href="#afterNodeAccess方法" class="headerlink" title="afterNodeAccess方法"></a>afterNodeAccess方法</h3><p>accessOrder被设置为true，也就是按照访问顺序进行迭代的时候，会将被修改的元素放到链表的尾部</p>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><pre><code>    public V get(Object key) &#123;
        Node&lt;K,V&gt; e;
        if ((e = getNode(hash(key), key)) == null)
            return null;
        if (accessOrder)
            afterNodeAccess(e);
        return e.value;
    &#125;
</code></pre>
<p>获取数据调用父类方法，只是之后根据accessOrder判断是否需要去对链表结构进行修改，同时由于afterNodeAccess中修改了modCount值，所以在迭代的时候进行get操作也会报异常</p>
<h2 id="LinkedHashIterator"><a href="#LinkedHashIterator" class="headerlink" title="LinkedHashIterator"></a>LinkedHashIterator</h2><pre><code>abstract class LinkedHashIterator &#123;
    LinkedHashMap.Entry&lt;K,V&gt; next;
    LinkedHashMap.Entry&lt;K,V&gt; current;
    int expectedModCount;

    LinkedHashIterator() &#123;
        next = head;
        expectedModCount = modCount;
        current = null;
    &#125;

    public final boolean hasNext() &#123;
        return next != null;
    &#125;

    final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;
        LinkedHashMap.Entry&lt;K,V&gt; e = next;
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        if (e == null)
            throw new NoSuchElementException();
        current = e;
        next = e.after;
        return e;
    &#125;

    public final void remove() &#123;
        Node&lt;K,V&gt; p = current;
        if (p == null)
            throw new IllegalStateException();
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        current = null;
        K key = p.key;
        removeNode(hash(key), key, null, false, false);
        expectedModCount = modCount;
    &#125;
&#125;
</code></pre>
<p>重写了迭代器，迭代的是内部维护的双向链表</p>
]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架 -- 集合框架</title>
    <url>/2023/04/13/java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>最基本的集合接口；有一个帮助类叫做Collections用于表示任何对象或元素组，想要尽可能以常规方式处理一组元素时，就使用这一类，实际上使用很少；</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>实现了collection接口，list其实就是数组，允许重复元素，通过角标可以直接定位元素</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>是个双向链表，所以可以当做队列和栈来使用，线程不安全</p>
<p>需要取出指定位置的数据的时候有一个加速机制，判断一下index和size一半的大小，也就是搞清楚是在前半段还是后半段，然后决定从头遍历还是从尾部遍历</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li><p>Array（数组）和ArrayLish的异同点</p>
<ul>
<li>  ArrayList可以看成是一个增强的Array一个动态的数组</li>
<li>  数组在定义的时候就要确定长度，ArrayList确可以动态的增长</li>
<li>  数组里面只能存储同一类型的数据，ArrayList可以存储不同的对象</li>
<li>  数组可以存储基本类型和引用类型，ArrayList只能存储引用类型</li>
</ul>
</li>
<li><p>  内存分配的机制：基于数组，当内存不够用的时候会去重新申请一片两倍于现在的内存空间，并将所有元素复制到新的内存中</p>
</li>
</ul>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>可以近似的认为是一个线程安全的ArrayList，效率偏低；属于是Java遗留的一个容器，已经不推荐使用了，多线程情况下，可以通过工具类 Collections 中的 synchronizedList 方法将ArrayList和Linkedlist转换成线程安全的容器后再使用</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>实现了collection接口，不允许集合中存在重复项，依赖对象的equal方法来检查独一性；它没有引入新方法；所以它其实就是一个Collection，只不过其行为不同</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>无序存储不重复自由集合，可以允许存在一个null值，底层直接就是用了HashMap对象，只是HashSet由于不是键值对，所以默认给出一个Object对象（常量）做为value</p>
<p>这里并没有提供构造函数给HashSet去指定HashMap的填充因子，因为该构造函数被linkedHashSet使用了，这一点很奇怪</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>使用二叉树结构，有序存取元素，因此添加到treeset中的元素必须是可排序的，在元素添加的时候它就会自动按照某种规则（取决于元素类型）排好了顺序</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>以双向链表的方式扩展了HashSet，实现元素按照插入的顺序来进行访问；继承了HashSet，但本质是使用了一个LinkedHashMap，且与HashSet相同将value置为一个常量；其添加和查找方法都是直接使用了LinkedHashMap的方法</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>没有实现collection接口；它用于维护键值对；键和值都允许为null，但是只能有一个键为null，且不能把map作为一个键或者值添加给自己</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>便于在map中插入、删除和定位元素，访问速度最快，最常用；<a href="https://blog.csdn.net/justloveyou_/article/details/62893086">详解</a></p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>线程安全的HashMap</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>需要按照自然的顺序或自定义顺序遍历map时使用，所以遍历时得到的是有序的结果；</p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>也是为了以插入的顺序遍历map，也双向链表结构；</p>
<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1>]]></content>
      <categories>
        <category>java</category>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Django -- Django ORM</title>
    <url>/2023/04/13/python/Django/Django%20ORM/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="Django自带ORM的语法"><a href="#Django自带ORM的语法" class="headerlink" title="Django自带ORM的语法"></a>Django自带ORM的语法</h1><h2 id="交互模式进入方式"><a href="#交互模式进入方式" class="headerlink" title="交互模式进入方式"></a>交互模式进入方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自动</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;resop.settings_firefly&quot;</span>)</span><br><span class="line"><span class="keyword">from</span> django.core.wsgi <span class="keyword">import</span> get_wsgi_application</span><br><span class="line">application = get_wsgi_application()</span><br><span class="line"><span class="keyword">from</span> orm.cloud.models <span class="keyword">import</span> GIC</span><br></pre></td></tr></table></figure>

<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">query_sql = Q(is_valid=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> route_id:</span><br><span class="line">    query_sql &amp;= Q(route_id=route_id)</span><br><span class="line"><span class="keyword">if</span> site_id:</span><br><span class="line">    query_sql &amp;= Q(vrrp__site_id=site_id)</span><br><span class="line">vrrp_info_list = VpcVrrpResource.objects.<span class="built_in">filter</span>(query_sql).select_related(</span><br><span class="line">    <span class="string">&quot;vrrp&quot;</span>, <span class="string">&quot;route&quot;</span>, <span class="string">&quot;vrrp__available_zone&quot;</span></span><br><span class="line">).values(</span><br><span class="line">    <span class="string">&#x27;vrrp__available_zone__site_name&#x27;</span>, <span class="string">&#x27;route__route_name&#x27;</span>, <span class="string">&#x27;vrrp__name&#x27;</span>, <span class="string">&#x27;vrrp__pubnet_status&#x27;</span>, <span class="string">&#x27;vrrp__subnet_status&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;vrrp__id&#x27;</span>, <span class="string">&#x27;route__route_id&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">------ <span class="comment"># values和values_list方法区别 ------</span></span><br><span class="line"><span class="comment"># values 结果为字典型</span></span><br><span class="line">books = Book.objects.<span class="built_in">filter</span>(id__lt=<span class="number">6</span>).values(<span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">[&#123;<span class="string">&#x27;number&#x27;</span>: <span class="string">&#x27;1&#x27;</span>&#125;, &#123;<span class="string">&#x27;number&#x27;</span>: <span class="string">&#x27;2&#x27;</span>&#125;, &#123;<span class="string">&#x27;number&#x27;</span>: <span class="string">&#x27;3&#x27;</span>&#125;, &#123;<span class="string">&#x27;number&#x27;</span>: <span class="string">&#x27;4&#x27;</span>&#125;, &#123;<span class="string">&#x27;number&#x27;</span>: <span class="string">&#x27;5&#x27;</span>&#125;]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># values_list 结果为元祖型</span></span><br><span class="line">books = Book.objects.values_list(<span class="string">&#x27;number&#x27;</span>)</span><br><span class="line">[(<span class="string">&#x27;1&#x27;</span>,), (<span class="string">&#x27;2&#x27;</span>,), (<span class="string">&#x27;3&#x27;</span>,), (<span class="string">&#x27;4&#x27;</span>,), (<span class="string">&#x27;5&#x27;</span>,)]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获取某个字段所有值2</span></span><br><span class="line">books = Book.objects.values_list(<span class="string">&#x27;number&#x27;</span>, flat=<span class="literal">True</span>)</span><br><span class="line">books = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">VpcVrrpResource.objects.<span class="built_in">filter</span>(query_sql).order_by(<span class="string">&#x27;-create_time&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in</span></span><br><span class="line">id_list  = []</span><br><span class="line">VpcVrrpResource.objects.<span class="built_in">filter</span>(id__in=id_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">Customer.objects.<span class="built_in">filter</span>(Q(id__contains=keyword) | Q(name__contains=keyword))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排除</span></span><br><span class="line">query_sql = Q(cds_product_id__in=[<span class="string">&#x27;peering&#x27;</span>, <span class="string">&#x27;&#x27;</span>]) | Q(cds_product_id__isnull=<span class="literal">True</span>)</span><br><span class="line">pro_attrs = ProAttrConfSite.objects.<span class="built_in">filter</span>(site_id=site_id, is_valid=<span class="number">1</span>).exclude(query_sql)</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vrrp = VpcVrrpResource(</span><br><span class="line">    <span class="built_in">id</span>=<span class="number">1</span>,</span><br><span class="line">    name=<span class="string">&#x27;vrrp&#x27;</span></span><br><span class="line">)</span><br><span class="line">vrrp.save   </span><br><span class="line">VpcVrrpResource.objects.create(vrrp)</span><br><span class="line">VpcVrrpResource.objects.bulk_create([vrrp])</span><br><span class="line"></span><br><span class="line">vrrp = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;vrrp&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">VpcVrrpResource.objects.create(**vrrp)</span><br><span class="line">VpcVrrpResource.objects.bulk_create([VpcVrrpResource(**vrrp)])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GlobalAccelerator.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=ga_id).update(status=<span class="string">&#x27;ok&#x27;</span>, max_connection=connections)</span><br></pre></td></tr></table></figure>

<h2 id="生成model文件"><a href="#生成model文件" class="headerlink" title="生成model文件"></a>生成model文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!--到wan_server项目下操作--&gt;</span><br><span class="line">python3 manage.py inspectdb --database automatic_product vpc_vrrp</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@transaction.atomic()</span></span><br><span class="line"><span class="meta">@transaction.atomic(<span class="params">using=<span class="string">&#x27;cluster&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@transaction.atomic(<span class="params">using=<span class="string">&#x27;adn&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_to_db</span>(<span class="params">request, data_dir</span>):</span><br><span class="line">    &lt;!--这里进行数据库读写，出现异常时三个库的事务都会回滚--&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    save_to_db(request, data_dir)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><h1 id="执行原生SQL"><a href="#执行原生SQL" class="headerlink" title="执行原生SQL"></a>执行原生SQL</h1><h2 id="cursor方式"><a href="#cursor方式" class="headerlink" title="cursor方式"></a>cursor方式</h2><p>这种方式类似于pymysql，比较原始，在结果为count这样的函数放回值时使用较为合适</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line">cursor = connection.cursor()</span><br><span class="line">query_sql = <span class="string">&quot;select count(*) from automatic_product.subinterface where is_alloc = 1 and site_id = &#x27;&#123;&#125;&#x27; and app_id is not null and status = &#x27;ok&#x27;&quot;</span>.<span class="built_in">format</span>(site.<span class="built_in">id</span>)</span><br><span class="line">cursor.execute(query_sql)</span><br><span class="line">used_count = cursor.fetchall()</span><br></pre></td></tr></table></figure>

<h3 id="指定数据库"><a href="#指定数据库" class="headerlink" title="指定数据库"></a>指定数据库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connections</span><br><span class="line"><span class="keyword">with</span> connections[<span class="string">&#x27;wan_fping&#x27;</span>].cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    query_sql = <span class="string">&quot;select count(*) from product_vm;&quot;</span></span><br><span class="line">    cursor.execute(query_sql)</span><br><span class="line">    cursor.fetchall()</span><br></pre></td></tr></table></figure>

<h2 id="raw方式"><a href="#raw方式" class="headerlink" title="raw方式"></a>raw方式</h2><p>这种方式会将sql查询出来的数据注入到模型类中，比较方便</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">query_sql = <span class="string">&quot;select * from automatic_product.subinterface&quot;</span></span><br><span class="line">data_list = Subinterface.objects.raw(query_sql)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- MRO</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/MRO/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def method(self):</span><br><span class="line">        print(&quot;CommonA&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def method(self):</span><br><span class="line">        print(&quot;CommonC&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class D(B, C):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;test : &#123;&#125;&quot;.format(D().method()))</span><br><span class="line"># python2输出</span><br><span class="line">CommonA</span><br><span class="line">test : None</span><br><span class="line"></span><br><span class="line"># python3输出</span><br><span class="line">CommonC</span><br><span class="line">test : None</span><br><span class="line"></span><br><span class="line">import inspect</span><br><span class="line">inspect.getmro(D)</span><br><span class="line"># python2需要inspect模块</span><br><span class="line">(&lt;class __main__.D at 0x101ebab48&gt;, &lt;class __main__.B at 0x101ebaa78&gt;, &lt;class __main__.A at 0x101ebaa10&gt;, &lt;class __main__.C at 0x101ebaae0&gt;)</span><br><span class="line"></span><br><span class="line">print(D.__mro__)</span><br><span class="line"># python3输出</span><br><span class="line">(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br></pre></td></tr></table></figure>
<ul>
<li>python作为一个多继承的语言，方法解析顺序就变得复杂了</li>
<li>python一共提供过三个版本的MRO<ul>
<li>第一种MRO：深度遍历，也就是python2输出的结果<code>D-&gt;B-&gt;A-&gt;C-&gt;A</code></li>
<li>第二种MRO：在第一版的基础上重复出现的类只会保留最后一个<code>D-&gt;B-&gt;C-&gt;A</code>，核心的逻辑是，既然C是A的子类那么C中重写的方法自然优先级应该高于A中的基础方法，也就是子类优先级高于父类</li>
<li>第三种MRO：第二种MRO思想是对的，但是存在问题，看下面的案例</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(X, Y):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(Y, X):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(A, B):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(C.__mro__)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">TypeError: Cannot create a consistent method resolution</span><br><span class="line">order (MRO) <span class="keyword">for</span> bases X, Y</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用第二种MRO<ul>
<li>对于 A，其搜索顺序为 <code>A-&gt;X-&gt;Y-&gt;object</code></li>
<li>对于 B，其搜索顺序为 <code>B-&gt;Y-&gt;X-&gt;object</code></li>
<li>对于 C，其搜索顺序为 <code>C-&gt;A-&gt;B-&gt;X-&gt;Y-&gt;object</code></li>
<li>对于B和C中对XY的解析顺序出现了冲突，违反了单调性</li>
</ul>
</li>
<li>第三种MRO的算法还挺复杂的，但目前python就是使用第三种MRO，也不用去记，基本还是通过第二种来做大致的判断即可，对于第二种会出现冲突的情况，第三版的MRO会报错</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 函数特性</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="函数作为对象使用"><a href="#函数作为对象使用" class="headerlink" title="函数作为对象使用"></a>函数作为对象使用</h1><ul>
<li>python中一切皆为对象，函数也是对象，有很多离谱操作</li>
<li>赋值给变量</li>
<li>作为另一个函数的实参</li>
<li>作为函数的返回值</li>
<li>嵌套定义值另一个函数中</li>
</ul>
<h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def add(num1, num2):</span><br><span class="line">    return num1 + num2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add(1, 2))</span><br><span class="line"></span><br><span class="line">print((lambda num1, num2: num1 + num2)(1, 2))</span><br><span class="line"></span><br><span class="line">le = lambda num1, num2: num1 + num2</span><br><span class="line">print(le(1, 2))</span><br><span class="line"></span><br><span class="line">result = map(lambda x: x * x, [1, 2, 3, 4])</span><br><span class="line">print(list(result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def do_sth():</span><br><span class="line">    return lambda num1, num2: num1 + num2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(do_sth()(1, 2))</span><br></pre></td></tr></table></figure>
<ul>
<li>相当于是一个匿名函数，同样是一个对象，也可以像函数那样用</li>
</ul>
<h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f(a, b=5):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f_new = partial(f, 2)</span><br><span class="line"></span><br><span class="line">f_new()</span><br><span class="line">f_new(6)</span><br><span class="line">f_new(b=6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># f_new(a = 3)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def eval_sum(*args):</span><br><span class="line">    s = 0</span><br><span class="line">    for n in args:</span><br><span class="line">        s += n</span><br><span class="line">    return s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eval_sum_new = partial(eval_sum, 20, 30)</span><br><span class="line">print(eval_sum_new(1, 2, 3, 4, 5))</span><br><span class="line"></span><br><span class="line">def f1(a, b=5, *args, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;args =&#x27;, args, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1_new = partial(f1, 1, 3, 6, m=8)</span><br><span class="line">f1_new(2, 4, n=9)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def f2(a, b=5, *, c, **kwargs):</span><br><span class="line">    print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;kwargs =&#x27;, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f2_new = partial(f2, 1, m=8)</span><br><span class="line">f2_new(3, c=9)</span><br></pre></td></tr></table></figure>
<ul>
<li>python可以为函数指定默认参数</li>
<li>一个函数定义的时候没有指定默认值，但后续使用的时候想给其指定，可以使用偏函数来实现</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def outer():</span><br><span class="line">    a = 10</span><br><span class="line"></span><br><span class="line">    def inner():</span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def do_sth():</span><br><span class="line">    temp = 8</span><br><span class="line">    print(temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do_sth()</span><br><span class="line"># print(temp)</span><br><span class="line"></span><br><span class="line">outer_result = outer()</span><br><span class="line">outer_result()</span><br><span class="line">outer()()</span><br><span class="line"></span><br><span class="line">print(outer_result.__closure__)</span><br><span class="line">print(outer_result.__closure__[0].cell_contents)</span><br></pre></td></tr></table></figure>
<ul>
<li>正常情况下，函数被调用后，函数内部声明的变量就会失效</li>
<li>如果一个函数的内部函数引用了外部函数，且外部函数的返回值是内部函数，这个种情况叫闭包，被内部函数引用的变量可以在内部函数特殊属性__closure__中找到</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def outer2():</span><br><span class="line">    a = 10</span><br><span class="line"></span><br><span class="line">    def inner2():</span><br><span class="line">        # a = 11</span><br><span class="line"></span><br><span class="line">        # a += 1</span><br><span class="line"></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    return inner2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def outer3():</span><br><span class="line">    a = [3]</span><br><span class="line"></span><br><span class="line">    def inner3():</span><br><span class="line">        # a = [1]</span><br><span class="line"></span><br><span class="line">        a[0] = 8</span><br><span class="line"></span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line">    return inner3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">outer3()()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def outer4():</span><br><span class="line">    a = 10</span><br><span class="line"></span><br><span class="line">    def inner4():</span><br><span class="line">        nonlocal a</span><br><span class="line"></span><br><span class="line">        # a = 11</span><br><span class="line">        a += 1</span><br><span class="line"></span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line">    return inner4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">outer4_result = outer4()</span><br><span class="line">outer4_result()</span><br><span class="line"></span><br><span class="line">outer4_result()</span><br></pre></td></tr></table></figure>
<ul>
<li>内部函数不能对外部函数的不可变类型的变量进行修改，只会进行覆盖，如果要进行修改需要使用nonlocal关键字来声明对外部函数变量进行使用</li>
<li>闭包的内部函数持有了外部函数的资源，使其在脱离了外部函数之后还可以独立的运行，具体的使用场景后续再探索</li>
</ul>
<h1 id="globals-和locals"><a href="#globals-和locals" class="headerlink" title="globals()和locals()"></a>globals()和locals()</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def outer(a):</span><br><span class="line">    b = 8</span><br><span class="line"></span><br><span class="line">    def inner(c):</span><br><span class="line">        d = 3</span><br><span class="line"></span><br><span class="line">    print(locals()) # &#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 8, &#x27;inner&#x27;: &lt;function outer.&lt;locals&gt;.inner at 0x107fd94c0&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">outer(5)</span><br><span class="line"></span><br><span class="line">g = 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyClass(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(globals())    # &#123;&#x27;__name__&#x27;: &#x27;__main__&#x27; ... &#x27;outer&#x27;: &lt;function outer at 0x107fd9670&gt;, &#x27;g&#x27;: 2, &#x27;MyClass&#x27;: &lt;class &#x27;__main__.MyClass&#x27;&gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>都是返回各自作用域中所有的对象类型和value，注意函数也是对象所以也被返回了</li>
<li>globals中打印了object中的资源所以有很多数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f():</span><br><span class="line">    x = 8</span><br><span class="line">    print(locals())</span><br><span class="line"></span><br><span class="line">    locals()[&#x27;x&#x27;] = 9</span><br><span class="line">    locals()[&#x27;y&#x27;] = 10</span><br><span class="line"></span><br><span class="line">    print(locals())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">g = 2</span><br><span class="line">globals()[&#x27;g&#x27;] = 6</span><br><span class="line">globals()[&#x27;gg&#x27;] = 66</span><br><span class="line"></span><br><span class="line">print(globals())</span><br></pre></td></tr></table></figure>
<ul>
<li>locals返回的是值拷贝，所以通过locals无法修改资源，但是可以通过映射添加新资源</li>
<li>globals返回的是真实的命名空间（数据名和数值），通过globals做的任何修改都会生效</li>
</ul>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul>
<li>上面说到的闭包的作用域比较特殊</li>
<li>还有就是python2和3中列表推导的差异，3中列表推导相当于一个函数有独立的作用域，注意for-in语句一直没有独立作用域</li>
</ul>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1>]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 动态绑定</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">s.name = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s.name)   <span class="comment"># test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self, name</span>):</span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.set_name = MethodType(set_name, s)    <span class="comment"># 为对象绑定方法，只有该对象可以使用</span></span><br><span class="line">s.set_name(<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.name)   <span class="comment"># haha</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s1 = Student()</span></span><br><span class="line"><span class="comment"># s1.set_name(&#x27;s1&#x27;)</span></span><br><span class="line"><span class="comment">#  &#x27;Student&#x27; object has no attribute &#x27;set_name&#x27;  这个实例没有绑定该方法</span></span><br><span class="line"></span><br><span class="line">Student.set_name = set_name     <span class="comment"># 为class绑定方法，所有的对象都可以使用</span></span><br><span class="line">s2 = Student()</span><br><span class="line">s2.set_name(<span class="string">&#x27;s2&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s2.name)  <span class="comment"># s2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>:</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;set_name&#x27;</span>)    <span class="comment"># 通过这个方法可以预留一些属性，同时也是限制</span></span><br><span class="line">    <span class="comment"># TODO 那和直接定义相应的实例属性有什么区别</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = Teacher()</span><br><span class="line">t1.name = <span class="string">&#x27;老师&#x27;</span></span><br><span class="line">t1.age = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name : &#123;&#125;, age : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(t1.name, t1.age))    <span class="comment"># name : 老师, age : 25</span></span><br><span class="line"><span class="comment"># t1.score = 100    score属性无法被绑定</span></span><br><span class="line"><span class="comment"># t1.set_name = set_name</span></span><br><span class="line"><span class="comment"># t1.set_name(name=&#x27;new name&#x27;)</span></span><br><span class="line"><span class="comment"># print(&#x27;name : &#123;&#125;, age : &#123;&#125;&#x27;.format(t1.name, t1.age))</span></span><br><span class="line"><span class="comment"># TODO 同样不能绑定成功</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 实例资源和类资源</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E5%AE%9E%E4%BE%8B%E8%B5%84%E6%BA%90%E5%92%8C%E7%B1%BB%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student:</span><br><span class="line">    name = &#x27;globe_name&#x27;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &#x27;name&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student()</span><br><span class="line">print(s1.name)  # name  实例属性优先级更高，先找实例属性，没有才会找类属性</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>调用属性会先找实例属性，没有再找类属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Student:</span><br><span class="line">    # 类属性</span><br><span class="line">    count = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name) -&gt; None:</span><br><span class="line">        # 实例属性</span><br><span class="line">        self.name = name</span><br><span class="line">        Student.count += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    s = Student(i)</span><br><span class="line">    print(&#x27;name : &#123;&#125;, count : &#123;&#125;&#x27;.format(s.name, s.count))  # 这里使用s.count和Student.count是一样的</span><br><span class="line"></span><br><span class="line"># 打印结果</span><br><span class="line">name : 0, count : 1</span><br><span class="line">name : 1, count : 2</span><br><span class="line">name : 2, count : 3</span><br><span class="line">name : 3, count : 4</span><br><span class="line">name : 4, count : 5</span><br><span class="line">name : 5, count : 6</span><br><span class="line">name : 6, count : 7</span><br><span class="line">name : 7, count : 8</span><br><span class="line">name : 8, count : 9</span><br><span class="line">name : 9, count : 10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>类属性是类绑定，实例之间共享，也就是会存在安全性问题</li>
</ul>
<h1 id="实例方法、类方法、静态方法"><a href="#实例方法、类方法、静态方法" class="headerlink" title="实例方法、类方法、静态方法"></a>实例方法、类方法、静态方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">COUNT = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    name = <span class="string">&#x27;globe_name&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instence_foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;instence_foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_foo</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class_foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_foo</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;static_foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student()</span><br><span class="line">s1.instence_foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s1.instence_foo : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s1.instence_foo))</span><br><span class="line"></span><br><span class="line">s1.class_foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s1.class_foo : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s1.class_foo))</span><br><span class="line"></span><br><span class="line">Student.class_foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Student.class_foo : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(Student.class_foo))</span><br><span class="line"></span><br><span class="line">s1.static_foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;s1.static_foo : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(s1.static_foo))</span><br><span class="line"></span><br><span class="line">Student.static_foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Student.static_foo : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(Student.static_foo))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">instence_foo</span><br><span class="line">s1.instence_foo : &lt;bound method Student.instence_foo of &lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10d0ef340</span>&gt;&gt;</span><br><span class="line">class_foo</span><br><span class="line">s1.class_foo : &lt;bound method Student.class_foo of &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Student&#x27;</span>&gt;&gt;</span><br><span class="line">class_foo</span><br><span class="line">Student.class_foo : &lt;bound method Student.class_foo of &lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Student&#x27;</span>&gt;&gt;</span><br><span class="line">static_foo</span><br><span class="line">s1.static_foo : &lt;function Student.static_foo at <span class="number">0x10d161040</span>&gt;</span><br><span class="line">static_foo</span><br><span class="line">Student.static_foo : &lt;function Student.static_foo at <span class="number">0x10d161040</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例方法只能被实例对象调用</li>
<li>类方法和静态方法都可以被实例对象或者类名调用</li>
<li>实例方法被绑定到实例对象上，类对象被绑定到类上，静态方法是独立的，只是被写入了class中，其实python和Java不同，完全可以写到class外也可以被调用（Java必须要依附于对象）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">COUNT = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    name = <span class="string">&#x27;globe_name&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.age = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">instence_foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;instence_foo&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get COUNT : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(COUNT))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get name : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get age : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.age))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_test</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class_test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_foo</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;class_foo&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get COUNT : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(COUNT))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get name : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(cls.name))</span><br><span class="line">        cls.class_test()</span><br><span class="line">        <span class="comment"># print(&#x27;get age : &#123;&#125;&#x27;.format(cls.age))   # AttributeError: type object &#x27;Student&#x27; has no attribute &#x27;age&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_foo</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;static_foo&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get COUNT : &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(COUNT))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student()</span><br><span class="line">s1.static_foo()</span><br><span class="line">s1.class_foo()</span><br><span class="line">s1.static_foo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">static_foo</span><br><span class="line">get COUNT : <span class="number">1</span></span><br><span class="line">class_foo</span><br><span class="line">get COUNT : <span class="number">1</span></span><br><span class="line">get name : globe_name</span><br><span class="line">class_test</span><br><span class="line">static_foo</span><br><span class="line">get COUNT : <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>本质上，实例对象被创建后会被赋值给self，所以可以通过self关键字调用对象资源</li>
<li>而类资源被赋值给了cls，所以可以通过cls访问到类资源（属性和方法），但是不能访问到实例资源（这些资源是在对象创建的时候被初始化的）</li>
<li>静态方法就不说了，啥都访问不到，只有外面的公共资源可以访问</li>
<li>Java里面没有类资源这个层级，只有静态和实例，类名被使用的时候静态资源就被创建了（因为静态资源可以通过类名直接调用），别的都是实例资源在对象被创建后才可以使用</li>
<li>==放在类定义以外的资源是如何中内存中存活和销毁的呢？==</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 工作目录</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="案例目录结构"><a href="#案例目录结构" class="headerlink" title="案例目录结构"></a>案例目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 目录结构示意图</span><br><span class="line"># project/</span><br><span class="line"># ├── task</span><br><span class="line"># │   ├── main.py</span><br><span class="line"># │   └── ....</span><br><span class="line"># ├── util</span><br><span class="line"># │   ├── xx_util.py</span><br><span class="line"># │   └── ....</span><br><span class="line"># └──  .... </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python task/main.py</span><br></pre></td></tr></table></figure>

<p>sys.path 就会进入到task 目录中，这样main.py 想要 import main 目录外的模块就会出问题，例如import util.xx_util 就会出现 ModuleNotFoundError, 就算本目录下的文件 import task.xxx 也会出现错误，因为sys.path 不对，在task目录下就没有那些文件。</p>
<h2 id="处理方案"><a href="#处理方案" class="headerlink" title="处理方案"></a>处理方案</h2><p>这种情况怎么办呢？我看到过几种做法：</p>
<h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>sys.path.append(‘..’) 将上一级目录 append 进来<br>非常不推荐这种做法，动态改变sys.path会使静态分析工具失效，例如pycharm 等IDE的代码提示。这在大型项目中会极大降低代码的可阅读性、增加开发难度<br>这是软件开发的灾难<br>（补充：通过环境变量PYTHONPATH 指定目录本质上也是sys.path 上append）</p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>使用相对路径import .task.xxx ，from .. import util<br>同样非常不推荐这样做，特别是我们只是想临时debug一下子模块中的包的时候，修改好后还需要改回去，十分繁琐，还有可能带来不一致的问题<br>这是软件开发的灾难</p>
<h3 id="方案三-推荐做法"><a href="#方案三-推荐做法" class="headerlink" title="方案三[ 推荐做法 ]"></a>方案三[ 推荐做法 ]</h3><p>使用python -m task.main 执行程序<br>此时sys.path就在执行这行代码时所在的目录，也就是working directory, 而不会进入main所在的位置，这是十分简单的解决方法，不会带来新的问题</p>
]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 异常处理</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="try…except"><a href="#try…except" class="headerlink" title="try…except"></a>try…except</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">    print(result)</span><br><span class="line">except ArithmeticError:</span><br><span class="line">    print(&quot;数学错误&quot;)   # 数学错误</span><br></pre></td></tr></table></figure>
<ul>
<li>基础的一个处理方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">    print(result)</span><br><span class="line">except ArithmeticError as e:</span><br><span class="line">    print(&quot;数学错误&quot;)   # 数学错误</span><br><span class="line">    print(type(e))  # &lt;class &#x27;ZeroDivisionError&#x27;&gt;</span><br><span class="line">    print(e)    # division by zero</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过as关键字拿到异常对象做处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">    print(result)</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    print(&quot;0不能作为除数&quot;)</span><br><span class="line">except ArithmeticError:</span><br><span class="line">    print(&quot;数学错误&quot;)</span><br><span class="line">print(&quot;结束&quot;)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">    print(result)</span><br><span class="line">except ArithmeticError:</span><br><span class="line">    print(&quot;数学错误&quot;)</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    print(&quot;0不能作为除数&quot;)</span><br><span class="line">print(&quot;结束&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意异常对象之间的继承关系，子类的异常会被父类捕获</li>
<li>异常捕获从上到下，被捕获后就跳出了，所以不要把子类异常放到父类异常后面，当然IDE也会有语法提示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">    print(result)</span><br><span class="line">except TypeError:</span><br><span class="line">    print(&quot;运行出错了&quot;)</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">    print(&quot;运行出错了&quot;)</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&quot;运行出错了&quot;)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">    print(result)</span><br><span class="line">except (TypeError, ZeroDivisionError, ValueError):</span><br><span class="line">    print(&quot;运行出错了&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果有多个异常的处理方式相同可以直接把异常对象放到元组中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    result = 1 / 0</span><br><span class="line">    print(result)</span><br><span class="line">except (TypeError, ValueError):</span><br><span class="line">    print(&quot;类型错误或值错误&quot;)</span><br><span class="line"># except:</span><br><span class="line">except Exception:</span><br><span class="line">    print(&quot;其它错误&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>最后接一个Exception或者直接except来捕获所有异常</li>
</ul>
<h1 id="else从句"><a href="#else从句" class="headerlink" title="else从句"></a>else从句</h1><p>如果没有异常发生则会执行的逻辑</p>
<h1 id="finally从句"><a href="#finally从句" class="headerlink" title="finally从句"></a>finally从句</h1><p>无论什么情况下都需要执行的逻辑</p>
<h1 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise ZeroDivisionError(&#x27;0不能作为除数&#x27;)</span><br><span class="line">except ZeroDivisionError as err:</span><br><span class="line">    print(err)</span><br></pre></td></tr></table></figure>
<ul>
<li>手动抛出异常</li>
</ul>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyException(Exception):</span><br><span class="line">    def __init__(self, msg1, msg2):</span><br><span class="line">        self.msg1 = msg1</span><br><span class="line">        self.msg2 = msg2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    raise MyException(&#x27;123&#x27;, &#x27;abc&#x27;)</span><br><span class="line">except MyException as err:</span><br><span class="line">    print(err)</span><br></pre></td></tr></table></figure>

<h1 id="获取异常信息"><a href="#获取异常信息" class="headerlink" title="获取异常信息"></a>获取异常信息</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line">def f1():</span><br><span class="line">    print(1 / 0)</span><br><span class="line"></span><br><span class="line">def f2():</span><br><span class="line">    try:</span><br><span class="line">        f1()</span><br><span class="line">    except ZeroDivisionError:</span><br><span class="line">        ex_type, ex_value, ex_traceback = sys.exc_info()</span><br><span class="line"></span><br><span class="line">        print(&#x27;异常的类型：%s&#x27; % ex_type)</span><br><span class="line">        print(&#x27;异常的错误信息：%s&#x27; % ex_value)</span><br><span class="line">        print(&#x27;异常调用堆栈的跟踪信息：%s&#x27; % ex_traceback)</span><br><span class="line"></span><br><span class="line">        tb = traceback.extract_tb(ex_traceback)</span><br><span class="line">        print(tb)</span><br><span class="line"></span><br><span class="line">        for filename, linenum, funcname, source in tb:</span><br><span class="line">            print(&#x27;文件名：%s&#x27; % filename)</span><br><span class="line">            print(&#x27;行数：%s&#x27; % linenum)</span><br><span class="line">            print(&#x27;函数名：%s&#x27; % funcname)</span><br><span class="line">            print(&#x27;源码：%s&#x27; % source)</span><br><span class="line"></span><br><span class="line">f2()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 特殊方法和属性</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><ul>
<li>通过dir()查看类对象或者实例时看到的以双下划线开头和结尾的方法和属性就是特殊方法和特殊属性，基本都是继承自object</li>
<li>通常会去显式的调用特殊资源，除了__init__()以外一般也不会去重写</li>
</ul>
<h1 id="dict"><a href="#dict" class="headerlink" title="dict"></a><strong>dict</strong></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ca = <span class="string">&quot;ca&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.ia = <span class="string">&quot;ia_value&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">im</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cm</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sm</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">MyClass.ca2 = <span class="string">&quot;ca2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(MyClass.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;ca&#x27;: &#x27;ca&#x27;, &#x27;__init__&#x27;: &lt;function MyClass.__init__ at 0x1014293a0&gt;, &#x27;im&#x27;: &lt;function MyClass.im at 0x1014d34c0&gt;, &#x27;cm&#x27;: &lt;classmethod object at 0x1013d3cd0&gt;, &#x27;sm&#x27;: &lt;staticmethod object at 0x10144d880&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;MyClass&#x27; objects&gt;, &#x27;__doc__&#x27;: None, &#x27;ca2&#x27;: &#x27;ca2&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line">mc.ia2 = <span class="string">&quot;ia2&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mc.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;ia&#x27;: &#x27;ia_value&#x27;, &#x27;ia2&#x27;: &#x27;ia2&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>特殊属性__dict__，获取到所有的方法和属性组成的字典，key是资源名称</li>
<li>对象不会显示特殊资源</li>
</ul>
<h1 id="类反射"><a href="#类反射" class="headerlink" title="类反射"></a>类反射</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.x = 1</span><br><span class="line"></span><br><span class="line">    def do_sth(self):</span><br><span class="line">        print(&quot;do_sth被调用&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line"></span><br><span class="line">print(hasattr(mc, &#x27;x&#x27;))</span><br><span class="line">print(hasattr(mc, &#x27;do_sth&#x27;))</span><br><span class="line">print(hasattr(mc, &#x27;y&#x27;))</span><br><span class="line"></span><br><span class="line">print(getattr(mc, &#x27;x&#x27;))</span><br><span class="line"></span><br><span class="line">f = getattr(mc, &#x27;do_sth&#x27;)</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"># print(getattr(mc, &#x27;y&#x27;)) </span><br><span class="line">print(getattr(mc, &#x27;y&#x27;, 2))</span><br><span class="line"></span><br><span class="line">setattr(mc, &#x27;z&#x27;, 3)</span><br><span class="line">print(getattr(mc, &#x27;z&#x27;))</span><br><span class="line"></span><br><span class="line">setattr(mc, &#x27;z&#x27;, 4)</span><br><span class="line">print(getattr(mc, &#x27;z&#x27;))</span><br><span class="line"></span><br><span class="line">delattr(mc, &#x27;z&#x27;)</span><br><span class="line">print(hasattr(mc, &#x27;z&#x27;))</span><br></pre></td></tr></table></figure>
<ul>
<li>python是个动态语言，本身就支持动态的为类对象或者实例对象进行属性和方法的绑定删除操作</li>
<li>==getattr()和直接调用方法的区别是什么呢==</li>
</ul>
<h1 id="特殊方法-len"><a href="#特殊方法-len" class="headerlink" title="特殊方法__len__()"></a>特殊方法__len__()</h1><ul>
<li>python有一个内置函数len(),但是它只能对内置类的对象使用</li>
<li>自定义的对象中只要实现了__len()__方法，即可使用len()</li>
</ul>
<h1 id="iter-和-next"><a href="#iter-和-next" class="headerlink" title="iter()和__next__()"></a><strong>iter</strong>()和__next__()</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyClass(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data = 0</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.data &gt; 5:</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        else:</span><br><span class="line">            self.data += 1</span><br><span class="line">            return self.data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for item in MyClass():</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<ul>
<li>自定义对象想要使用for-in语句，需要对__iter__()和__next__()进行实现</li>
</ul>
<h1 id="str-和-repr"><a href="#str-和-repr" class="headerlink" title="str()和__repr__()"></a><strong>str</strong>()和__repr__()</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; class MyClass(object):</span><br><span class="line">...     def __str__(self):</span><br><span class="line">...         return &quot;__str__被调用&quot;</span><br><span class="line">...     def __repr__(self):</span><br><span class="line">...         return &quot;__repr__被调用&quot;</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; mc = MyClass()</span><br><span class="line">&gt;&gt;&gt; mc</span><br><span class="line">__repr__被调用</span><br><span class="line">&gt;&gt;&gt; print(mc)</span><br><span class="line">__str__被调用</span><br><span class="line">&gt;&gt;&gt; str(mc)</span><br><span class="line">&#x27;__str__被调用&#x27;</span><br><span class="line">&gt;&gt;&gt; repr(mc)</span><br><span class="line">&#x27;__repr__被调用&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>对应了两个内置函数str()和repr()</li>
<li>还得说说两个内置函数的区别，str追求输出内容的可读性，repr追求数据的完整性（适合调试，尽量把信息展示齐全）</li>
<li>直接打印一个实例对象时，调用__repr__()，如果没有实现，打印类对象信息和实力对象在内存中的地址</li>
<li>print()，查找__str__() -&gt; <strong>repr</strong>() -&gt;打印内存地址</li>
<li>str(),调用此方法其实是创建一个字符串，<strong>str</strong>() -&gt; <strong>repr</strong>() -&gt;打印内存地址</li>
<li>repr(),<strong>repr</strong>() -&gt;打印内存地址</li>
<li>通常情况下两个特殊方法的实现是一样的，所以实现一个方法后可以赋值给另一个方法<code>__repr__ = __str__</code></li>
</ul>
<h1 id="new"><a href="#new" class="headerlink" title="new()"></a><strong>new</strong>()</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;父类的__new__()被调用，其形参cls对应实参的id:%s&quot; % id(cls))</span><br><span class="line">        obj = super().__new__(cls)</span><br><span class="line">        print(&quot;创建的实例对象的id:%s&quot; % id(obj))</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        print(&quot;子类的__init__()被调用，其形参self对应实参的id：%s&quot; % id(self))</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&quot;父类的id：%s&quot; % id(Parent))</span><br><span class="line">print(&quot;子类的id：%s&quot; % id(Child))</span><br><span class="line"></span><br><span class="line">child = Child(&quot;Mike&quot;)</span><br><span class="line">print(&quot;创建的实例对象的id：%s&quot; % id(child))</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">父类的id：140308712091888</span><br><span class="line">子类的id：140308712092832</span><br><span class="line">父类的__new__()被调用，其形参cls对应实参的id:140308712092832</span><br><span class="line">创建的实例对象的id:4371497552</span><br><span class="line">子类的__init__()被调用，其形参self对应实参的id：4371497552</span><br><span class="line">创建的实例对象的id：4371497552</span><br></pre></td></tr></table></figure>
<ul>
<li>通过类名()的方式创建实例对象时，执行两个操作<ul>
<li>执行__new__()方法，自身实现-&gt;父类实现-&gt;object实现，通过__new__()创建对象</li>
<li>执行__init_()对创建的对象进行初始化</li>
</ul>
</li>
</ul>
<h1 id="del"><a href="#del" class="headerlink" title="del()"></a><strong>del</strong>()</h1><p>对象被回收前会先调用这个方法，注意del obj也只是告诉回收器进行回收，具体有没有释放掉不确定，不一定是立即进行回收</p>
<h1 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a><strong>getattr</strong>()</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class SomeClass(object):</span><br><span class="line">    def __getattr__(self, name):</span><br><span class="line">        if name == &quot;data&quot;:</span><br><span class="line">            return 18</span><br><span class="line">        elif name == &quot;do_sth&quot;:</span><br><span class="line">            return print</span><br><span class="line">        raise AttributeError(&quot;&#x27;SomeClass&#x27; object has no attribute &#x27;%s&#x27;&quot; % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sc = SomeClass()</span><br><span class="line">print(sc.data)  # 18</span><br><span class="line">sc.do_sth(1, 2, 3)  # 1 2 3</span><br><span class="line">print(sc.score) # AttributeError: &#x27;SomeClass&#x27; object has no attribute &#x27;score&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问对象的属性或者方法时，如果资源不存在会抛出AttributeError</li>
<li>如果实现了__getattr__()，则会调用这个特殊方法</li>
</ul>
<h1 id="getitem"><a href="#getitem" class="headerlink" title="getitem()"></a><strong>getitem</strong>()</h1><p>迭代对象时<code>obj[index]</code>会调用此特殊方法</p>
<h1 id="call"><a href="#call" class="headerlink" title="call()"></a><strong>call</strong>()</h1><p><code>obj()</code>，把对象当方法调用，奇怪的脑洞</p>
<h1 id="doc"><a href="#doc" class="headerlink" title="doc()"></a><strong>doc</strong>()</h1><p>获取对象的文档字符串，也就是类的注释”””对类的描述说明”””</p>
<h1 id="slots"><a href="#slots" class="headerlink" title="slots()"></a><strong>slots</strong>()</h1><p>动态绑定的时候说过这个方法，python是一个动态语言，可以给对象动态绑定资源，这个特殊方法是为了限制这一点，只有在这个方法中预留的资源才可以进行动态绑定</p>
]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 生成器迭代器</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E7%94%9F%E6%88%90%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ge = (i * i for i in range(1, 7))</span><br><span class="line">&lt;!--调用方式一：--&gt;</span><br><span class="line">print(next(ge))</span><br><span class="line">print(next(ge))</span><br><span class="line">print(next(ge))</span><br><span class="line">&lt;!--调用方式二--&gt;</span><br><span class="line">for item in ge:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<ul>
<li>之前讲过python有列表推导和生成器表达式，列表推导会把所有元素都生成放到列表中再进行遍历，而生成器表达式是在遍历的过程中对后续的元素进行生成（保存的不是对应的元素而是如何推算出元素的算法）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    i = 0</span><br><span class="line">    a, b = 1, 1</span><br><span class="line">    while i &lt; n:</span><br><span class="line">        yield a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        i += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gf = fib(6)</span><br><span class="line">print(next(gf))</span><br><span class="line">print(next(gf))</span><br><span class="line"></span><br><span class="line">gf = fib(6)</span><br><span class="line"></span><br><span class="line">for item in gf:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>生成器是是用yield进行实现的，和Java多线程中的yield完全不同，这里是每次迭代的时候会在yield处进行return，下次遍历从yield之后再次执行</li>
</ul>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><ul>
<li>可以是用for-in语句的对象称为可迭代对象（Iterable），一个可迭代对象可以作为内置函数next()的实参进行惰性推算叫做迭代器对象（Iterator），列表、元组、字典等都不是迭代器对象</li>
<li>可以调用内置函数iter()把可迭代对象转换为迭代器对象</li>
<li>一个对象同时实现了__iter__()和__next()<strong>，这个对象也被称为迭代器对象，for-in语句会先调用__iter()</strong>()返回一个可迭代对象，然后不断调用__next()__()返回下一次迭代的值</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 脚本传参</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E8%84%9A%E6%9C%AC%E4%BC%A0%E5%8F%82/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    parser = argparse.ArgumentParser(description=&#x27;此脚本运行需要输入必要参数&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;--pid&#x27;, &#x27;-p&#x27;, help=&#x27;产品ID，必要参数&#x27;, required=True)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    prodcut_id = args.pid</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 获取对象信息的内置方法</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF%E7%9A%84%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass"></a>issubclass</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(D, A))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(D, B))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(D, (B, A, C)))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(D, (B, C)))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">str</span>))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">bool</span>, (<span class="built_in">str</span>, <span class="built_in">int</span>, <span class="built_in">dict</span>)))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">bool</span>, (<span class="built_in">str</span>, <span class="built_in">list</span>, <span class="built_in">dict</span>)))  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(D(), D))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(D(), A))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(D(), (D, B, C)))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(D(), (B, A, C)))  <span class="comment"># True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>issubclass用于判断是否是子类</li>
<li>第一个参数是类对象，第二个参数是类对象或者元组，如果第二个参数是元组的时候，第一个类对象如果是元组中任意一个元素的子类的时候就会返回True</li>
<li>isinstance方法于上面类似</li>
</ul>
<h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mc = MyClass()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(mc))  <span class="comment"># &lt;class &#x27;__main__.MyClass&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">18</span>))  <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>))  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(MyClass))  <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">int</span>))  <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">str</span>))  <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_sth</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(do_sth))  <span class="comment"># &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))  <span class="comment"># &lt;class &#x27;builtin_function_or_method&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">18</span>) == <span class="built_in">int</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>) == <span class="built_in">str</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(type(do_sth) == function)</span></span><br><span class="line"><span class="comment"># print(type(print) == builtin_function_or_method)</span></span><br><span class="line"><span class="comment"># 不能直接判断，这两个类型中types里面有定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(do_sth) == types.FunctionType)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>) == types.BuiltinFunctionType)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>type用来查看对象类型</li>
<li>类对象的类型是type，也就是说类对象是type的一个实例</li>
<li>自定义方法的类型是FunctionType</li>
<li>内置方法的类型是BuiltinFunctionType</li>
</ul>
<h1 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class MyClass(object):</span><br><span class="line">    ca = &quot;ca&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.ia = &quot;ia&quot;</span><br><span class="line"></span><br><span class="line">    def im(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def cm(cls):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def sm():</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">print(dir(MyClass))</span><br><span class="line"># 输出</span><br><span class="line">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27; ... &#x27;ca&#x27;, &#x27;cm&#x27;, &#x27;im&#x27;, &#x27;sm&#x27;]</span><br><span class="line"></span><br><span class="line">print(dir(MyClass()))</span><br><span class="line"># 输出</span><br><span class="line">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27; ... &#x27;ca&#x27;, &#x27;cm&#x27;, &#x27;ia&#x27;, &#x27;im&#x27;, &#x27;sm&#x27;]</span><br></pre></td></tr></table></figure>
<ul>
<li>dir可以获取到类对象或者实例对象可访问到的方法和属性（包括父类资源）的列表</li>
<li>==类对象中不能查看到实例属性，但能看到实例方法，这是为什么呢==</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础 -- 访问限制</title>
    <url>/2023/04/13/python/python%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Student:</span><br><span class="line">    # 类属性</span><br><span class="line">    __count = 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name) -&gt; None:</span><br><span class="line">        # 实例属性</span><br><span class="line">        self.name = name</span><br><span class="line">        Student.__count += 1</span><br><span class="line">        self.__age = 100</span><br><span class="line">        self._score = 1000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student(&#x27;haha&#x27;)</span><br><span class="line">print(s1._score)    # 1000</span><br><span class="line"># print(s1.__age)     # AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__age&#x27;</span><br><span class="line">print(dir(s1))      # [&#x27;_Student__age&#x27;, &#x27;_Student__count&#x27;, &#x27;__class__&#x27;, ... &#x27;name&#x27;]</span><br><span class="line">print(&#x27;age : &#123;&#125;, count: &#123;&#125;&#x27;.format(s1._Student__age, s1._Student__count))   # age : 100, count: 1</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    s = Student(i)</span><br><span class="line">    print(&#x27;name : &#123;&#125;, count : &#123;&#125;&#x27;.format(s.name, s._Student__count))</span><br><span class="line"></span><br><span class="line"># 打印结果</span><br><span class="line">name : 0, count : 2</span><br><span class="line">name : 1, count : 3</span><br><span class="line">name : 2, count : 4</span><br><span class="line">name : 3, count : 5</span><br><span class="line">name : 4, count : 6</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>python并不像Java那样有明确的public、private之类的关键字来对属性做访问限制，但也有一套自己的实现</li>
<li>_score,一个下划线开头是可以被访问到的，这个是开发者约定俗成的私有变量，不推荐去使用，但没有做语法保护</li>
<li>__age和__count，这两个属性是不能被直接访问到的，但是通过dir可以看到实际是生成了对应的_Student__age和_Student__count，所以硬要访问也可以通过这样的方式实现</li>
<li>私有变量只要通过set和get来进行安全的访问即可</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫 -- Xpath解析</title>
    <url>/2023/04/13/python/%E7%88%AC%E8%99%AB/Xpath%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="抓取数据"><a href="#抓取数据" class="headerlink" title="抓取数据"></a>抓取数据</h2><pre><code>from lxml import etree
html = requests.get(url=product_url)
&lt;!--解析数据--&gt;
html = etree.HTML(html.content)
html_data = html.xpath(&#39;/html/body/div/ul/li/a&#39;)
</code></pre>
<h2 id="使用xpath进行数据定位"><a href="#使用xpath进行数据定位" class="headerlink" title="使用xpath进行数据定位"></a>使用xpath进行数据定位</h2><pre><code>&lt;!--这里列举一些语法案例--&gt;
//button[@type=&#39;submit&#39;]
//section/span[contains(@class,&#39;glyphsSpriteHeart&#39;)]/..
//input[@id=&#39;username&#39;]
//a[contains(@href, &quot;/products/&quot;)]/@href
</code></pre>
]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫 -- 爬虫总结</title>
    <url>/2023/04/13/python/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="问题与解决方案"><a href="#问题与解决方案" class="headerlink" title="问题与解决方案"></a>问题与解决方案</h1><h2 id="模拟请求"><a href="#模拟请求" class="headerlink" title="模拟请求"></a>模拟请求</h2>]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python -- 文本和字节序列</title>
    <url>/2023/04/13/python/%E6%B5%81%E7%95%85%E7%9A%84Python/%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>人类使用文本，计算机使用字节序列</p>
<h1 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h1><p>python3的str相当于python2中的unicode类型</p>
<pre><code>str-&gt;bytes   encode
bytes-&gt;str   decode
</code></pre>
<p>但是由于编码的时候会指定编码方式，解码的时候需要使用同样的编码方式，很多时候拿到了bytes却不知道编码方式导致无法解码</p>
]]></content>
      <categories>
        <category>python</category>
        <category>流畅的Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>流畅的Python</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python -- 第一章 Python的模型</title>
    <url>/2023/04/13/python/%E6%B5%81%E7%95%85%E7%9A%84Python/%E7%AC%AC%E4%B8%80%E7%AB%A0%20Python%E7%9A%84%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Python的模型"><a href="#Python的模型" class="headerlink" title="Python的模型"></a>Python的模型</h1><h2 id="一摞Python风格的纸牌"><a href="#一摞Python风格的纸牌" class="headerlink" title="一摞Python风格的纸牌"></a>一摞Python风格的纸牌</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line">Card = collections.namedtuple(&#x27;Card&#x27;, [&#x27;rank&#x27;, &#x27;suit&#x27;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FrenchDeck:</span><br><span class="line">    ranks = [str(n) for n in range(2, 11)] + list(&#x27;JQKA&#x27;)</span><br><span class="line">    suits = &#x27;spades diamonds clubs hearts&#x27;.split()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self._cards)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, position):</span><br><span class="line">        return self._cards[position]</span><br></pre></td></tr></table></figure>
<ul>
<li>namedtuple方法用于构建一些只有属性但没有方法的简单类（比如数据库条目）</li>
<li>__len__和__getitem__是Python的两个特殊方法，分别对应了len(obj)和obj[]，现在对这两个方法进行了重写，FrenchDeck类的对象再调用这两个特殊方法时就会走重写的逻辑</li>
<li>由于__getitem__将[]指向了self._cards，FrenchDeck对象将支持所有[]的功能比如切片、获取首尾元素，==这里没看懂实用性在哪毕竟self._cards本身也是一个list也有这些功能==</li>
</ul>
<h2 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h2><p>上面提到的__len__和__getitem__是Python的特殊方法，这些特殊方法是给Python调节器用的，开发者不要直接去调用，而是通过len()</p>
<ul>
<li>当对自定义的类使用len()方法时会去调用自定义实现的__len__；当对内置类型使用len()，那么 CPython 会抄个近路，<strong>len</strong> 实际上会直接返回 PyVarObject 里的 ob_size 属性。PyVarObject是表示内存中长度可变的内置对象的 C 语言结构体。直接读取这个值比调用一个方法要快很多</li>
<li>通常代码无需直接调用特殊方法，特例是__init__</li>
<li>通过内置函数（len、str、iter）来使用特殊方法，内置函数会有额外的优化，性能更高，后续会详细的说明</li>
<li>最好不要自行定义特殊方法，比如__foo__，当前版本该方法没有被使用，但在后续的版本中就不一定了</li>
</ul>
<h3 id="模拟数值类型"><a href="#模拟数值类型" class="headerlink" title="模拟数值类型"></a>模拟数值类型</h3><p>通过重写__add__、__mul__等特殊方法来实现一个二维向量类，直接实现+、*等操作</p>
<h3 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h3><p>通过__repr__方法的重新，可以实现类似java中toString方法的效果</p>
<h2 id="特殊方法一览"><a href="#特殊方法一览" class="headerlink" title="特殊方法一览"></a>特殊方法一览</h2><p>Python中共计有83个特殊方法，其中47个用于实现算术运算，这里不一个个全列出来了</p>
<h2 id="len为什么不是一个普通方法"><a href="#len为什么不是一个普通方法" class="headerlink" title="len为什么不是一个普通方法"></a>len为什么不是一个普通方法</h2><p>实用大于纯粹，之前也提到了，内置的对象实用len时能够获得更高的性能，Python也提供给了自义定类使用len的方法，在语言一致性上找到了平衡点（==这里不太理解如果把len作为一个普通方法让内置类去实现为什么就不能走性能捷径了，应该是语言结构决定的后续应该会讲==）</p>
]]></content>
      <categories>
        <category>python</category>
        <category>流畅的Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>流畅的Python</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python -- 第三章 字典与集合</title>
    <url>/2023/04/13/python/%E6%B5%81%E7%95%85%E7%9A%84Python/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E5%85%B8%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="泛映射类型（key-value）"><a href="#泛映射类型（key-value）" class="headerlink" title="泛映射类型（key-value）"></a>泛映射类型（key-value）</h1><p>这里提到了一个可散列的概念，可散列对象需要实现一个__hash__方法，会有一个可散列值，这个值在生命周期中是不变的，大概也就是说需要是原子不可变数据类型（str、bytes和数值类型），一般来讲用户自定义类的对象都是可散列的，散列值是他们id()函数的返回值</p>
<p>只有可散列的数据才能作为字典的key</p>
<pre><code>dict(one=1, two=2, three=3)
&#123;&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3&#125;
dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3]))
dict([(&#39;two&#39;, 2), (&#39;one&#39;, 1), (&#39;three&#39;, 3)])
dict(&#123;&#39;three&#39;: 3, &#39;one&#39;: 1, &#39;two&#39;: 2&#125;)
</code></pre>
<p>构建字典的几种方式，实现方式太多也不是好事情</p>
<h1 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h1><pre><code>DIAL_CODES  = [(86, &#39;China&#39;)]
&#123;country: code for code, country in DIAL_CODES&#125; 
</code></pre>
<p>写法有些迷惑，用到的时候再看吧，和列表推导相似</p>
<h1 id="常见的映射方法"><a href="#常见的映射方法" class="headerlink" title="常见的映射方法"></a>常见的映射方法</h1><h2 id="用setdefault处理找不到的键"><a href="#用setdefault处理找不到的键" class="headerlink" title="用setdefault处理找不到的键"></a>用setdefault处理找不到的键</h2><p><code>d.get(k, default)</code>通过这个方法可以为找不到的键一个默认的返回值</p>
<pre><code># 方式一：
if key not in my_dict:
    my_dict[key] = []
my_dict[key].append(new_value)

# 方式二：
my_dict.setdefault(key, []).append(new_value)
</code></pre>
<p>方式一需要至少两次查询，如果key不存在需要三次查询，而方式二只需要一次查询</p>
<h1 id="映射的弹性查询"><a href="#映射的弹性查询" class="headerlink" title="映射的弹性查询"></a>映射的弹性查询</h1><h2 id="defaultdict-处理找不到的键"><a href="#defaultdict-处理找不到的键" class="headerlink" title="defaultdict 处理找不到的键"></a>defaultdict 处理找不到的键</h2><pre><code>index = collections.defaultdict(list) 
index[key].append(new_value)
</code></pre>
<p>defaultdict会按照定义为不存在的key做初始化，所以第二句代码总能成功执行</p>
<p>如果创建的时候没有指定default_factory，在查询不存在的key的时候会触发KeyError</p>
<p>defaultdict的初始化操作是在__getitem__方法中被调用的，如果通过index.get(key)的方式就会返回None</p>
<h2 id="missing-方法"><a href="#missing-方法" class="headerlink" title="__missing__方法"></a>__missing__方法</h2><p>所有的映射类型在处理找不到键的时候，都会尝试调用__missing__方法，而dict中只是没有去做实现所以直接触发了KeyError，我们可以继承dict然后实现__missing__方法即可模拟defaultdict的功能</p>
<h2 id="继承dict以自定义功能"><a href="#继承dict以自定义功能" class="headerlink" title="继承dict以自定义功能"></a>继承dict以自定义功能</h2><p>通过覆盖父类的方法来实现key忽略类型来获取数据（d[1]和d[‘1’]获取到同一个value）</p>
<h1 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h1><h2 id="collections-OrderedDict"><a href="#collections-OrderedDict" class="headerlink" title="collections.OrderedDict"></a>collections.OrderedDict</h2><p>一个有序的字典，通过<code>my_odict.popitem(last=False)</code>可以实现队列的功能</p>
<h2 id="collections-ChainMap"><a href="#collections-ChainMap" class="headerlink" title="collections.ChainMap"></a>collections.ChainMap</h2><p>没整明白</p>
<h2 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h2><pre><code>ct = collections.Counter(&#39;abracadabra&#39;)
ct  # Counter(&#123;&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;r&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1&#125;)
ct.most_common(2)  # [(&#39;a&#39;, 5), (&#39;b&#39;, 2)]
</code></pre>
<h2 id="colllections-UserDict"><a href="#colllections-UserDict" class="headerlink" title="colllections.UserDict"></a>colllections.UserDict</h2><p>使用纯Python把dict写了一遍，这个类不直接提供功能，而是用于用户继承已自定义子类</p>
<h1 id="子类化UserDict"><a href="#子类化UserDict" class="headerlink" title="子类化UserDict"></a>子类化UserDict</h1><p>UserDict和dict的区别上面也大概说了，如果我们想要一个定制化的字典类，那通过继承UserDict来实现要比继承dict要方便很多（UserDict也不是dict的子类）</p>
<h1 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h1><p>标准库中所有的映射类型都是可变的，如果不希望某些数据在使用中被篡改，可以借助MappingProxyType来实现</p>
<pre><code>from types import MappingProxyType
d = &#123;a:1&#125;
d_proxy = MappingProxyType(d)
</code></pre>
<p>这里d_proxy只读，而修改d的内容d_proxy内容会同步更新，可以将d设置为私有，而暴露d_proxy给用户</p>
<h1 id="论集合"><a href="#论集合" class="headerlink" title="论集合"></a>论集合</h1><p>即set，在Python里面出现比较晚，用得也比较少，特性就是去重</p>
<pre><code># needles和haystack是两个集合
found = len(needles &amp; haystack)

found = 0
for n in needles:
    if n in haystack:
        found += 1
</code></pre>
<p>比较逗的是书上说的是方法一比方法二要快，方法一要求两个序列都是集合，方法二只要是可迭代对象，但如果两个都不是set的时候，虽然可以做强转但会涉及到对象转换的成本，结论说，如果两个对象中有一个已经是set都可能会比第二种方法快</p>
]]></content>
      <categories>
        <category>python</category>
        <category>流畅的Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>流畅的Python</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python -- 第二章 序列构成的数组</title>
    <url>/2023/04/13/python/%E6%B5%81%E7%95%85%E7%9A%84Python/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="序列构成的数组"><a href="#序列构成的数组" class="headerlink" title="序列构成的数组"></a>序列构成的数组</h1><p>Python的作者以前参与过一个叫ABC的语言的迭代，这个语言是专为初学者准备的，所以Python身上也有很多它的特征，其中之一就是序列的泛型操作，也就是字符串、列表、数组、字节序列、xml元素以及数据库查询结果等都共用一套操作：迭代、切片、排序和拼接</p>
<p>比如说java中string要进行切割的话需要调用方法比如split（当然py中同样有这个方法）或者substring来指定保留的内容，而数组需要通过copyOfRange方法或者subList方法，但py中都可以通过[]来完成</p>
<h2 id="Python内置序列（集合）"><a href="#Python内置序列（集合）" class="headerlink" title="Python内置序列（集合）"></a>Python内置序列（集合）</h2><h3 id="容器序列"><a href="#容器序列" class="headerlink" title="容器序列"></a>容器序列</h3><p>list、tuple 和 collections.deque 这些序列能存放不同类型的数据。</p>
<h3 id="扁平序列"><a href="#扁平序列" class="headerlink" title="扁平序列"></a>扁平序列</h3><p>str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。</p>
<p>容器序列中存储的是对象引用，扁平序列中存储的是值（基础数据类型），这里说扁平序列都是连续的内存空间更加紧凑</p>
<h3 id="可变不可变序列"><a href="#可变不可变序列" class="headerlink" title="可变不可变序列"></a>可变不可变序列</h3><p>按照是否可变进行划分</p>
<ul>
<li>可变：list、bytearray、array.array、collections.deque 和memoryview</li>
<li>不可变：tuple、str 和 bytes</li>
</ul>
<h2 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h2><p>列表推导（list comprehension）是构建列表的快捷方式，生成器表达式（generator expression）则可以用于创建其他任何类型的序列</p>
<h3 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h3><p><code>[card for card in cards]</code>这个就叫做列表推导，能提高代码的可阅读性，但不要滥用它，通常的原则是只用来创建列表，且如果代码超过了两行就要考虑是否用for循环的方式写了，这个自行把握尺度</p>
<ul>
<li>另外Python会忽略[]、{}和()中的换行</li>
<li>Python2中列表推到会出现变量泄露，也就是说上面的card如果之前有定义，在列表推到后会被赋值为最后一次迭代的元素，Python3中不会再有这个问题，列表推导有自己的作用域</li>
</ul>
<p>还有嵌套的列表推导<code>[(color, size) for color in colors for size in sizes]</code>，即是一个嵌套循环colors是外层循环</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p><code>tuple(ord(symbol) for symbol in symbols)</code></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>这里说一下，列表推导就是用来生成列表的，如果一定要用来做元组、数组之类的初始化会有一个内存浪费的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">colors = [&#x27;black&#x27;, &#x27;white&#x27;]</span><br><span class="line">sizes = [&#x27;S&#x27;, &#x27;M&#x27;, &#x27;L&#x27;]</span><br><span class="line">for tshirt in [&#x27;&#123;&#125; &#123;&#125;&#x27;.format(c, s) for c in colors for s in sizes]:</span><br><span class="line">    print(tshirt)</span><br><span class="line"></span><br><span class="line">for tshirt in (&#x27;&#123;&#125; &#123;&#125;&#x27;.format(c, s) for c in colors for s in sizes):</span><br><span class="line">    print(tshirt)</span><br></pre></td></tr></table></figure>
<p>在上面的案例中用列表推导的方式会先生成一个长度为6的列表，然后再进行遍历打印，而生成器表达式遵循迭代器协议，一次循环只生成一个元素进行打印；想象一下如果colors和sizes都是1000，那么会多出一个长度为100w列表的内存占用</p>
<h2 id="元组不仅仅是不可变列表"><a href="#元组不仅仅是不可变列表" class="headerlink" title="元组不仅仅是不可变列表"></a>元组不仅仅是不可变列表</h2><p>在很多的入门教程中会说元组是不可变的列表，这个是从构造的角度说的，而从作用上来看就不仅如此</p>
<h3 id="元组和记录"><a href="#元组和记录" class="headerlink" title="元组和记录"></a>元组和记录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lax_coordinates = (33.9425, -118.408056)</span><br><span class="line">city, year, pop, chg, area = (&#x27;Tokyo&#x27;, 2003, 32450, 0.66, 8014)</span><br><span class="line">traveler_ids = [(&#x27;USA&#x27;, &#x27;31195855&#x27;), (&#x27;BRA&#x27;, &#x27;CE342567&#x27;), (&#x27;ESP&#x27;, &#x27;XDA205856&#x27;)]</span><br></pre></td></tr></table></figure>
<p>在上面的案例中，前两个示例是元组，而第三个是由元组组成的列表，那么我们来看看元组为什么要定义为不可变的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lax_coordinates = (33.9425, -118.408056)</span><br><span class="line">print(lax_coordinates[0])   # 33.9425</span><br><span class="line">lax_coordinates[0] = 1  # TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>
<p>案例中lax_coordinates存储了洛杉矶机场的经纬度，元组可以通过[]角标来访问也可以迭代访问（都说了是不可变的列表嘛）</p>
<p>但是这里准备将经度修改为1，这就不行了，而且如果想将第一个元素和第二个元素进行对调也是不行的，很明显元组虽然也是列表，但元组里面的每个元素都有自己的含义比如这里的经纬度，所以本质是一条记录，而不单纯是一堆数据的容器，每个位子都有他特定的含义</p>
<p><em>“除了用作不可变的列表，它还可以用于没有字段名的记录”</em></p>
<h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p><code>for country, _ in traveler_ids</code> 通过迭代分布提取元组中的元素叫做拆包，这里我们认为第二个元素没有意义，所以用_占位符给忽略掉<br><code>print(&#39;%s, %s&#39; % lax_coordinates)</code>元组拆包方式二<br><code>city, year, pop, chg, area = (&#39;Tokyo&#39;, 2003, 32450, 0.66, 8014)</code>元组拆包方式三</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">divmod(20, 8)   # (2, 4)</span><br><span class="line">t = (20, 8)</span><br><span class="line">divmod(*t)  # (2, 4)</span><br><span class="line">quotient, remainder = divmod(*t)</span><br><span class="line">quotient, remainder     # (2, 4)</span><br></pre></td></tr></table></figure>
<p>拆包方式四<br><code>a, b, *rest = range(5)</code> 这里会将[2, 3, 4]都放到reset中（接收的时候要加上*），且reset可以放到任意位置比如<code>a, *rest， b = range(5)</code><br><code>a, b = b, a</code> 优雅的元素置换方式，==具体实现有待探究==</p>
<h3 id="嵌套拆包"><a href="#嵌套拆包" class="headerlink" title="嵌套拆包"></a>嵌套拆包</h3><p><code>name, cc, pop, (latitude, longitude) = (&#39;Tokyo&#39;,&#39;JP&#39;,36.933,(35.689722,139.691667))</code></p>
<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p>元组已经设计得很好用了，但作为记录来用的话，还是少了一个功能：我们时常会需要给记录中的字段命名。namedtuple 函数的出现帮我们解决了这个问题。</p>
<p>collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类——这个带名字的类对调试程序有很大帮助。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">City = namedtuple(&#x27;City&#x27;, &#x27;name country population coordinates&#x27;)</span><br><span class="line">tokyo = City(&#x27;Tokyo&#x27;, &#x27;JP&#x27;, 36.933, (35.689722, 139.691667))</span><br><span class="line">tokyo   # City(name=&#x27;Tokyo&#x27;, country=&#x27;JP&#x27;, population=36.933, coordinates=(35.689722, 139.691667))</span><br><span class="line">City._fields    # (&#x27;name&#x27;, &#x27;country&#x27;, &#x27;population&#x27;, &#x27;coordinates&#x27;)</span><br><span class="line">tokyo._asdict()     # OrderedDict([(&#x27;name&#x27;, &#x27;Tokyo&#x27;), (&#x27;country&#x27;, &#x27;JP&#x27;), (&#x27;population&#x27;, 36.933), (&#x27;coordinates&#x27;, (35.689722, 139.691667))])</span><br><span class="line">tokyo._asdict().items()     # 可进行迭代</span><br></pre></td></tr></table></figure>

<h3 id="作为不可变的列表"><a href="#作为不可变的列表" class="headerlink" title="作为不可变的列表"></a>作为不可变的列表</h3><p>具体来说和列表的区别就是，无法追加、删除元素等修改操作，可以做是否包含的判定</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是一个强大的功能，这里先介绍怎么用，后续会说底层原理</p>
<h3 id="为什么切片和区间会忽略最后一个元素"><a href="#为什么切片和区间会忽略最后一个元素" class="headerlink" title="为什么切片和区间会忽略最后一个元素"></a>为什么切片和区间会忽略最后一个元素</h3><p>就是解释一下为什么要和c一样从0开始计算</p>
<ul>
<li>range(3)即返回三个元素，直观</li>
<li>range(1, 5)返回5-1个元素，直观</li>
<li>my_list[:x] 和 my_list[x:]可以从第几个元素那分割序列，直观</li>
</ul>
<h3 id="对对象进行切片"><a href="#对对象进行切片" class="headerlink" title="对对象进行切片"></a>对对象进行切片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#x27;bicycle&#x27;</span><br><span class="line">s[::3]  # &#x27;bye&#x27;</span><br><span class="line">s[::-1]  # &#x27;elcycib&#x27;  </span><br><span class="line">s[::-2]  # &#x27;eccb&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="多维切片和省略"><a href="#多维切片和省略" class="headerlink" title="多维切片和省略"></a>多维切片和省略</h3><p>a[m:n, k:l] 大概是这样，这里没看懂且不是很常用</p>
<h3 id="切片赋值"><a href="#切片赋值" class="headerlink" title="切片赋值"></a>切片赋值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l = list(range(10))</span><br><span class="line">l[2:5] = [20, 30]   # [0, 1, 20, 30, 5, 6, 7, 8, 9]</span><br><span class="line">del l[5:7]  # [0, 1, 20, 30, 5, 8, 9]</span><br><span class="line">l[3::2] = [11, 22]  # [0, 1, 20, 11, 5, 22, 9]</span><br><span class="line">l[2:5] = [100]  # [0, 1, 100, 22, 9]</span><br></pre></td></tr></table></figure>

<h2 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h2><ul>
<li><p>使用+来拼接两个序列的时候，会创建一个同样类型数据的序列来作为拼接的结果</p>
</li>
<li><p>如果想要将一个序列复制几份然后再拼接起来，更快捷的是吧序列乘以一个整数</p>
</li>
<li><p><code>[[]] * 3</code>这个时候得到的列表里面的三个元素都是同一个引用</p>
</li>
<li><p>二维列表的创建方式</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[&#x27;_&#x27;] * 3 for i in range(3)]</span><br><span class="line">[[&#x27;_&#x27;] * 3] * 3</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h2><p>对于<code>a += b</code> 如果a实现了__iadd__方法（就地加法）就会调用这个方法，如果没有实现则会调用__add__方法；即是说对于可变序列来说a指向的对象没有变，对对象进行了扩展，如果是__add__方法的话，就会变成<code>a + b</code></p>
<p>可变序列一般都实现了__iadd__方法，不可变序列不支持这个操作，str是一个例外，由于字符串的+=操作太常见了所以做了特殊的优化（==初始化的时候预留出内存，这还叫不可变？==）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = (1, 2, [30, 40])</span><br><span class="line">t[2] += [50, 60]</span><br></pre></td></tr></table></figure>
<p>上面的案例会发生什么？</p>
<ul>
<li>报错：’tuple’ object does not support item assignment</li>
<li>t的值会被修改：(1, 2, [30, 40, 50, 60])，原因是t[2]指向的是一个可变对象，所以可变对象的+=操作执行成功了，在将执行结果赋值给元组的时候报错</li>
</ul>
<h2 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h2><p>list.sort方法会就地排序列表，不会发生复制，所以返回值为None，这种情况下返回None是Python的一个惯例：如果一个函数或者方法对对象进行的是就地改动那它就应该返回None</p>
<p>让调用者知道传入的参数发生了变动且未产生新的对象，其弊端是无法将其串联起来调用，而str的所有方法则正好相反</p>
<p>儿sorted方法则相反，它会新建一个列表作为返回值，这个方法可以接受任何形式的可迭代对象作为参数，包括不可变序列或者生成器，但最终的返回结果都会是一个列表</p>
<ul>
<li>reverse参数，用来控制升序降序</li>
<li>key这个参数会被用在序列中的每个元素上，<code>key=str.lower</code>表示忽略大小写进行排序，<code>key=len</code>表示基于字符串长度的排序，默认值是恒等函数（identity function）表示用元素自己的值来排序</li>
</ul>
<h2 id="用bisect来管理已排序的序列"><a href="#用bisect来管理已排序的序列" class="headerlink" title="用bisect来管理已排序的序列"></a>用bisect来管理已排序的序列</h2><p>bisect 模块包含两个主要函数，bisect 和 insort，两个函数都利用二分查找算法来在有序序列中查找或插入元素。</p>
<h3 id="用bisect来搜索"><a href="#用bisect来搜索" class="headerlink" title="用bisect来搜索"></a>用bisect来搜索</h3><p><code>bisect(haystack, needle)</code>在haystack中找出needle的位置，即将needle插入返回的指针位置后序列仍然有序</p>
<p><code>haystack.insert(index, needle)</code>来进行元素的插入，也可以用insort一步到位，且速度更快一些</p>
<h3 id="用bisect-insort插入新元素"><a href="#用bisect-insort插入新元素" class="headerlink" title="用bisect.insort插入新元素"></a>用bisect.insort插入新元素</h3><p><code>insort(seq, item) </code>不同于上面两个方法，insort不要求序列本身有序，可以完成序列的排序和元素的插入，且让序列保持有序</p>
<h2 id="当列表不是首选"><a href="#当列表不是首选" class="headerlink" title="当列表不是首选"></a>当列表不是首选</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>当我们需要一个只包含数字的列表，那么array.array效率更高，且包含了效率更高的文件读写方法</p>
<h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p>memoryview 是一个内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。</p>
<p>不太好理解，这里给出的案例是，将一个有符号的数组，通过memoryview转化为一个无符号列表，然后去操作列表中的元素，这个时候原来的数组的内容也被修改了</p>
<h3 id="NumPy-和-SciPy"><a href="#NumPy-和-SciPy" class="headerlink" title="NumPy 和 SciPy"></a>NumPy 和 SciPy</h3><p>是两个很厉害的第三方库，主要提供高阶的多维数组和矩阵的操作</p>
<h3 id="双向队列和其他队列"><a href="#双向队列和其他队列" class="headerlink" title="双向队列和其他队列"></a>双向队列和其他队列</h3><p>首先如果我们使用list的append和pop方法可以把列表当做栈或者队列来用，但实际上向列表的首端添加数据的成本很大</p>
<p>collections.deque 类是一个双向队列，是一个线程安全的、可以快速从两端读写元素的数据类型；且deque可以设置队列长度，如果队列满了，还可以从反向端删除元素</p>
<p>queue提供线程安全的Queue、lifoQueue和PriorityQueue，不同的线程可以利用这些数据类型来交换信息，也支持设置最大值，不过区别是到了最大值之后是锁定入队操作而不是淘汰现有元素</p>
<p>multiprocessing与上面的queue比较类似，不过是设计用于进程间通信的。同时还有一个专门的multiprocessing.JoinableQueue 类型，可以让任务管理变得更方便。</p>
<p>asyncio基本涵盖了queue和multiprocessing，是专门为异步编程设计的</p>
<p>heapq跟上面三个模块不同的是，heapq 没有队列类，而是提供了heappush 和 heappop 方法，让用户可以把可变序列当作堆队列或者优先队列来使用。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>Python里面sorted方法的内置排序算法是timsort，这个算法的是Tim Peter在02年加入的Python，这哥们也是Python核心开发者，他贡献了太多的代码，以至于大家说他是人工智能Timbot，同时他也是==python之蝉==的作者，这本书也可以抽空看一看</p>
]]></content>
      <categories>
        <category>python</category>
        <category>流畅的Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>流畅的Python</tag>
      </tags>
  </entry>
  <entry>
    <title>hibernate -- hibernate故事会</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/hibernate/hibernate%E6%95%85%E4%BA%8B%E4%BC%9A/</url>
    <content><![CDATA[<p>hibernate故事会</p>
<p>2016年1月29日</p>
<p>9:34</p>
<p>关于id生成策略的故事： </p>
<p>“assigned”–主键由外部程序负责生成，在 save() 之前指定一个。 </p>
<p>“hilo”–通过hi/lo 算法实现的主键生成机制，需要额外的数据库表或字段提供高位值来源。 </p>
<p>“seqhilo”–与hilo 类似，通过hi/lo 算法实现的主键生成机制，需要数据库中的 Sequence，适用于支持 Sequence 的数据库，如Oracle。</p>
<p>“increment”–主键按数值顺序递增。此方式的实现机制为在当前应用实例中维持一个变量，以保存着当前的最大值，之后每次需要生成主键的时候将此值加1作为主键。这种方式可能产生的问题是：不能在集群下使用。</p>
<p>“identity”–采用数据库提供的主键生成机制。如DB2、SQL Server、MySQL 中的主键生成机制。</p>
<p>“sequence”–采用数据库提供的 sequence 机制生成主键。如 Oralce 中的Sequence。</p>
<p>“native”–由 Hibernate 根据使用的数据库自行判断采用 identity、hilo、sequence 其中一种作为主键生成方式。</p>
<p>“uuid.hex”–由 Hibernate 基于128 位 UUID 算法 生成16 进制数值（编码后以长度32 的字符串表示）作为主键。</p>
<p>“uuid.string”–与uuid.hex 类似，只是生成的主键未进行编码（长度16），不能应用在 PostgreSQL 数据库中。</p>
<p>“foreign”–使用另外一个相关联的对象的标识符作为主键。</p>
<p> </p>
<p> </p>
<p>关于日期类型的故事： </p>
<p>1、在java中代表时间和日期的类型有util包中的Date和Calendar</p>
<p>        在Jdbc中提供了Date的三个子类：java.sql.Date    java.sql.Time和java.sql.Timestamp分别和标准sql中的DATE,TIME,TIMESTAMP类型相对应</p>
<p>2.因为java中的Date是Jdbc中三个时间类的父类，所以它可以对应标准sql中的三种时间类型。</p>
<p>3.基于以上两点，我们在设置持久化类的是Date类型时，设置为java.util.Date.</p>
<p>4.那么我们如何才能把两者映射关联起来呢？</p>
<p>            在我们配置持久化类的映射文件时的property中配置，例如</p>
<p>            <property name="date" type="date"></property></p>
<p>                    <column name="DATE"></column></p>
<p>            </p>
<p>            </p>
<p>            <property name="date" type="time"></property></p>
<p>                    <column name="DATE"></column></p>
<p>            </p>
<p> </p>
<p>            <property name="date" type="timestamp"></property></p>
<p>                    <column name="DATE"></column></p>
<p>            </p>
<p> </p>
<p>mysql的事务隔离级别：</p>
<p>            事务隔离是个什么东西呢：当有两个事务在同时操作一个数据的时侯会产生冲突，比如一个事务读取了一个数据后另一个事务修改了这个数据，那这个时候前一个事务读的数据应该是什么呢？由此产生了事务隔离级别的概念，事务的隔离级别有4个，分别是：</p>
<p>                1.read  uncommitted  叫做读未提交内容：这个隔离级别表示每个事务都可以读取到别的事务未提交的内容，这个事务的隔离级别很少被真正的应用，我们想一下，瞎读别人还没有提交的内容显然不科学，会产生各种问题。</p>
<p>                2.read committed 叫做读提交内容：这个是大多数数据库的默认级别，但不是MySQL的默认级别，这个的意思是读取提交的内容。</p>
<p>                3.repeatable read 叫做可重读：这个是MySQL的默认级别，它确保同一事务的实例在并发读取数据是能看到同样的数据行。</p>
<p>                4.serializable 叫做可串行化：这个级别会要求事务排序，使他们能够不产生冲突，但明显这个级别会导致效率低下。</p>
<p>                由于事务的隔离级别不同会产生以下的典型问题：</p>
<p>                        脏读：一个事务更新了一个数据，另一个事务读取了这条数据后，原来的事务rollback了这个操作，导致后一个事务读取的数据不正确。</p>
<p>                        不可重复读：一个事务的两次查询的数据不一致，比如上面的情况。</p>
<p>                        幻读：同样是一个事务在两次查询中发现数据不一致。</p>
<p> </p>
<p>那么我们如何改变项目中默认的隔离级别呢：在hibernate的配置文件中，加入以下配置：</p>
<p>            <property name="connection.isolation">n&lt;&gt;  //n的取值为1,2,4,8分别对应上面的隔离级别</property></p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>hibernate -- hibernate笔记1</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/hibernate/hibernate%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>hibernate笔记1</p>
<p>2016年1月20日</p>
<p>13:33</p>
<p>hibernate配置</p>
<ol>
<li><p>导入hibernate的jar包</p>
</li>
<li><p>编写hibernate配置文件</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20</td>
<td>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;!DOCTYPE hibernate-configuration PUBLIC<br>        “-//Hibernate/Hibernate Configuration DTD 3.0//EN”<br>        “<a href="http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;">http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd&quot;</a>&gt;<br>&lt;hibernate-configuration&gt;<br>    &lt;session-factory&gt;<br>        &lt;!– 数据库的方言，每个数据库都有自己的方言 –&gt;<br>        &lt;property name=”dialect”&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;<br>        &lt;property name=”connection.url”&gt;jdbc:mysql://127.0.0.1:3306/hibernate&lt;/property&gt;<br>        &lt;property name=”connection.username”&gt;root&lt;/property&gt;<br>        &lt;property name=”connection.password”&gt;&lt;/property&gt;<br>        &lt;property name=”connection.driver_class”&gt;com.mysql.jdbc.Driver&lt;/property&gt;<br>        &lt;!– 是否在控制台输出对应的sql语句 –&gt;<br>        &lt;property name=”show_sql”&gt;true&lt;/property&gt;<br>        &lt;!– 数据库更新方案，update是更新，还有覆盖之类的东西，用到时候去查找 –&gt;<br>        &lt;property name=”hbm2ddl.auto”&gt;update&lt;/property&gt;<br>        &lt;!– 加载映射文件 –&gt;<br>        &lt;mapping resource=”com/firefly/hibernate/domain/First.hbm.xml”/&gt;<br>    &lt;/session-factory&gt;<br>&lt;/hibernate-configuration&gt;</td>
</tr>
</tbody></table>
<p>                以上的hbm2ddl.auto项有几个选择：</p>
<p>                        create-drop 在程序启动的时候创建对应的数据库表结构。当sessionFactory关闭时会将创建的表结构删除</p>
<p>                        create 在每次启动的时候都会去删除上次创建的表结构，然后再创建新的表结构</p>
<p>                        update在每次启动的时候都会追加修改的表结构，但是不会影响原来的数据（这个是常用的）</p>
<p>                        validate在每次启动的时候会验证并修改表结构</p>
<ol>
<li><p>编写实体类，并未实体类加载映射文件，记得倒回去修改配置文件中的加载映射文件语句。</p>
</li>
<li><p>编写java文件对数据库进行操作</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32</td>
<td>package com.firefly.hibernate.hibernate;<br> <br>import org.hibernate.Session;<br>import org.hibernate.SessionFactory;<br>import org.hibernate.Transaction;<br>import org.hibernate.cfg.Configuration;<br> <br>import com.firefly.hibernate.domain.First;<br> <br>public class News {<br>    public static void main(String[] args) throws Exception {<br>        //获得configuration对象<br>        Configuration conf = new Configuration().configure();<br>        //创建session工厂<br>        SessionFactory sf = conf.buildSessionFactory();<br>        //打开session<br>        Session sess = sf.openSession();<br>        //开始事务<br>        Transaction tx =sess.beginTransaction();<br>        First f = new First(); <br>        f.setId(1);<br>        f.setTitle(“我是第一条数据！”);<br>        f.setContent(“I’m content”);<br>        sess.save(f);<br>        //提交事务<br>        tx.commit();<br>        //关闭session<br>        sess.close();<br>        //关闭session工厂<br>        sf.close();<br>    }<br>}</td>
</tr>
</tbody></table>
<p>以上是向数据库中添加一条数据</p>
<p>        sessionFactory是在应用程序开始的时候创建的，可以被多个线程同时使用</p>
<p>        hibernate4之后SessionFactory的闯将方法有一些不同，以上的buildSessionFactory属于是已经过时的方法，我们在使用的时候会有一条横杠将他划上，表示不推荐使用，高逼格的方法为：</p>
<p>                    在获得configuration之后 ServiceRegistry sr = new ServiceRegistryBuilder().applySettings(configuration.getProperties()).buildServiceRegistry();</p>
<p>                    SessionFactory sf = configuratioin.buildSesionFactory(sr);</p>
<p>        关于事务：用  beginTransaction();      是开始事务，还有另一个方法是 getTransaction  表示获得与当前session关联的事务</p>
<p> </p>
<p>关于hibernate运行流程：</p>
<p>            hibernate的思想是将对关系型数据库的操作改变为符合java面向对象编程思想的操作。</p>
<p>            hibernate将数据库中的数据映射成为对象通过与实体类对应的映射文件实现；而对对象的操作是放在session容器中的，而session对象的获取是通过session工厂生产的，session工厂是通过configuration对象的来的，在获得configuration对象过程中关联了相关的实体类映射文件。</p>
<p> </p>
<p>hibernate的javabean的几个通用的要求：</p>
<p>    1.要有一个id，建议要使用封装类</p>
<p>    2.这个类不能是被final修饰</p>
<p>    3.需要有一个无参的构造器</p>
<p>    4.需要给所有属性提供getting/setting方法</p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>hibernate -- hibernate笔记2</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/hibernate/hibernate%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>hibernate笔记2</p>
<p>2016年1月29日</p>
<p>9:33</p>
<p>关于hibernate配置的故事：</p>
<p>        hibernate.cfg.xml（主配置文件）</p>
<p>                    1.数据库信息（方言，url，驱动，用户名，密码）</p>
<p>                    2.导入映射配置文件</p>
<p>                    3.其他配置</p>
<p>        domain.hbm.xml（映射文件）</p>
<p>                    普通属性</p>
<p>                    主键(关于主键id生成策略在故事会中有详细说明)</p>
<p>                    集合属性</p>
<p>                            集合属性让我们可以写一个实体类，对应数据库中的两个表</p>
<p>                            关于set的配置： </p>
<p>                                        User.java</p>
<p>                                        public class User {</p>
<p>                                         private Integer id;</p>
<p>                                         private String name;</p>
<p>                                         private Set<String> address = new HashSet<String>();</String></String></p>
<p>                                         public Integer getId() {</p>
<p>                                         return id;</p>
<p>                                         }</p>
<p>                                         public void setId(Integer id) {</p>
<p>                                         this.id = id;</p>
<p>                                         }</p>
<p>                                         public String getName() {</p>
<p>                                         return name;</p>
<p>                                         }</p>
<p>                                         public void setName(String name) {</p>
<p>                                         this.name = name;</p>
<p>                                         }</p>
<p>                                         public Set<String> getAddress() {</String></p>
<p>                                         return address;</p>
<p>                                         }</p>
<p>                                         public void setAddress(Set<String> address) {</String></p>
<p>                                         this.address = address;</p>
<p>                                         }</p>
<p>                                        }</p>
<p>                                        hibernate中的配置：</p>
<p>                                        <hibernate-mapping package="com.firefly.hibernate.domain"></hibernate-mapping></p>
<p>                                            <class name="User" table="USER"></class></p>
<p>                                                <id name="id" type="java.lang.Integer"></id></p>
<p>                                                    <column name="ID"></column></p>
<p>                                                    <generator class="increment"></generator></p>
<p>                                                </p>
<p>                                                <property name="name" type="java.lang.String"></property></p>
<p>                                                    <column name="NAME"></column></p>
<p>                                                </p>
<p>                                                </p>
<p>                                                <set name="Address" table="ADDRESS"></set></p>
<p>                                                 <key column="userId"></key></p>
<p>                                                 <element type="string" column="address"></element></p>
<p>                                                </p>
<p>                                            </p>
<p>                                        </p>
<p>                                通过以上配置就可以在数据库中生成一个address表，该表有一个userId对应为user表的外键</p>
<p>                    关联关系</p>
<p>                        一对一</p>
<p>                        多对多</p>
<p>                        一对多、多对一</p>
<p>                    继承结构</p>
<p>                    </p>
<p>        关于配置有很多的小故事，比如：我们在主配置文件中第二个小点是导入映射文件，然后我们在得到configuration时导入这个主配置文件，但我们也可以不在主配置文件中关联映射文件，而用configuration.addClass(javabean名);    这样它会到这个javabean的包下面去寻找同名的映射文件</p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。e 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>hibernate -- hibernate笔记3</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/hibernate/hibernate%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p>hibernate笔记3</p>
<p>2016年1月29日</p>
<p>9:34</p>
<p>关于session缓存</p>
<p>    session对象与数据库交流：</p>
<p>        flush方法：将session缓存中的对象内容保存到数据库中</p>
<p>        reflesh方法：将session缓存中的对象的内容与数据库同步</p>
<p>        clear方法：清除session缓存中的对象</p>
<p>        关于以上三个方法–正常在提交事务的时候回调用flush方法将对对象的更新保存到数据库中，但可以人为的调用该方法进行保存；如果我们在操作对象时数据库内容发生了变化，则可以通过reflesh对象进行刷新；clear即是清除session缓存中的对象。</p>
<p> </p>
<p>    session中对象的状态：临时 持久化   托管   删除</p>
<p> </p>
<p>            get和load方法的区别：get是即时获得对象，load是延时获得对象（托管对象，如果不使用不会立即执行查询操作）。</p>
<p>                        如果在调用了这两个方法后就关闭session对象，load则会出现LazyInitializationException异常。</p>
<p>                        如果数据表中不存在该记录，get会返回一个null对象，而load会报异常。</p>
<p>                        可以在表的映射文件中的class标签中用lazy选项配置，它的默认值为true，也就是表示load会延迟，改成false后就不再延迟</p>
<p>            save和persist的区别：save是为对象的id赋值，而在调用save方法前对对象ID的操作不会生效；如果是persist方法则会报异常。</p>
<p>            saveOrUpdate方法：如果对象的id已经存在了，就执行update，如果不存在就执行save。</p>
<p>            merge方法：当一个对象有id是当做游离对象处理，当该对象没有id是当做是临时对象处理，会根据id的生成策略来生成id，而这个方法比较特殊的地方在于，如果我们在关闭一个session之后有一个游离对象了，我们又在新的session里面试图获取第二个相同的对象并 持久化时，别的方法都会冲突，而merge会把后面一个的参数赋给前一个对象。</p>
<p> </p>
<p>    hibernate的三级缓存：</p>
<p>            一级缓存：一级缓存的生命周期很短和session的生命周期一致，所以人们也把一级缓存叫做session缓存</p>
<p>                            作用;减少数据库的访问，从内存中取数据的速度要远高于从数据库中取数据，当我们去关闭session时，session会把缓存中所有的数据与数据库同步，这时session会把所有的sql语句合成一条对数据库进行访问。</p>
<p>                            支持session缓存的方法有：get();    load();    iterate();</p>
<p>                                   </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>hibernate -- hibernate笔记4</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/hibernate/hibernate%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p>hibernate笔记4</p>
<p>2016年1月29日</p>
<p>9:34</p>
<p>hql语言（hibernate query language）hibernate查询语言：</p>
<p>            那么为什么我们有了sql语句还要去用hql语句呢：</p>
<p>                             1.sql语句在对不同是数据库时有一些差异，那么如果我们完成的项目要更换数据库时再去重写sql语句显然是很不方便的，而hql语句对所有数据库都是一致的。</p>
<p>                             2.hql语句是面向对象的操作，虽然它最终也是转换为sql语言，但是它明显更符合我们的思维</p>
<p>            一下为hql语句的一些具体应用:</p>
<p>                        from table；与sql的 select * from table；是一致的，当我们在查询该条数据的所有内容时省略select *，并且是必须省略，但也可以写成这样：  select t from table  as t;  as 是同义词关键字，可以省略，也就是说刚才的语句可以写成 select t from table t ; 这种写法在下面会大量出现。</p>
<p>   </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><br>1<br> <br>2<br> <br>3<br> <br>4<br> <br>5<br> <br>6<br></td>
<td><br>String hql =”select u  from User u”;<br> <br>Query  query = session.createQuery(hql);<br> <br>List&lt;User&gt;  list = query.list();<br> <br>for(User  u: list){<br> <br>    System.out.println(u);<br> <br>}<br></td>
</tr>
</tbody></table>
<p>                        </p>
<p>                       用uniqueResult修饰query表示查询的结果只有一个，为什么会有这个方法的出现呢，明显在上一个查询中我们用的是list来接收结果，但是当我们很明确我们要的结果只有一个时还用list就会导致，我们要先装进去再拿出来，这是很不明智的。</p>
<p> </p>
<p>   </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><br>1<br> <br>2<br> <br>3<br> <br>4<br></td>
<td><br>String hql =”from  User u where u.id=1”;<br> <br>Query  query = session.createQuery(hql);<br> <br>User  u = (User)query.uniqueResult();<br> <br>System.out.println(u);<br></td>
</tr>
</tbody></table>
<p>                     以上代码可格式化的简写为（每调用一个方法时就退行，方便阅读）：</p>
<p>   </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><br>1<br> <br>2<br> <br>3<br> <br>4<br></td>
<td><br>User  u = (User) session.createQuery(<br> <br>        “from User u where u.id=1”<br> <br>        ).uniqueResult();<br> <br>System.out.println(u);<br></td>
</tr>
</tbody></table>
<p>            </p>
<p>            设置有参数的查询：</p>
<p>   </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><br>1<br> <br>2<br> <br>3<br> <br>4<br> <br>5<br></td>
<td><br>User  u = (User) session.createQuery(<br> <br>                “from User u where u.id=?”<br> <br>                ).setParameter(0, 1)<br> <br>                .uniqueResult();<br> <br>System.out.println(u);<br></td>
</tr>
</tbody></table>
<p>    </p>
<p>        我们也可以通过hql语句直接对数据库进行更改和删除操作，与sql语句一样，这样它不会通知session</p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>hibernate</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis -- mybatis笔记1--搭配环境</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/mybatis/mybatis%E7%AC%94%E8%AE%B01--%E6%90%AD%E9%85%8D%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<ol>
<li><p>创建一个java项目</p>
</li>
<li><p>项目名Mybatis1</p>
</li>
<li><p>导入jar包：mybatis-3.2.8.jar、mysql-connector-java-5.0.7-bin.jar</p>
</li>
<li><p>创建一个配置文件mybatis_config.xml</p>
</li>
</ol>
<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE configuration

PUBLIC "-//mybatis.org//DTD Config 3.0//EN"

"http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>

<pre><code>&lt;environments default=&quot;development&quot;&gt;

    &lt;environment id=&quot;development&quot;&gt;

        &lt;transactionManager type=&quot;JDBC&quot;/&gt;

        &lt;dataSource type=&quot;POOLED&quot;&gt;

            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///firefly&quot;/&gt;

            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;

            &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;

        &lt;/dataSource&gt;

    &lt;/environment&gt;

&lt;/environments&gt;

&lt;mappers&gt;

    &lt;mapper resource=&quot;com/firefly/mybatis1/domain/userMapper.xml&quot;/&gt;

&lt;/mappers&gt;
</code></pre>
</configuration>

<ol>
<li>创建一个bean</li>
</ol>
<p>package com.firefly.mybatis1.domain;</p>
<p>public class User {</p>
<pre><code>private int id;

private String name;

private int age;

public int getId() &#123;

    return id;

&#125;

public void setId(int id) &#123;

    this.id = id;

&#125;

public String getName() &#123;

    return name;

&#125;

public void setName(String name) &#123;

    this.name = name;

&#125;

public int getAge() &#123;

    return age;

&#125;

public void setAge(int age) &#123;

    this.age = age;

&#125;

public String toString() &#123;

    return &quot;User [id=&quot; + id + &quot;, name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;

&#125;
</code></pre>
<p>}</p>
<ol>
<li><p>创建一个与bean对应的xml文件</p>
<?xml version="1.0" encoding="UTF-8" ?></li>
</ol>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.firefly.mybatis1.domain.userMapper">

<pre><code>&lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;com.firefly.mybatis1.domain.User&quot;&gt;

    select * from user where id=#&#123;a&#125;

&lt;/select&gt;
</code></pre>
</mapper>

<pre><code>&lt;/select&gt;
</code></pre>
<ol>
<li>创建 一个测试文件</li>
</ol>
<p>package com.firefly.mybatis1.test;</p>
<p>import java.io.IOException;</p>
<p>import java.io.InputStream;</p>
<p>import org.apache.ibatis.session.SqlSession;</p>
<p>import org.apache.ibatis.session.SqlSessionFactory;</p>
<p>import org.apache.ibatis.session.SqlSessionFactoryBuilder;</p>
<p>import com.firefly.mybatis1.domain.User;</p>
<p>public class Test {</p>
<pre><code>public static void main(String[] args) throws IOException &#123; 

    InputStream is = Test.class.getClassLoader().getResourceAsStream(&quot;mybatis_config.xml&quot;);

    SqlSessionFactory sf = new SqlSessionFactoryBuilder().build(is);

    SqlSession session = sf.openSession();

    String statement = &quot;com.firefly.mybatis1.domain.userMapper.getUser&quot;; 

    Integer i = new Integer(1);

    User user = (User) session.selectOne(statement, i);

    System.out.println(user);

&#125;
</code></pre>
<p>}</p>
<pre><code>    System.out.println(user);

&#125;
</code></pre>
<p>}</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis -- mybatis笔记2--crud的两种方法</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/mybatis/mybatis%E7%AC%94%E8%AE%B02--crud%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>通过xml文件进行CRUD</p>
<ol>
<li><p>创建一个java工程：mybatis2_CRUD、导入jar：com.springsource.org.junit-4.8.1.jar、junit-4.3.jar</p>
</li>
<li><p>mybatis配置文件</p>
</li>
</ol>
<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE configuration

PUBLIC "-//mybatis.org//DTD Config 3.0//EN"

"http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>

<pre><code>&lt;environments default=&quot;development&quot;&gt;

    &lt;environment id=&quot;development&quot;&gt;

        &lt;transactionManager type=&quot;JDBC&quot;/&gt;

        &lt;dataSource type=&quot;POOLED&quot;&gt;

            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;

            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///firefly&quot;/&gt;

            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;

            &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;

        &lt;/dataSource&gt;

    &lt;/environment&gt;

&lt;/environments&gt;

&lt;mappers&gt;

    &lt;mapper resource=&quot;com/firefly/mybatis2_crud/domain/userMapper.xml&quot;/&gt;
</code></pre>
<p>  <mapper class="com.firefly.mybatis2_crud.test1.UserMapper"></mapper></p>
<pre><code>&lt;/mappers&gt;
</code></pre>
</configuration>

<ol>
<li>实体类和它的mapper文件：实体类就是上一个项目的user</li>
</ol>
<?xml version="1.0" encoding="UTF-8" ?>

<mapper namespace="com.firefly.mybatis2_crud.domain.userMapper">

    

<pre><code>&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.firefly.mybatis2_crud.domain.User&quot;&gt;

    insert into user(name,age) value(#&#123;name&#125;,#&#123;age&#125;);

&lt;/insert&gt;



&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;

    delete from user where id=#&#123;id&#125;

&lt;/delete&gt;



&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.firefly.mybatis2_crud.domain.User&quot;&gt;

    update user set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;

&lt;/update&gt;



&lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;com.firefly.mybatis2_crud.domain.User&quot;&gt;

    select * from user where id=#&#123;a&#125;

&lt;/select&gt;



&lt;select id=&quot;getAllUser&quot; resultType=&quot;com.firefly.mybatis2_crud.domain.User&quot;&gt;

    select * from user

&lt;/select&gt;
</code></pre>
</mapper>

<ol>
<li>测试文件</li>
</ol>
<p>package com.firefly.mybatis2_crud.test;</p>
<p>import java.util.List;</p>
<p>import org.apache.ibatis.session.SqlSession;</p>
<p>import org.apache.ibatis.session.SqlSessionFactory;</p>
<p>import org.junit.Test;</p>
<p>import com.firefly.mybatis2_crud.domain.User;</p>
<p>import com.firelfy.mybatis2_crud.util.MybatisUtil;</p>
<p>public class TestCRUD {</p>
<pre><code>@Test

public void testAdd()&#123;

    SqlSessionFactory factory = MybatisUtil.getFactory();

    SqlSession session = factory.openSession();

    

    String state = &quot;com.firefly.mybatis2_crud.domain.userMapper.addUser&quot;;

    User user = new User(&quot;kk&quot;,23);

    int insert = session.insert(state,user);

    System.out.println(insert);

    session.commit();

    session.close();

&#125;



@Test

public void testUpdate()&#123;

    SqlSessionFactory factory = MybatisUtil.getFactory();

    SqlSession session = factory.openSession();

    

    String state = &quot;com.firefly.mybatis2_crud.domain.userMapper.updateUser&quot;;

    User user = new User(1,&quot;kk&quot;,23);

    int success = session.update(state,user);

    System.out.println(success);

    session.commit();

    session.close();

&#125;



@Test

public void testDelete()&#123;

    SqlSessionFactory factory = MybatisUtil.getFactory();

    SqlSession session = factory.openSession();

    

    String state = &quot;com.firefly.mybatis2_crud.domain.userMapper.deleteUser&quot;;

    Integer i = new Integer(3);

    int success = session.update(state,i);

    System.out.println(success);

    session.commit();

    session.close();

&#125;



@Test

public void testGetAll()&#123;

    SqlSessionFactory factory = MybatisUtil.getFactory();

    SqlSession session = factory.openSession();

    

    String state = &quot;com.firefly.mybatis2_crud.domain.userMapper.getAllUser&quot;;

    List&lt;User&gt; list = session.selectList(state); 

    System.out.println(list);

    session.commit();

    session.close();

&#125;
</code></pre>
<p>}</p>
<p>用注解的方法实现：</p>
<ol>
<li><p>还是刚才那个工程</p>
</li>
<li><p>新建一个包，test1，在下面创建一个接口</p>
</li>
</ol>
<p>package com.firefly.mybatis2_crud.test1;</p>
<p>import org.apache.ibatis.annotations.Delete;</p>
<p>import org.apache.ibatis.annotations.Insert;</p>
<p>import org.apache.ibatis.annotations.Select;</p>
<p>import org.apache.ibatis.annotations.Update;</p>
<p>import com.firefly.mybatis2_crud.domain.User;</p>
<p>public interface UserMapper {</p>
<pre><code>@Insert(&quot;insert into user(name,age) value(#&#123;name&#125;,#&#123;age&#125;);&quot;)

public int add(User user);

@Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)

public int deleteById(int id);

@Update(&quot;update user set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;&quot;)

public int update(User user);

@Select(&quot;select * from user where id=#&#123;a&#125;&quot;)

public User getById(int id);

@Select(&quot;select * from user&quot;)

public List&lt;User&gt; getAllUser();
</code></pre>
<p>}</p>
<ol>
<li><p>为我们的接口进行注册：在mybatis_config.xml中的<mappers>标签下加入<mapper class="com.firefly.mybatis2_crud.test1.UserMapper"></mapper></mappers></p>
</li>
<li><p>测试类</p>
</li>
</ol>
<p>package com.firefly.mybatis2_crud.test;</p>
<p>import org.apache.ibatis.session.SqlSession;</p>
<p>import org.apache.ibatis.session.SqlSessionFactory;</p>
<p>import com.firefly.mybatis2_crud.domain.User;</p>
<p>import com.firefly.mybatis2_crud.test1.UserMapper;</p>
<p>import com.firelfy.mybatis2_crud.util.MybatisUtil;</p>
<p>public class TestCRUD_ByAnnotation {</p>
<pre><code>@org.junit.Test

public void testAddUser()&#123;

    SqlSessionFactory factory = MybatisUtil.getFactory();

    SqlSession session = factory.openSession();

    

    UserMapper mapper = session.getMapper(UserMapper.class);

    User user = new User(&quot;hello&quot;, 12);

    int success = mapper.add(user);

    System.out.println(success);

    session.commit();

    session.close();

&#125;
</code></pre>
<p>}</p>
<ol>
<li><p>package com.firefly.mybatis2_crud.test;</p>
</li>
<li><pre><code>    SqlSession session = factory.openSession();
</code></pre>
</li>
<li><pre><code>    session.close();
</code></pre>
</li>
</ol>
<p>我们对以上的两种方法进行对比，当然注解要好使一些，编写简单y.mybatis2_crud.test;</p>
<ol>
<li><pre><code>    SqlSession session = factory.openSession();
</code></pre>
</li>
<li><pre><code>    session.close();
</code></pre>
</li>
</ol>
<p>我们对以上的两种方法进行对比，当然注解要好使一些，编写简单</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>spring -- Spring笔记1--入门helloworld项目</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/spring/Spring%E7%AC%94%E8%AE%B01--%E5%85%A5%E9%97%A8helloworld%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>Spring笔记1–入门helloworld项目</p>
<p>2016年1月29日</p>
<p>9:36</p>
<p>Spring笔记1–入门helloworld项目</p>
<p> </p>
<p>配置环境：到eclipse上install softwear中输入<a href="http://dist.springsource.com/release/TOOLS/update/e4.3/">http://dist.springsource.com/release/TOOLS/update/e4.3/</a></p>
<p>安装带spring IDE的4个部分，完成后重启eclipse</p>
<p>写一个HelloWorld项目：</p>
<p>1.创建一个名为Helloworld的java项目，在项目下创建一个叫做lib的文件夹，导入所需的jar包（5个），将其建立成一个libraries。</p>
<p>2.在src目录下创建com.firefly.spring.beans包，在里面创建一个HelloWorld.java文件，内容如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</td>
<td>package com.firefly.spring.beans;                <br>public class HelloWorld {                <br> private String name;                <br>  <br> public void setName(String name) {                <br>  this.name = name;                <br> }                <br>  public void hello(){                <br>  System.out.println(“hello:”+name);                <br> }                <br>}</td>
</tr>
</tbody></table>
<p> 3.创建配置文件：applicationContext.xml</p>
<p>?</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</td>
<td>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;                <br>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a>                <br> xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a>                <br> xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans.xsd&quot;">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</a>&gt;                <br>  <br>  <br> &lt;bean id=”helloWorld” class=”com.firefly.spring.beans.HelloWorld”&gt;                <br>  &lt;property name=”name” value=”Spring”&gt;&lt;/property&gt;                <br> &lt;/bean&gt;                <br>  <br>&lt;/beans&gt;</td>
</tr>
</tbody></table>
<p> 4.在com.firefly.spring.beans包中创建Main.java文件：</p>
<p>?</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>1</td>
<td>package com.firefly.spring.beans;                <br>import org.springframework.context.ApplicationContext;                <br>import org.springframework.context.support.ClassPathXmlApplicationContext;                <br>public class main {                <br>  <br> public static void main(String[] args){                <br> //创建spring容器                <br>  ApplicationContext ctx = new ClassPathXmlApplicationContext(“applicationContext.xml”);                <br>  //获得实例                <br>  HelloWorld helloWorld = (HelloWorld)ctx.getBean(“helloWorld”);                <br>  helloWorld.hello();                <br> }                <br>}</td>
</tr>
</tbody></table>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring -- Spring笔记4 工厂方法</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/spring/Spring%E7%AC%94%E8%AE%B04%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Spring笔记4 工厂方法</p>
<p>2016年1月29日</p>
<p>9:37</p>
<p>静态工厂方法：</p>
<p>Phone.java</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28</td>
<td>package com.firefly.spring.beans.factory;<br> <br>public class Phone {<br>    private String name;<br>    private int price;<br>    public Phone(String name) {<br>        super();<br>        this.name = name;<br>    }<br>    public Phone(String name, int price) {<br>        super();<br>        this.name = name;<br>        this.price = price;<br>    }<br>    public String getName() {<br>        return name;<br>    }<br>    public void setName(String name) {<br>        this.name = name;<br>    }<br>    public int getPrice() {<br>        return price;<br>    }<br>    public void setPrice(int price) {<br>        this.price = price;<br>    }<br> <br>}</td>
</tr>
</tbody></table>
<p>StaticPhoneFactory.java</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</td>
<td>package com.firefly.spring.beans.factory;<br> <br>import java.util.HashMap;<br>import java.util.Map;<br> <br>public class StaticPhoneFactroy {<br>    private static Map&lt;String,Phone&gt; phone =new HashMap&lt;String,Phone&gt;();<br> <br>    static{<br>        phone.put(“iphone”, new Phone(“iphone”,5000));<br>        phone.put(“xiaomi”, new Phone(“xiaomi”,2000));<br> <br>    }<br>    public static Phone getPhone(String name){<br>        return phone.get(name);<br>    }<br>}</td>
</tr>
</tbody></table>
<p>bean配置：</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4</td>
<td>&lt;bean id=”phone1” class=”com.firefly.spring.beans.factory.StaticPhoneFactroy”<br>    factory-method=”getPhone”&gt;<br>        &lt;constructor-arg  value=”iphone”&gt;&lt;/constructor-arg&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    factory-method来指定工厂方法，constructor-arg来给工厂方法赋值。</p>
<p>    以上静态工厂方法工作流程：在一个静态工厂类中先静态的配置好实例，并用map封装起来，在真正用bean创建实例的时候是以名字为钥匙找到对应的实例，用以创建对象；</p>
<p>    还有对应的动态工厂方法，只是它不用static修饰，在调用的时候才配置实例，原理与静态工厂相似。</p>
<p> </p>
<p>注解配置方法：~~</p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring -- Spring笔记5 AOP</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/spring/Spring%E7%AC%94%E8%AE%B05%20AOP/</url>
    <content><![CDATA[<p>Spring笔记5 AOP</p>
<p>2016年1月29日</p>
<p>9:37</p>
<p> </p>
<p>aop是什么：面向切面的编程（OOP是面向对象的编程）</p>
<p> </p>
<p>为什么要用aop：如果我们要写一个简单的计算器，核心的代码只有加减乘除四个方法，但是如果我们还想要有一些日志来提示使用者，这些提示对每个方法来说都是相近的，如果我们在每个方法里面都加上提示输出，就会让代码显得很冗余，而且不利于后期的更新和维护，而这种情况下我们就可以使用aop。</p>
<p> </p>
<p>首先我们用代理类的方法来实现这一功能：</p>
<p>CountIplm.java文件实现了Count.java接口（Iplm应该是Ipml，后来发现了不想改了）</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25</td>
<td>package com.firefly.spring.count;<br> <br>public class CountIplmimplements Count   {<br> <br>    public int add(inti, int j) {<br>        int result = i + j;<br>        return result;<br>    }<br> <br>    public int sub(inti, int j) {<br>        int result = i - j;<br>        return result;<br>    }<br> <br>    public int mul(inti, int j) {<br>        int result = i * j;<br>        return result;<br>    }<br> <br>    public int div(inti, int j) {<br>        int result = i / j;<br>        return result;<br>    }<br> <br>}</td>
</tr>
</tbody></table>
<p>代理类CountLoggingProxy.java</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40</td>
<td>package com.firefly.spring.count;<br> <br>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;<br>import java.util.Arrays;<br> <br>public class CountLogginProxy {<br>    //要代理的对象<br>    private Count target;<br> <br>    public CountLogginProxy(Count target2) {<br>        this.target = target2;<br>    }<br>    public Count getLoggingProxy(){<br>        Count proxy = null;<br> <br>        //代理对象由哪一个类加载器负责加载<br>        ClassLoader loader = target.getClass().getClassLoader();<br>        //代理对象的类型。即其中有哪些方法<br>        Class [] interfaces = new Class[]{Count.class};<br>        //当调用代理对象其中的方法时，该执行的代码<br>        InvocationHandler h = new InvocationHandler() {<br>            //正在返回的对象<br>            //method正在被调用的方法<br>            //arg2调用方法时传入的参数<br>            public Object invoke(Object arg0, Method arg1, Object[] arg2)<br>                    throws Throwable {<br>                StringmethodName = arg1.getName();<br>                System.out.println(“The method “+methodName+” begins with”+Arrays.asList(arg2));<br>                Objectresult = arg1.invoke(target, arg2);<br>                returnresult;<br>            }<br>        };<br> <br>        proxy = (Count)Proxy.newProxyInstance(loader, interfaces, h);<br>        return proxy;<br> <br>    }<br>}</td>
</tr>
</tbody></table>
<p>调用类Main.java</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</td>
<td>package com.firefly.spring.count;<br> <br>public class Main {<br> <br>    public static voidmain(String[] args) {<br> <br>        Count target =new CountIplm();<br>        Count proxy = new CountLogginProxy(target).getLoggingProxy();<br>        int result = proxy.add(1, 2);<br>        System.out.println(result);<br>    }<br> <br>}</td>
</tr>
</tbody></table>
<p>本来代理类与spring关系不大，可是java基础太烂记下来当是复习了。</p>
<p> </p>
<p>aop方法实现：</p>
<p>aop中的一些术语：</p>
<p>        切面：横切关注点，意会。。</p>
<p>        通知：切面必须完成的工作，例如例子中的打印日志提示。</p>
<p>        目标：被通知的对象，例子中4个不同的方法调用时生成的对象。</p>
<p>        代理：向目标对象应用通知后创建的对象，可以理解为被包装后的目标形成的新对象。</p>
<p>        连接点和切点以后详述。</p>
<p> </p>
<p>CountIplm.java文件实现了Count.java接口，与上面唯一的不同是要用@Component把类加入到IOC容器中。</p>
<p>LoggingAspect.java</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22</td>
<td>package com.firefly.spring.aop;<br> <br>import java.util.Arrays;<br>import java.util.List;<br> <br>import org.aspectj.lang.JoinPoint;<br>import org.aspectj.lang.annotation.Aspect;<br>import org.aspectj.lang.annotation.Before;<br>import org.springframework.stereotype.Component;<br> <br>//把这个类声明为一个切面：需要把该类放到IOC容器中，再声明为一个切面<br>@Aspect<br>@Component<br>public class LoggingAspect {<br>    //指定该方法在哪些类的哪些方法前执行<br>    @Before(“execution(public int com.firefly.spring.aop.Count.*(int,int))”)<br>    public void beforeMethod(JoinPoint joinpoint){<br>        String methodName = joinpoint.getSignature().getName();<br>        List&lt;Object&gt; args = Arrays.asList(joinpoint.getArgs());<br>        System.out.println(“The method “+methodName+” begins with “+args);<br>    }<br>}</td>
</tr>
</tbody></table>
<p>bean的配置代码：</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5</td>
<td>&lt;!– 自动扫描的包 –&gt;<br>&lt;context:component-scan base-package=”com.firefly.spring.aop”&gt;&lt;/context:component-scan&gt;<br> <br>&lt;!– 使aspject注解起作用：自动为匹配的类生成代理对象 –&gt;<br>&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</td>
</tr>
</tbody></table>
<p>调用的方法</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</td>
<td>package com.firefly.spring.aop;<br> <br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br> <br>public class Main {<br> <br>    public static voidmain(String[] args) {<br>        ApplicationContext ac = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        Count count = ac.getBean(Count.class);<br>        int result = count.add(2, 3);<br>        System.out.println(result);<br>        result = count.mul(2, 3);<br>        System.out.println(result);<br>    }<br> <br>}</td>
</tr>
</tbody></table>
<p>以上例子中用到了前置通知，相应的还有后置通知，@after在目标方法执行后执行，配置与前置通知相仿。</p>
<p>后置通知不论方法是否发生异常它都会被执行</p>
<p>后置通知还不能访问执行结果。</p>
<p>返回通知可以访问方法的返回结果，是在方法正常执行后执行，@AfterReturning（value=“execution（）”）配置</p>
<p>异常通知,程序出现异常时候调用，@AfterThrowing(value=“execution（）”)</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</td>
<td>@After(“execution(public int com.firefly.spring.aop.Count.*(..))”)<br>public void afterMethod(JoinPoint joinPoint){<br>    String methodName = joinPoint.getSignature().getName();<br>    System.out.println(“The method “+methodName+” end”);<br>}<br> <br>@AfterReturning(value=”execution(public int com.firefly.spring.aop.Count.*(..))”,returning=”result”)<br>public void afterReturning(JoinPoint joinPoint,Object result){<br>    String methodName = joinPoint.getSignature().getName();<br>    System.out.println(“The method “+methodName+” end with “+result);<br>}<br> <br>@AfterThrowing(value=”execution(public int com.firefly.spring.aop.Count.*(..))”,throwing=”e”)<br>public void afterThrowing(JoinPoint joinPoint,Exception e){<br>    String methodName = joinPoint.getSignature().getName();<br>    System.out.println(“The method “+methodName+” have exception “+e);<br>}</td>
</tr>
</tbody></table>
<p> </p>
<p>当有多个切面对同一个方法进行操作时，我们可以用@Order（n）来对切面设置优先级，n越小优先级越高。</p>
<p> </p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3</td>
<td>//使用@Pointcut来声明一个切入点表达式，一般的这个方法里面不需要再写别的代码<br>    @Pointcut(“execution(public int com.firefly.spring.aop.Count.*(..))”)<br>    public void flog(){}</td>
</tr>
</tbody></table>
<p>每次都去写切入点会很麻烦，所以我们把切入点写成一个表达式，用上面的方法，以后在配置的时候只要用flog就行了。</p>
<p> </p>
<p>一下为用文件配置AOP的方法</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</td>
<td>&lt;bean id=”count” class=”com.firefly.spring.aop.CountIplm”&gt;&lt;/bean&gt;<br> <br>    &lt;bean id=”loggingAspect” class=”com.firefly.spring.aop.LoggingAspect”&gt;&lt;/bean&gt;<br> <br>    &lt;!– 配置AOP –&gt;<br>    &lt;aop:config&gt;<br>        &lt;!– 配置切点表达式 –&gt;<br>        &lt;aop:pointcut expression=”execution(* com.firefly.spring.aop.Count.*(..))”<br>        id=”pointcut”/&gt;<br>        &lt;!– 配置切面通知 –&gt;<br>        &lt;aop:aspect ref=”loggingAspect” order=”2”&gt;<br>            &lt;aop:before method=”beforeMethod” pointcut-ref=”pointcut”/&gt;<br>            &lt;aop:after method=”afterMethod” pointcut-ref=”pointcut”/&gt;<br>            &lt;aop:after-throwing method=”afterThrowing” pointcut-ref=”pointcut” throwing=”e”/&gt;<br>            &lt;aop:after-returning method=”afterReturning” pointcut-ref=”pointcut” returning=”result”/&gt;<br>        &lt;/aop:aspect&gt;<br>    &lt;/aop:config&gt;</td>
</tr>
</tbody></table>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。rosoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring -- Spring笔记6 Jdbc</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/spring/Spring%E7%AC%94%E8%AE%B06%20Jdbc/</url>
    <content><![CDATA[<p>Spring笔记6 Jdbc</p>
<p>2016年1月29日</p>
<p>9:37</p>
<p>Spring 通过 JdbcTemplate对数据库进行操作</p>
<p> </p>
<p>以下是对bean的配置：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14</td>
<td>&lt;context:property-placeholder location=”classpath:db.propertise”/&gt;<br> <br>&lt;bean id=”dataSource” class=”com.mchange.v2.c3p0.ComboPooledDataSource”&gt;<br>    &lt;property name=”user” value=”${jdbc.user}”&gt;&lt;/property&gt;<br>    &lt;property name=”password” value=”${jdbc.password}”&gt;&lt;/property&gt;<br>    &lt;property name=”driverClass” value=”${jdbc.driverclass}”&gt;&lt;/property&gt;<br>    &lt;property name=”jdbcUrl” value=”${jdbc.jdbcurl}”&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br> <br>&lt;!– 配置Spring的JdbcTemplate –&gt;<br>&lt;bean id=”jdbcTemplate”<br>    class=”org.springframework.jdbc.core.JdbcTemplate”&gt;<br>    &lt;property name=”dataSource” ref=”dataSource”&gt;&lt;/property&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>Jdbc.java文件：</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46</td>
<td>package com.firefly.spring.jdbc;<br> <br>import java.sql.SQLException;<br> <br>import javax.sql.DataSource;<br> <br>import org.junit.Test;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>import org.springframework.jdbc.core.BeanPropertyRowMapper;<br>import org.springframework.jdbc.core.JdbcTemplate;<br>import org.springframework.jdbc.core.RowMapper;<br> <br>import com.firefly.spring.domain.User;<br> <br>public class Jdbc {<br>    private ApplicationContext ac = null;<br>    private JdbcTemplate jdbcTemplate;<br> <br>    {<br>        ac = new ClassPathXmlApplicationContext(“jdbcContext.xml”);<br>        jdbcTemplate = (JdbcTemplate)ac.getBean(“jdbcTemplate”);<br>    }<br> <br>    @Test<br>    public void testSelect(){<br>        String sql = “select id,name from user where id=?”;<br>        RowMapper&lt;User&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(User.class);<br>        User user = jdbcTemplate.queryForObject(sql, rowMapper,1);<br>        System.out.println(user);<br>    }<br> <br>     //以下方法用于实现对数据库的修改，即：插入，修改，删除操作<br> <br>    @Test<br>    public void testUpdate(){<br>        String sql = “UPDATE user SET  name=? where id=?”;<br>        jdbcTemplate.update(sql,”Tom”,1);<br>    }<br>    @Test<br>    public void testDataSource() throws SQLException {<br>        DataSource dataSource = ac.getBean(DataSource.class);<br>        System.out.println(dataSource.getConnection());<br>    }<br> <br>}</td>
</tr>
</tbody></table>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring -- spring笔记2 bean的配置</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/spring/spring%E7%AC%94%E8%AE%B02%20bean%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>spring笔记2 bean的配置</p>
<p>2016年1月29日</p>
<p>9:36</p>
<p>spring笔记 bean的配置</p>
<p>在SpringIOC读取bean配置创建bean实例之前，必须对它进行实例化，spring提供了两种类型的ioc容器实现：</p>
<p>    -BeanFactory是spring框架的基础设施，面向spring本身</p>
<p>    -ApplicationContext面向使用spring框架的开发者（基本只会用到这种方式，不会用到BeanFactory）</p>
<p>    无论使用的是哪种方法，配置文件时都是相同的</p>
<p> </p>
<p>    bean配置的具体属性：</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21</td>
<td>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;<br>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a><br>    xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a><br>    xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>   <a href="http://www.springframework.org/schema/beans/spring-beans.xsd&quot;">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</a>&gt;<br> <br> <br>    &lt;bean id=”helloWorld” class=”com.firefly.spring.beans.HelloWorld”&gt;<br>        &lt;property name=”name” value=”Spring”&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br> <br>    &lt;bean id=”Phone1” class=”com.firefly.spring.beans.Phone”&gt;<br>            &lt;constructor-arg value=”xiaomi” index=”0”&gt;&lt;/constructor-arg&gt;<br>            &lt;constructor-arg value=”5.5” type=”double”&gt;&lt;/constructor-arg&gt;<br>    &lt;/bean&gt;<br> <br>    &lt;bean id=”Phone2” class=”com.firefly.spring.beans.Phone”&gt;<br>            &lt;constructor-arg value=”iphone” index=”0”&gt;&lt;/constructor-arg&gt;<br>            &lt;constructor-arg value=”5500” type=”int”&gt;&lt;/constructor-arg&gt;<br>    &lt;/bean&gt;<br> <br>&lt;/beans&gt;</td>
</tr>
</tbody></table>
<p>    调用bean来得到实例的代码为：</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18</td>
<td>package com.firefly.spring.beans;<br> <br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br> <br>public class main {<br> <br>    public static voidmain(String[] args){<br>        ApplicationContext ctx = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        HelloWorld helloWorld = (HelloWorld)ctx.getBean(“helloWorld”);<br>        helloWorld.hello();<br>        Phone phone = (Phone)ctx.getBean(“Phone1”);<br>        System.out.println(phone);<br>        phone = (Phone)ctx.getBean(“Phone2”);<br>        System.out.println(phone);<br>    }<br> <br>}</td>
</tr>
</tbody></table>
<p>    id是为了调用的时候进行区分</p>
<p>    property是给实体类的成员赋值，name对应成员名，value是所需要的值，这种赋值方法必须要有对应的set方法在实体类中。</p>
<p>    constructor-arg是用于对应构造函数的赋值，用type属性区分不同的构造函数。</p>
<p>    </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6</td>
<td>&lt;bean id=”Phone1” class=”com.firefly.spring.beans.Phone”&gt;<br>            &lt;constructor-arg type=”java.lang.String”&gt;<br>                &lt;value&gt;&lt;![CDATA[&lt;xiaomi&gt;]]&gt;&lt;/value&gt;<br>            &lt;/constructor-arg&gt;<br>            &lt;constructor-arg value=”5.5” type=”double”&gt;&lt;/constructor-arg&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    如果赋值字段中包含了特殊字符，则用【CDATA【所需要的值】】包裹起来</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4</td>
<td>&lt;bean id=”man” class=”com.firefly.spring.beans.Man”&gt;<br>        &lt;property name=”name” value=””&gt;&lt;/property&gt;<br>        &lt;property name=”phone” ref=”Phone2”&gt;&lt;/property&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    ref属性可以实现bean之间的相互引用。</p>
<p> </p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</td>
<td>&lt;bean id=”man1” class=”com.firefly.spring.beans.Man”&gt;<br>        &lt;property name=”name” value=”firefly”&gt;&lt;/property&gt;<br>        &lt;property name=”phone”&gt;<br>            &lt;bean class=”com.firefly.spring.beans.Phone”&gt;<br>                &lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;<br>                &lt;constructor-arg value=”2000” type=”int”&gt;&lt;/constructor-arg&gt;<br>            &lt;/bean&gt;<br>        &lt;/property&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    以上为内部bean，<null>为赋值null的专用方法。</null></p>
<p> </p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</td>
<td>&lt;bean id=”man2” class=”com.firefly.spring.beans.collection.Man”&gt;<br>        &lt;property name=”name” value=”firefly”&gt;&lt;/property&gt;<br>        &lt;property name=”phone”&gt;<br>            &lt;list&gt;<br>                &lt;ref bean=”Phone1”/&gt;<br>                &lt;ref bean=”Phone2”/&gt;<br>            &lt;/list&gt;<br>        &lt;/property&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    配置当成员变量为集合时。</p>
<p> </p>
<p> </p>
<p>        对map的配置</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</td>
<td>&lt;util:list id=”phones”&gt;<br>    &lt;ref bean=”Phone1”/&gt;<br>    &lt;ref bean=”Phone2”/&gt;<br>&lt;/util:list&gt;<br> <br>&lt;bean id=”man3” class=”com.firefly.spring.beans.collection.Man”&gt;<br>    &lt;property name=”name” value=”firefly”&gt;&lt;/property&gt;<br>    &lt;property name=”phone” ref=”phones”&gt;&lt;/property&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    用util标签将对集合的配置独立出来，以便于多个bean引用，要导入util命名空间包。</p>
<p> </p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4</td>
<td>&lt;!– 通过P命名空间进行配置 –&gt;<br>    &lt;bean id=”man4” class=”com.firefly.spring.beans.collection.Man”<br>        p:name=”fire” p:phone-ref=”phones”<br>    &gt;&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>        通过P命名空间进行配置，要先导入P命名空间包。</p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring -- spring笔记3 bean的自动装配：</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/spring/spring%E7%AC%94%E8%AE%B03%20bean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%9A/</url>
    <content><![CDATA[<p>spring笔记3 bean的自动装配：</p>
<p>2016年1月29日</p>
<p>9:37</p>
<p> </p>
<p>spring笔记 bean的自动装配：</p>
<p>    </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15</td>
<td>&lt;bean id=”car” class=”com.firefly.spring.beans.autowire.Car”<br>    p:name=”baoma” p:price=”300000”<br>&gt;&lt;/bean&gt;<br> <br>&lt;bean id=”phone” class=”com.firefly.spring.beans.autowire.Phone”<br>p:name=”iphone” p:price=”4000”<br>&gt;&lt;/bean&gt;<br> <br>&lt;bean id=”person” class=”com.firefly.spring.beans.autowire.Person”<br>    p:name=”test” p:car-ref=”car” p:phone-ref=”phone”<br>&gt;&lt;/bean&gt;<br> <br>&lt;bean id=”person1” class=”com.firefly.spring.beans.autowire.Person”<br>    p:name=”test” autowire=”byName”<br>&gt;&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    运用autowire方法进行自动装配，byName-根据名字进行自动装配，byType-根据类型进行自动装配（基本不用，因为容易冲突）</p>
<p>    实际上，自动装配这种方法我们很少会用到，总不如自己制定填充明了。</p>
<p> </p>
<p>bean之间的关系：继承与依赖</p>
<p> </p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11</td>
<td>&lt;bean id=”sword” class=”com.firefly.spring.beans.relation.Sword”<br>    p:brand=”破败王者之刃” p:size=”100”<br>&gt;&lt;/bean&gt;<br> <br>&lt;bean id=”person” class=”com.firefly.spring.beans.relation.Person”<br>    p:name=”akali” p:age=”18” abstract=”true”<br>&gt;&lt;/bean&gt;<br> <br>&lt;bean id=”person1” class=”com.firefly.spring.beans.relation.Person”<br>    parent=”person” depends-on=”sword”<br>&gt;&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    person1继承person，用abstract修饰了的bean不能被用于创建实例，与抽象类相似；person1依赖sword，如果sword不存在，虚拟机会抛出异常。</p>
<p> </p>
<p>bean的作用域</p>
<p> </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3</td>
<td>&lt;bean id=”person2” class=”com.firefly.spring.beans.relation.Person”<br>    parent=”person” scope=”prototype”<br>&gt;&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>    scope的默认值为singleton：它是单例的，在容器 初始化的时候创建bean实例，整个容器的生命周期中，它只会被创建一次。</p>
<p>                               prototype：原型，它在每次请求是都创建一个新的bean，并返回。</p>
<p> </p>
<p>bean内引用外部配置文件</p>
<p>db.propertise的代码为：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4</td>
<td>user=root<br>password=root<br>driverclass=com.mysql.jdbc.Driver<br>jdbcurl=jdbc:mysql:///test</td>
</tr>
</tbody></table>
<p>bean引用外部文件的代码为：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8</td>
<td>&lt;context:property-placeholder location=”classpath:db.propertise”/&gt;<br> <br>&lt;bean id=”dataSource” class=”com.mchange.v2.c3p0.ComboPooledDataSource”&gt;<br>    &lt;property name=”user” value=”${user}”&gt;&lt;/property&gt;<br>    &lt;property name=”password” value=”${password}”&gt;&lt;/property&gt;<br>    &lt;property name=”driverClass” value=”${driverclass}”&gt;&lt;/property&gt;<br>    &lt;property name=”jdbcUrl” value=”${jdbcurl}”&gt;&lt;/property&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>因为有的配置，像上面例子中对数据库连接的配置那样的，在真正发布的时候需要进行修改，如果全都配置在bean中，你要从许多的bean中去寻找，显然是不方便的。所以用一个配置文件将它独立出来，以便于修改。</p>
<p> </p>
<p>spring中的spel：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1<br>2<br>3<br>4<br>5<br>6<br>7</td>
<td>&lt;bean id=”phone” class=”com.firefly.spring.beans.spel.Phone” p:price=”5500”&gt;&lt;/bean&gt;<br> <br>&lt;bean id=”person” class=”com.firefly.spring.beans.spel.Person”<br>    p:name=”Tom”  p:statue=”#{phone.price&gt;5000?’土豪’:’屌丝’}”<br>&gt;<br>    &lt;property name=”phone” value=”#{phone}”&gt;&lt;/property&gt;<br>&lt;/bean&gt;</td>
</tr>
</tbody></table>
<p>spel是spring的一种特殊语法，与el表达式类似。</p>
<p>格式为：#{}  将内容写在大括号里，可以写运算符，可以用于bean之间的相互引用。</p>
<p> </p>
<p>bean的生命周期，与以前action的生命周期相似</p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc -- springMVC各jar作用</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/springmvc/springMVC%E5%90%84jar%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li>springMVC3与jdk1.8不兼容</li>
</ol>
<ol>
<li>jar的作用</li>
</ol>
<p>(1) spring-core.jar这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，</p>
<p>当然你也可以在自己的应用系统中使用这些工具类。</p>
<p>(2) spring-beans.jar 这个jar文件是所有应用都要用到的，</p>
<p>它包含访问配置文件、创建和管理bean以及进行Inversion of Control / Dependency Injection（IoC/DI）操作相关的所有类。</p>
<p>如果应用只需基本的IoC/DI支持，引入spring-core.jar及spring-beans.jar文件就可以了。</p>
<p>(3) spring-aop.jar这个jar文件包含在应用中使用Spring的AOP特性时所需的类。</p>
<p>使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。</p>
<p>(4) spring-context.jar　　这个jar文件为Spring核心提供了大量扩展。可以找到使用Spring ApplicationContext特性时所需的全部类，</p>
<p>JDNI所需的全部类，UI方面的用来与模板（Templating）引擎如Velocity、FreeMarker、JasperReports集成的类，以及校验Validation方面的相关类。</p>
<p>(5) spring-dao.jar　　这个jar文件包含Spring DAO、Spring Transaction进行数据访问的所有类。</p>
<p>为了使用声明型事务支持，还需在自己的应用里包含spring-aop.jar。</p>
<p>(6) spring-hibernate.jar　　这个jar文件包含Spring对Hibernate 2及Hibernate 3进行封装的所有类。</p>
<p>(7) spring-jdbc.jar　　这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。</p>
<p>(8) spring-orm.jar　　这个jar文件包含Spring对DAO特性集进行了扩展，使其支持 iBATIS、JDO、OJB、TopLink，因为Hibernate已经独立成包了，现在不包含在这个包里了。</p>
<p>这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含spring-dao.jar包。</p>
<p>(9) spring-remoting.jar　　这个jar文件包含支持EJB、JMS、远程调用Remoting（RMI、Hessian、Burlap、Http Invoker、JAX-RPC）方面的类。</p>
<p>(10) spring-support.jar　　这个jar文件包含支持缓存Cache（ehcache）、JCA、JMX、邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类。</p>
<p>(11) spring-web.jar　　这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，</p>
<p>包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。</p>
<p>(12) spring-webmvc.jar　　这个jar文件包含Spring MVC框架相关的所有类。</p>
<p>    包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。</p>
<p>    当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。</p>
<p>    </p>
<p>(13) spring-mock.jar　　</p>
<p>    这个jar文件包含Spring一整套mock类来辅助应用的测试。Spring测试套件使用了其中大量mock类，这样测试就更加简单。</p>
<p>    模拟HttpServletRequest和HttpServletResponse类在Web应用单元测试是很方便的。　</p>
<p>　</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc -- springMVC笔记1--HelloWorld</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/springmvc/springMVC%E7%AC%94%E8%AE%B01--HelloWorld/</url>
    <content><![CDATA[<ol>
<li><p>环境配置：</p>
</li>
<li><p>创建项目SpringMVC1</p>
</li>
<li><p>导入jar包，添加web.xml和springMVC-servle.xml到WEB-INF下</p>
</li>
<li><p>web.xml</p>
</li>
</ol>
<?xml version="1.0" encoding="UTF-8"?>

<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemalocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5">

<p>  <display-name>SpringMVC1</display-name></p>
<p>  <welcome-file-list></welcome-file-list></p>
<p>    <welcome-file>index.html</welcome-file></p>
<p>    <welcome-file>index.htm</welcome-file></p>
<p>    <welcome-file>index.jsp</welcome-file></p>
<p>    <welcome-file>default.html</welcome-file></p>
<p>    <welcome-file>default.htm</welcome-file></p>
<p>    <welcome-file>default.jsp</welcome-file></p>
<p>  </p>
<p>  <servlet></servlet></p>
<p>    <servlet-name>springMVC</servlet-name></p>
<p>    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class></p>
<p>        <init-param></init-param></p>
<p>            <param-name>contextConfigLocation</param-name></p>
<p>            <param-value>classpath:com/firefly/springmvc1/config/spring-servlet.xml</param-value></p>
<p>        </p>
<p>    <load-on-startup>1</load-on-startup></p>
<p>  </p>
<p>  <servlet-mapping></servlet-mapping></p>
<p>    <servlet-name>springMVC</servlet-name></p>
<p>    <url-pattern>/</url-pattern></p>
<p>  </p>
</web-app>

<ol>
<li>springMVC-servlet.xml</li>
</ol>
<?xml version="1.0" encoding="UTF-8"?>

<p>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a>  </p>
<p> xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a>  </p>
<p> xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;">http://www.springframework.org/schema/p&quot;</a>  </p>
<p> xmlns:mvc=”<a href="http://www.springframework.org/schema/mvc&quot;">http://www.springframework.org/schema/mvc&quot;</a>  </p>
<p> xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a>  </p>
<p> xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>  </p>
<p>      <a href="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</a>  </p>
<p>      <a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>  </p>
<p>      <a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a>  </p>
<p>      <a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a>  </p>
<p>      <a href="http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt;">http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt;</a></p>
<p>    </p>
<p>    <bean name="/welcome" class="com.firefly.springmvc.controller.HelloWorld"></bean></p>
<p>    </p>
<pre><code>&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;

    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/content/&quot;&gt;&lt;/property&gt;

    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;

&lt;/bean&gt;
</code></pre>
<p>   </p>
<ol>
<li>创建controller层</li>
</ol>
<p>package com.firefly.springmvc1.controller;</p>
<p>import java.util.HashMap;</p>
<p>import java.util.Map;</p>
<p>import javax.servlet.http.HttpServletRequest;</p>
<p>import javax.servlet.http.HttpServletResponse;</p>
<p>import org.springframework.web.servlet.ModelAndView;</p>
<p>import org.springframework.web.servlet.mvc.Controller;</p>
<p>public class HelloWorld implements Controller{</p>
<pre><code>public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123;

    System.out.println(&quot;-----hello mvc-----&quot;);

    ModelAndView mv = new ModelAndView();

    mv.addObject(&quot;msg&quot;,&quot;hello springmvc&quot;);

    mv.setViewName(&quot;welcome&quot;);

    return mv;

&#125;
</code></pre>
<p>}</p>
<ol>
<li><p>创建welcome.jsp文件</p>
</li>
<li><p>运行测试：输入welcome</p>
</li>
<li><p>可能遇到的问题</p>
</li>
<li><p>springMVC的xml文件报错，有可能是与以前的spring的xml文件版本的不同，eclipse自动保存了xml版本的信息，清理方法：window-&gt;preferences-&gt;general-&gt;network connections-&gt;cache,将里面所有的东西都移除掉</p>
</li>
<li><p>启动tomcat时找不到springMVC的xml，检查xml的名字</p>
</li>
</ol>
]]></content>
      <categories>
        <category>web框架</category>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc -- springMVC笔记2--基于注解的实现</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/springmvc/springMVC%E7%AC%94%E8%AE%B02--%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>spirngmvc 与spring相似支持以注解的方法实现自己的功能，老何曾经问什么叫做低侵入性的框架，回答是我们要引进框架自己的jar包，这是不可避免的，但是我们只是用他们实现功能，并不去继承jar包中的类，之前的框架中没有注意这个事情，基本都去继承了某个类，这里我们可以通过注解代替继承</p>
<ol>
<li><p>创建工程：SpringMVC2、导入jar</p>
</li>
<li><p>web.xml      与helloworld实例的配置相同</p>
</li>
<li><p>spring-servlet.xml</p>
</li>
</ol>
<?xml version="1.0" encoding="UTF-8"?>

<p>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a>  </p>
<p> xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a>  </p>
<p> xmlns:p=”<a href="http://www.springframework.org/schema/p&quot;">http://www.springframework.org/schema/p&quot;</a>  </p>
<p> xmlns:mvc=”<a href="http://www.springframework.org/schema/mvc&quot;">http://www.springframework.org/schema/mvc&quot;</a>  </p>
<p> xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;">http://www.w3.org/2001/XMLSchema-instance&quot;</a>  </p>
<p> xsi:schemaLocation=”<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>  </p>
<p>      <a href="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</a>  </p>
<p>      <a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>  </p>
<p>      <a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a>  </p>
<p>      <a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a>  </p>
<p>      <a href="http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt;">http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd&quot;&gt;</a></p>
<p>     </p>
<p>    &lt;context:component-scan base-package=”com.firefly.springmvc2.controller”&gt;</p>
<p>    <a href="mvc:annotation-driven/">mvc:annotation-driven/</a></p>
<p>     </p>
<p>    <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"></bean></p>
<p>    <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"></bean></p>
<p>      </p>
<p>    <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"></bean></p>
<pre><code>    &lt;property name=&quot;prefix&quot; value=&quot;/jspPage/&quot;&gt;&lt;/property&gt;

    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;

&lt;/bean&gt;
</code></pre>
<p>     </p>
<p>    </p>
<p>   </p>
<ol>
<li><p>说一下这个配置文件中的坑吧，我花了一整天的时间就在这个配置文件这过不去，首先我们已经是决定用注解编程了就不要再写一个controller的bean了</p>
</li>
<li><p>其次<a href="mvc:annotation-driven/">mvc:annotation-driven/</a>这个东西比较奇葩，框架要求我们要配置两个东西：HandlerMapping和HandlerAdapter，这两个东西是为了连接注解中的@controller；我在上面也配置了，但是不知道是在哪里出了问题，反正那两个东西没有生效，而我是不知道的，这个语句会自动帮我们配置这两个东西，并且在后面要与ajax结合是还会用到</p>
</li>
<li><p>然后springMVC3与jdk1.8不兼容</p>
<p>   4.WelcomeController.java</p>
</li>
</ol>
<p>package com.firefly.springmvc2.controller;</p>
<p>import javax.servlet.http.HttpServletRequest;</p>
<p>import javax.servlet.http.HttpServletResponse;</p>
<p>import org.springframework.stereotype.Controller;</p>
<p>import org.springframework.web.bind.annotation.RequestMapping;</p>
<p>import org.springframework.web.servlet.ModelAndView;</p>
<p>@Controller </p>
<p>@RequestMapping(“/welcome”)</p>
<p>public class WelcomeController{</p>
<pre><code>@RequestMapping(&quot;/welcome&quot;)

public ModelAndView welcome(HttpServletRequest arg0, HttpServletResponse arg1)&#123;

    System.out.println(&quot;---mvc---&quot;);

    ModelAndView mv = new ModelAndView();

    mv.addObject(&quot;welcome&quot;,&quot;welcome to springmvc2&quot;);

    mv.setViewName(&quot;welcome&quot;);

    return mv; 

&#125;
</code></pre>
<ol>
<li>}</li>
</ol>
<p>5.编写jsp</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc -- springMVC笔记3--controller到jsp的故事</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/springmvc/springMVC%E7%AC%94%E8%AE%B03--controller%E5%88%B0jsp%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<p>创建项目，配置与注解实现时相同，只是将spring-servlet.xml中的视图渲染器去除</p>
<p>package com.firefly.springmvc3.controller;</p>
<p>import java.io.IOException;</p>
<p>import javax.servlet.ServletException;</p>
<p>import javax.servlet.http.HttpServletRequest;</p>
<p>import javax.servlet.http.HttpServletResponse;</p>
<p>import org.springframework.stereotype.Controller;</p>
<p>import org.springframework.web.bind.annotation.RequestMapping;</p>
<p>@Controller</p>
<p>public class WelcomeController {</p>
<pre><code>@RequestMapping(&quot;/welcome&quot;)

public void welcome(HttpServletRequest req,HttpServletResponse resp) throws IOException, ServletException&#123;

    //用servlet跳转

    //resp.getWriter().println(&quot;use spring mvc httpservlet api&quot;);

    resp.sendRedirect(&quot;redirect.jsp&quot;);
</code></pre>
<p>  </p>
<pre><code>    //req.setAttribute(&quot;msg&quot;, &quot;spring mvc api&quot;);

    //req.getRequestDispatcher(&quot;redirect.jsp&quot;).forward(req, resp);

&#125;

@RequestMapping(&quot;/hello&quot;)

public String hello()&#123;
</code></pre>
<p>//用springmvc跳转</p>
<pre><code>    return &quot;redirect:redirect.jsp&quot;;

    //return &quot;redirect.jsp&quot;;

&#125; 
</code></pre>
<p>}</p>
<p>注意上面的案例中，分别通过servlet的request和response以及springmvc的方法来进行了跳转，并且分别实现了转发和重定向</p>
<hr>
<p>数据处理：</p>
<p>向一个controller传递数据：</p>
<p>   请求： <a href="http://localhost:8080/SpringMVC3/date?name=luoyang">http://localhost:8080/SpringMVC3/date?name=luoyang</a></p>
<p>    接收：</p>
<p>package com.firefly.springmvc3.controller;</p>
<p>import org.springframework.stereotype.Controller;</p>
<p>import org.springframework.web.bind.annotation.RequestMapping;</p>
<p>@Controller</p>
<p>public class DateController {</p>
<pre><code>@RequestMapping(&quot;/date&quot;)

public String date(String name)&#123;

    System.out.println(name);

    return &quot;redirect.jsp&quot;;

&#125;
</code></pre>
<p>}</p>
<p>    以上date是controller 处理器的方法，后面接我们想要的参数，当传递的参数与接收方法的参数相同时，就可以接收数据了；</p>
<p>上面的案例中参数相同，下面是参数不相同的案例：</p>
<p>    请求:<a href="http://localhost:8080/SpringMVC3/date1?userName=luoyang">http://localhost:8080/SpringMVC3/date1?userName=luoyang</a></p>
<p>    接收:</p>
<p>@RequestMapping(“/date1”)</p>
<pre><code>public String date1(@RequestParam(&quot;userName&quot;)String name)&#123;

    System.out.println(name);

    return &quot;redirect.jsp&quot;;

&#125;
</code></pre>
<p>上面配置中的userName是提交的域的名称</p>
<p>传递数据为一个对象时：</p>
<p>    请求：<a href="http://localhost:8080/SpringMVC3/user?name=liuxuliu&amp;password=123">http://localhost:8080/SpringMVC3/user?name=liuxuliu&amp;password=123</a></p>
<p>    接收：</p>
<p>@RequestMapping(“/user”)</p>
<pre><code>public String user(User user)&#123;

    System.out.println(user);

    return &quot;redirect.jsp&quot;;

&#125;
</code></pre>
<p>以上为提交一个对象的情况，当然我们要创建一个User.java的bean，这里就不加代码了；</p>
<hr>
<p>controller向视图传递数据：</p>
<p>    第一种方法：ModelAndView，这个方法就是HelloWorld项目中的方法，需要一个视图解析器</p>
<p>    第二种方法：通过ModelMap</p>
<p>@RequestMapping(“toJsp”)</p>
<pre><code>public String toJsp(String name,ModelMap model)&#123;

    model.addAttribute(&quot;name&quot;,name);

    System.out.println(name);

    return &quot;redirect.jsp&quot;;

&#125;
</code></pre>
<p>    这种方法需要将ModelMap作为处理方法的参数</p>
<p>对以上两种方法的对比：</p>
<p>    共同点：当然就是都用来传递参数給视图</p>
<p>    不同点：ModelAndView自己就包含了跳转的视图的信息，但是需要一个解析器来解析；</p>
<p>                   ModelMap相当于就是封装了一个map，它需要程序指定要跳转的目标，但是不需要解析器；</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>springmvc -- springMVC笔记4--文件的上传</title>
    <url>/2023/04/13/web%E6%A1%86%E6%9E%B6/springmvc/springMVC%E7%AC%94%E8%AE%B04--%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>新建一个项目，配置环境</p>
<p>写一个jsp</p>
<p>&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8”</p>
<p>    pageEncoding=”UTF-8”%&gt;</p>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>

<head>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Insert title here</title>

</head>

<body>

<pre><code>&lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;

    file&lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;

    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt;

&lt;/form&gt;
</code></pre>
</body>

</html>

<p>编写controller</p>
<p>package com.firefly.springmvc4.controller;</p>
<p>import java.io.File;</p>
<p>import java.io.FileOutputStream;</p>
<p>import java.io.IOException;</p>
<p>import java.io.InputStream;</p>
<p>import java.io.OutputStream;</p>
<p>import javax.servlet.http.HttpServletRequest;</p>
<p>import org.springframework.stereotype.Controller;</p>
<p>import org.springframework.web.bind.annotation.RequestMapping;</p>
<p>import org.springframework.web.bind.annotation.RequestParam;</p>
<p>import org.springframework.web.multipart.commons.CommonsMultipartFile;</p>
<p>@Controller</p>
<p>public class FileuploadController {</p>
<pre><code>@RequestMapping(&quot;/jspPage/upload&quot;)

public String upload(@RequestParam(&quot;file&quot;)CommonsMultipartFile file,HttpServletRequest req) throws IOException&#123;

    String path = req.getRealPath(&quot;/upload&quot;);

    InputStream is = file.getInputStream();

    OutputStream os = new FileOutputStream(new File(path,file.getOriginalFilename()));

    int len = 0;

    byte[] buffer = new byte[400];

    while((len = is.read(buffer))!=-1)

        os.write(buffer, 0, len);

    os.close();

    is.close();

    return &quot;/jspPage/show.jsp&quot;;

&#125;
</code></pre>
<p>}</p>
<p>没明白这个故事是怎么回事</p>
]]></content>
      <categories>
        <category>web框架</category>
        <category>springmvc</category>
      </categories>
      <tags>
        <tag>web框架</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>linux -- CentOS配置（阿里云服务器）</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/CentOS%E9%85%8D%E7%BD%AE%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><h3 id="python3"><a href="#python3" class="headerlink" title="python3"></a>python3</h3><p>现在的服务器是centOS7，默认python版本为2.7，需要安装python3</p>
<ul>
<li><a href="https://blog.csdn.net/lovefengruoqing/article/details/79284573">安装教程</a></li>
<li>这个过程大概是先安装pip，用pip安装了wget，用wget下载python3的源码包，解压安装配置</li>
<li>安装完成后python命令被指向了python3.6版本，但实际上我习惯了用python3，只要执行：ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3  创建一个python3的软链就行了</li>
<li>添加pip3的软链：ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</li>
<li>注意安装过程中最好不要把python链接到python3，最好直接创建一个python3去链接，系统有些服务的引用是python，而他们需要的是python2，如果把python指向了python3可能会出问题</li>
<li>添加pip3的软链<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3</span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在国外的服务器上搭建ss服务"><a href="#在国外的服务器上搭建ss服务" class="headerlink" title="在国外的服务器上搭建ss服务"></a>在国外的服务器上搭建ss服务</h3><ul>
<li>在~目录下创建并切换到shadowsocks目录</li>
<li>执行：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget –no-check-certificate  https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">./shadowsocks.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks.log</span><br></pre></td></tr></table></figure></li>
<li>这里需要配置ss服务的参数：密码、端口、加密方式（建议使用aes-256-cfb）</li>
<li>最后界面上回显示红色标记的内容就是ss的连接信息了</li>
</ul>
<h3 id="shadowsocks全局翻墙-旧版"><a href="#shadowsocks全局翻墙-旧版" class="headerlink" title="shadowsocks全局翻墙(旧版)"></a>shadowsocks全局翻墙(旧版)</h3><ul>
<li><a href="https://i.jakeyu.top/2017/03/16/centos%E4%BD%BF%E7%94%A8SS%E7%BF%BB%E5%A2%99/">安装教程</a></li>
<li>可能会遇到用sslocal的时候命令行找不到该命令，全局搜一下这个文件的路径，我的在python3下面的，然后把sslocal和 ssserver都复制到/bin目录去就ok了</li>
<li>将别名写到~/.bashrc里面，不然每次会话结束别名就失效了，写完之后用source ~/.bashrc，能让它立即生效</li>
<li>zsh的时候需要写到~/.bash_profile里面同样source执行，这个配置文件应该是全局的，上面那个只对bash这个shell生效</li>
<li>跟着教程完成安装后执行ssinit初始化shadowsocks，执行sson运行shadowsocks，执行ssoff关闭</li>
</ul>
<h3 id="全局翻墙（新版）"><a href="#全局翻墙（新版）" class="headerlink" title="全局翻墙（新版）"></a>全局翻墙（新版）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--下载和执行脚本--&gt;</span><br><span class="line">wget https://install.direct/go.sh</span><br><span class="line">chmod +x go.sh</span><br><span class="line">./go.sh</span><br><span class="line"></span><br><span class="line">&lt;!--修改配置文件--&gt;</span><br><span class="line">&lt;!--路径：/etc/v2ray/config.json--&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;inbound&quot;: &#123;</span><br><span class="line">    &quot;port&quot;: 7070,</span><br><span class="line">    &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;userLevel&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;inboundDetour&quot;: [&#123;</span><br><span class="line">    &quot;port&quot;: 7080,</span><br><span class="line">    &quot;protocol&quot;: &quot;http&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;userLevel&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;outbound&quot;: &#123;</span><br><span class="line">    &quot;tag&quot;: &quot;vps-jp&quot;,</span><br><span class="line">    &quot;protocol&quot;: &quot;shadowsocks&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;servers&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;207.148.115.199&quot;,</span><br><span class="line">          &quot;port&quot;: 15505,</span><br><span class="line">          &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">          &quot;password&quot;: &quot;mcmmxbt&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;outboundDetour&quot;: [&#123;</span><br><span class="line">    &quot;tag&quot;: &quot;direct&quot;,</span><br><span class="line">    &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;userLevel&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  &quot;routing&quot;: &#123;</span><br><span class="line">    &quot;strategy&quot;: &quot;rules&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">      &quot;domainStrategy&quot;: &quot;IPOnDemand&quot;,</span><br><span class="line">      &quot;rules&quot;: [</span><br><span class="line">        &#123;&quot;type&quot;:&quot;field&quot;, &quot;domain&quot;:&quot;geosite:cn&quot;, &quot;outboundTag&quot;:&quot;direct&quot;&#125;,</span><br><span class="line">        &#123;&quot;type&quot;:&quot;field&quot;, &quot;ip&quot;:&quot;geoip:cn&quot;, &quot;outboundTag&quot;:&quot;direct&quot;&#125;,</span><br><span class="line">        &#123;&quot;type&quot;:&quot;field&quot;, &quot;ip&quot;:&quot;geoip:private&quot;, &quot;outboundTag&quot;:&quot;direct&quot;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--启动服务--&gt;</span><br><span class="line">sudo systemctl start v2ray.service</span><br><span class="line">&lt;!--查看服务状态--&gt;</span><br><span class="line">sudo systemctl status v2ray.service</span><br><span class="line">&lt;!--将服务加入开机自启--&gt;</span><br><span class="line">sudo systemctl enable v2ray.service</span><br><span class="line">&lt;!--测试--&gt;</span><br><span class="line">curl ip.me</span><br><span class="line">curl -x 127.0.0.1:7080 ip.me</span><br><span class="line">curl -x 127.0.0.1:7080 www.google.com</span><br><span class="line">&lt;!--进行命令行代理--&gt;</span><br><span class="line">export http_proxy=&quot;http://127.0.0.1:7080&quot;</span><br><span class="line">export https_proxy=&quot;http://127.0.0.1:7080&quot;</span><br><span class="line">&lt;!--测试--&gt;</span><br><span class="line">curl www.google.com</span><br></pre></td></tr></table></figure>

<h3 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h3><ul>
<li><a href="https://www.jianshu.com/p/4ce7d511bc13">参考教程</a></li>
</ul>
<h3 id="配置项目外网访问"><a href="#配置项目外网访问" class="headerlink" title="配置项目外网访问"></a>配置项目外网访问</h3><ul>
<li>这里就以目前搭的vue cli项目为例</li>
<li>搭建过程参考vue cli环境搭建</li>
<li>当vue cli 项目被创建并成功启动后，默认是通过<a href="http://localhost:8080访问的，这时在命令行通过curl已经能过访问通了，但是这个localhost本质指向了127.0.0.1只能在本地访问，所以要到config/index.js中将localhost改为0.0.0.0这是一个虚拟地址指向当前机器ip">http://localhost:8080访问的，这时在命令行通过curl已经能过访问通了，但是这个localhost本质指向了127.0.0.1只能在本地访问，所以要到config/index.js中将localhost改为0.0.0.0这是一个虚拟地址指向当前机器ip</a></li>
<li>现在用的是iview的模板，这个模板里面修改webpack.dev.config.js,在module.exports标签里面添加<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    port:8080,</span><br><span class="line">    host:&#x27;0.0.0.0&#x27;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li>阿里云有加密机制需要配置一下授予8080端口外网访问的权限，具体是在服务器的管理台找到“安全组”，选择右侧的‘配置规则’，添加安全组规则<img src="https://raw.githubusercontent.com/fireflyso/Img/master/markdown/WX20180913-120012.png" alt="阿里云8080外网访问"></li>
<li>还需要在服务器上配置防火墙<ul>
<li>关于防火墙firewalld</li>
<li>查看状态：systemctl status firewalld</li>
<li>开启：systemctl start firewalld</li>
<li>关闭：systemctl stop firewalld</li>
<li>开放8080：sudo firewall-cmd –zone=public –add-port=8080/tcp –permanent</li>
<li>修改后重启：sudo systemctl restart firewalld.service</li>
<li>查看是否生效：sudo firewall-cmd –query-port=8080/tcp （输出yes）</li>
</ul>
</li>
<li>补充：后来设置mysql的3306端口时候防火墙起不来了，但是好像没有什么影响，远程连接可以连通</li>
<li>应该一切ok了，通过ip+端口就能访问了</li>
</ul>
<h3 id="配置vim"><a href="#配置vim" class="headerlink" title="配置vim"></a>配置vim</h3><p>安装一些vim的插件来方便开发</p>
<ul>
<li><a href="http://coderunthings.com/2015/12/09/frontendvim/">教程</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux -- Linux</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/Linux/</url>
    <content><![CDATA[<h2 id="一、常用操作以及概念"><a href="#一、常用操作以及概念" class="headerlink" title="一、常用操作以及概念"></a>一、常用操作以及概念</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>  Tab：命令和文件补齐</li>
<li>  Ctrl+C：中断正在运行的程序</li>
<li>  Ctrl+D：在录入信息时表示end of file结束输入，在终端中相当于exit回车，远程会直接退出</li>
<li>  who：查看当前在线用户情况，Linux不同于windows多用户在线很普遍</li>
</ul>
<h2 id="二、磁盘"><a href="#二、磁盘" class="headerlink" title="二、磁盘"></a>二、磁盘</h2><h4 id="磁盘接口"><a href="#磁盘接口" class="headerlink" title="磁盘接口"></a>磁盘接口</h4><ul>
<li>  IDE：不知道是啥，反正基本没人用了</li>
<li>  SATA：现在比较通用的，抗干扰性强，二代接口速度大概是300M/s,三代标准600M/s</li>
<li>  还有SCSI和他的优化版SAS，都比SATA好当然也比它贵，所以现在还不是很普及</li>
</ul>
<h4 id="磁盘名称"><a href="#磁盘名称" class="headerlink" title="磁盘名称"></a>磁盘名称</h4><p>Linux里面的每个存储工具（磁盘或者光盘之类的）都被当做一个文件夹，比如两个磁盘就是两个根目录，不像Windows里面可以把一块硬盘分成好几个盘（没有实际使用过，不是很了解）</p>
<h2 id="三、文件"><a href="#三、文件" class="headerlink" title="三、文件"></a>三、文件</h2><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>ll查看一个目录的详细信息：==drwxr-xr-x 4 root root 4.0K 10月 22 16:43 temp==</p>
<ul>
<li>第一个字符代表文件类型<ul>
<li>  d:目录</li>
<li>  -:文件</li>
<li>  l：链接文件</li>
</ul>
</li>
<li>类型后面的9位代表权限<ul>
<li>  r、w、x表示可读、可写、可执行</li>
<li>  9位中美三个为一组代表一个角色的权限，分别对应文件拥有者、所属群组和其他人的权限</li>
</ul>
</li>
<li>  4：链接数</li>
<li>  root：文件拥有者</li>
<li>  root：文件所属群组</li>
<li>  4.0k：文件大小</li>
<li>  10月 22 16:43：文件最后修改时间</li>
<li>  temp：文件名称</li>
</ul>
<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>==touch [-acdmt] filename==：更新文件时间或者创建文件（不太清楚更新时间是什么作用）</p>
<ul>
<li>  a ： 更新 atime</li>
<li>  c ： 更新 ctime，若该文件不存在则不建立新文件</li>
<li>  m ： 更新 mtime</li>
<li>  d ： 后面可以接更新日期而不使用当前日期，也可以使用 –date=”日期或时间”</li>
<li>  t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</li>
</ul>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>可以将一组权限用数字来表示，r:4、w:2、x:1；所以通常用==chmod 777 filename==给文件所有用户所有权限，4、2、1的组合很巧妙不会出现一个数字能代表两种权限组合的情况</p>
<h3 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h3><ul>
<li>  文件默认权限是666、没有执行的权限，所以好多时候要执行一个脚本的时候需要去修改他的权限</li>
<li>  文件夹的默认权限是777，因为默认是可以打开的</li>
<li>  注意由于文件名是存储在文件夹里面的，所以只对文件有写入权限的时候是不能</li>
</ul>
<h3 id="获取文件内容"><a href="#获取文件内容" class="headerlink" title="获取文件内容"></a>获取文件内容</h3><ul>
<li>  cat：取得文件内容，有的时候vim打开文件去复制会出现符合编码的问题，用cat打印到命令行再复制就不会</li>
<li>  tac：将文件内容倒着打印出来</li>
<li>  more：对比cat它可以一页页的查看，适合大文件</li>
<li>  less：比more多了一个向前翻页</li>
<li>  head：取得文件的前几行   head -n filename</li>
<li>  tail：文件的后几行，通常用来查看日志文件</li>
</ul>
<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><ul>
<li>  which 只能搜索可执行的文件</li>
<li>  whereis 比which强一些能搜索所有的文件(不太清楚和locate是个什么区别)</li>
<li>  locate 依赖linux维护的数据库来搜索速度非常快，但是数据库的更新是每天一次，新文件会出现搜不到的情况，可以用updatedb来立即更新数据库（估计每天只更新一次是为了节省资源开销，老是用updatedb的话影响整体性能了）</li>
<li>  find 文件搜索，从根目录搜索，会很慢，可以自己限定范围，比如 find . -name filename</li>
<li>  总结：试了一下前面的三个命令都用得不是很明白，大概在找一写程序的安装目录的时候用whereis 比较合适，其他时候还是老老实实用find自己去缩小查找范围，不过find命令是真的很慢</li>
</ul>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><ul>
<li>linux里面常见的压缩文件格式<ul>
<li>  .Z    commpress</li>
<li>  .zip  zip</li>
<li>  .gz   gzip</li>
<li>  .bz2  bzip2</li>
<li>  .xz   xz</li>
<li>  .tar  tar程序打包数据，没有经过压缩</li>
<li>  .tar.gz   .tar.bz2    .tar.xz     就是经过对应的方式进行了压缩</li>
</ul>
</li>
<li>不同的压缩类型<ul>
<li>gzip<ul>
<li>  gzip filename 直接压缩文件，源文件会消失，出现一个filename.gz的文件</li>
<li>  gzip -d filename 解压文件，这个文件当然得是压缩文件了，可以解开compress、zip和gzip所压缩的文件</li>
</ul>
</li>
<li>  bzip2 提供比gzip更高的压缩比</li>
<li>  xz 比bzip2更高的压缩比，这几种方式的压缩比是增加的，同时会花费更多的时间</li>
</ul>
</li>
</ul>
<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>tar命令，试了一下没有成功，用于压缩文件夹的</p>
<h2 id="四、Bash-创建一个-sh文件"><a href="#四、Bash-创建一个-sh文件" class="headerlink" title="四、Bash(创建一个.sh文件)"></a>四、Bash(创建一个.sh文件)</h2><h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><ul>
<li><p>  赋值 =</p>
</li>
<li><p>  对变量的取用在变量的前面加上<code>$或者$</code>{}</p>
</li>
<li><p>  输出变量echo</p>
</li>
<li><p>当变量的内容中包含空格，需要使用双引号或者单引号-</p>
<ul>
<li>  双引号内的特殊字符可以保留原本的属性</li>
<li>  单引号内的特殊字符就是特殊字符本身</li>
</ul>
<p>  x=”x is <code>$LANG&quot;   y=&#39;y is $</code>LANG’<br>  输出结果：<br>  x is zh_CN.UTF-8<br>  y is $LANG</p>
</li>
</ul>
<h2 id="五、管道指令"><a href="#五、管道指令" class="headerlink" title="五、管道指令"></a>五、管道指令</h2><ul>
<li>  管道是指将一个命令的输出作为另一个命令的输入，管道命令可以是连续的多个命令，中间用|分隔</li>
<li>  提取指令：cut，提取结果中需要的部分涉及正则表达式，用的时候再具体说</li>
<li>  排序：sort</li>
<li>  去重：uniq</li>
</ul>
<h3 id="字符转换："><a href="#字符转换：" class="headerlink" title="字符转换："></a>字符转换：</h3><ul>
<li>tr 删除或者替换字符<ul>
<li>  last | tr ‘[a-z]’ ‘[A-Z]’ 将last输出的内容中的小写转换为大写</li>
<li>  tr -d string  删除行中sting字符串</li>
</ul>
</li>
<li>  col 将tab字符转换为空格</li>
<li>  expand将tab转换为一定数量的空格，默认是8个</li>
</ul>
<h3 id="分区指令"><a href="#分区指令" class="headerlink" title="分区指令"></a>分区指令</h3><p>split将一个文件划分为多个文件</p>
<pre><code>split [-bl] file PREFIX
-b：以大小分区，可以加单位，b,k,m之类的，不知道默认的是什么
-l：以行数分区
-PREFIX：分区文件的前缀
完整示例：split -l 2 test.py son
将test.py文件没两行分为一个文件，前缀是son，最后得到的文件是sonaa、sonab、sonac...源文件还存在，分割后的文件没有格式后缀
</code></pre>
<h2 id="六、进程管理"><a href="#六、进程管理" class="headerlink" title="六、进程管理"></a>六、进程管理</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><ul>
<li>ps<ul>
<li>  ps -l 查看自己的进程</li>
<li>  ps aux    查看系统所有进程</li>
<li>  ps aux | grep threadx     查看特定的进程，这个就是以前经常用的</li>
</ul>
</li>
<li>  pstree -A 查看所有进程树，这个会比较直观的把所有的进程以树状结构展示出来</li>
<li>  top 显示实时进程信息（类似于Windows里面的任务管理）top -d 2 两秒钟刷新一次</li>
<li>netstat   查看端口占用情况<ul>
<li>  netstat -anp | grep portNum   查看特定端口占用情况，一般是先通过ps命令把程序对应的端口号找出来，再用这个命令查看</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux -- Linux系统安装维护</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[<h1 id="一、系统安装"><a href="#一、系统安装" class="headerlink" title="一、系统安装"></a>一、系统安装</h1><h2 id="1-1-Ubuntu"><a href="#1-1-Ubuntu" class="headerlink" title="1.1 Ubuntu"></a>1.1 Ubuntu</h2><h3 id="1-1-1-U盘安装"><a href="#1-1-1-U盘安装" class="headerlink" title="1.1.1 U盘安装"></a>1.1.1 U盘安装</h3><p>U盘安装ubantu    2016年3月22日    12:01</p>
<p>下载系统，用一个小软件写入U盘，启动系统，选择U盘启动，选择语言，这些百度就好，重点是分区，装系统前最好是有一块未分配的磁盘空间，分300M为EFI引导分区，分4G（与电脑的内存差不多大小）为swps（具体不记得了）交换空间，再分一个盘来安装ubantu，大小看自己实际情况就好，然后就可以安装了。</p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
<h3 id="1-1-2-硬盘安装"><a href="#1-1-2-硬盘安装" class="headerlink" title="1.1.2 硬盘安装"></a>1.1.2 硬盘安装</h3><p>Windows下硬盘安装ubantu GNOME<br>2016年3月22日<br>11:17</p>
<p>打开easybcd，选择添加新条目，选择NeoGrub，点击安装后选择‘安装’右边的‘配置’，将一下的内容替换原有内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title Install Ubuntu</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel (hd0,0)/vmlinuz boot=casper iso-scan/filename=/ubuntu-14.04-desktop-i386.iso ro quiet splash locale=zh_CN.UTF-8</span><br><span class="line">initrd (hd0,0)/initrd.lz</span><br></pre></td></tr></table></figure>
<p>其中 （hd0,0)  是c盘在linux下的编号，hd0是指第一块硬盘，后面的0是指第一个分区，打开windows的磁盘管理，看c盘的位置是第几个就是第几个分区，filename=/后面的是系统文件名称；</p>
<p>下面把准备好的Ubuntuiso镜像文件用压缩软件或者虚拟光驱打开，找到casper文件夹，把里面的initrd.lz和vmlinuz解压到C盘，把.disk文件夹也解压到C盘，然后在把整个iso文件复制到C盘。</p>
<p>重启电脑，应该能看到一个新的引导叫做NeoGrub，进去就能到ubantu的桌面了，打开终端输入以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo umount -l /isodevice</span><br></pre></td></tr></table></figure>
<p>这一命令取消掉对光盘所在 驱动器的挂载（注意，这里的-l是L的小写，-l 与 /isodevice 有一个空格。），否则分区界面找不到分区。</p>
<p>建议输入两次，第一次回车后没有反应，但是第二次回车后会提示没有驱动被挂载<br>然后就可以选择安装系统了，选择与当前系统共存就行（这次安装的时候我的磁盘有70g是未分配的空间，安装系统会自己把这片空间分区包括引导分区、交换空间和系统文件区，它都会自己分好的，直接安装就好了）</p>
<p>不出意外这样就能完成安装了，记得会windows下把还在c盘的文件删除，把easyBCD的那个引导删除。</p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
<h1 id="二、维护"><a href="#二、维护" class="headerlink" title="二、维护"></a>二、维护</h1><h2 id="2-1-修复Linux引导"><a href="#2-1-修复Linux引导" class="headerlink" title="2.1 修复Linux引导"></a>2.1 修复Linux引导</h2><h3 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h3><p>双系统下重装windows的时候把linux的系统引导给覆盖了，用工具修复不行，需要做一个U盘启动盘，然后通过U盘进试用版的linux系统来修复</p>
<h3 id="linuxU盘启动盘的制作"><a href="#linuxU盘启动盘的制作" class="headerlink" title="linuxU盘启动盘的制作"></a>linuxU盘启动盘的制作</h3><ul>
<li>下载UltraISO工具</li>
<li>文件-打开-选择系统镜像</li>
<li>启动-写入系统镜像</li>
<li>这个时候如果插入了U盘就能看到了，直接写入就行了</li>
<li>然后重启按esc选U盘启动</li>
<li>选体验版，别安装</li>
</ul>
<h3 id="在linux-cmd修复引导"><a href="#在linux-cmd修复引导" class="headerlink" title="在linux cmd修复引导"></a>在linux cmd修复引导</h3><ul>
<li>这个系统就是一个U盘上的体验版，所以管理员权限好像是没有密码的，切管理员模式</li>
<li>sudo -i</li>
<li>fdisk -l</li>
<li>查看linux所在的分区，这次我的分区是/dev/sda6（通过磁盘大小和名称来判断吧）</li>
<li>mkdir /media/tmp</li>
<li>mount /dev/sda6 /media/tmp</li>
<li>grub-install –root-directory=/media/tmp /dev/sda</li>
<li>正常这里就会说没有错误，那就成功了，重启就行了，如果还有问题就回来更新一下系统引导,这次到这里就成了</li>
<li>sudo update-grub2</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux -- Ubuntu配置</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/Ubuntu%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><ul>
<li>打开设置，选择语言，点击输入源下面到加号，在中文下选择中文pinyin，系统就能够使用中文输入法了</li>
<li>打开firefox，搜索zh-CN的插件，安装后重启，firefox的语言就变成中文的了</li>
<li>打开软件更新器，更新系统</li>
<li>安装chrome</li>
<li>自带的中文输入法不好用，安装搜狗输入法</li>
<li>配置ss翻墙</li>
<li>在应用商店搜索netspeed监控网速</li>
<li>通过deepin-wine安装常用的软件，<a href="https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu">git地址</a></li>
<li>ssh，默认好像是不能用的<a href="https://blog.csdn.net/netwalk/article/details/12952051">参考教程</a></li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>安装zsh</li>
<li>安装Java、Tomcat、eclipse、idea（都很容易就能找到教程）</li>
<li>安装Python3、git</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux -- crontab</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/crontab/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>linux里面执行定时任务的工具为crontab</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>查看定时任务</p>
<p>  crontab -l</p>
</li>
<li><p>编辑定时任务(修改完成后保存退出即可生效)</p>
<p>  crontab -e</p>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>*/1 * * * * /home/work/restart_update_process.sh &gt;&gt; /home/work/log/check_update_process.out
</code></pre>
<ul>
<li>  五个个星号分别对应 分、时、日、月、周  取值范围分别是0-59/0-23/1-31/1-12/0-7  关于周的时候呢取0或者7都是表示星期天  且周与日月不可共存</li>
<li>  *表示任意时间  比如案例中日月周都为*即是表示任意天</li>
<li>  ,（逗号） 比如 0 1,2 * * * command  表示1点和2点</li>
<li>  -（减号） 比如 0 1-8 * * * command  表示1点到8点的没个小时0分都执行</li>
<li>  /n  比如  */5 * * * * command  表示每隔5分钟执行一次</li>
</ul>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li>  如果要执行的语句比较复杂可以考虑写到一个shell脚本中，定时执行脚本即可</li>
<li>  被执行的脚本或者程序需要有执行权限</li>
</ul>
<h2 id="常用案例"><a href="#常用案例" class="headerlink" title="常用案例"></a>常用案例</h2><pre><code>0 1 * * *   每天1点
20 */24 * * *    每天0点20分
0 */3 * * *     从0点开始计算，每3个小时
</code></pre>
<p><a href="https://crontab.guru/">一个可以检测执行效果的网页</a></p>
<h2 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h2><h3 id="冻结危险命令"><a href="#冻结危险命令" class="headerlink" title="冻结危险命令"></a>冻结危险命令</h3><ul>
<li>  -r</li>
<li>  -i</li>
</ul>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><ul>
<li><p>  通过备份恢复</p>
</li>
<li><p>通过日志文件恢复（没有备份的情况下）</p>
<ul>
<li>  日志文件位置</li>
<li>过滤命令  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--将日志文件中的命令输出到cmd_tmp文件中--&gt;</span><br><span class="line">cat /Users/luoyang/Downloads/crontab.log | grep -i &quot;whoami&quot; &gt; grep &quot;CMD&quot; | awk -F &#x27;(&#x27; &#x27;&#123;print $3&#125;&#x27; | awk -F &#x27;)&#x27; &#x27;&#123;print $1&#125;&#x27; | sort -u &gt; cmd_tmp</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>  从上个命令输出的文件中一一拿出命令到日志文件中进行grep搜索，结果中有时间信息应该是可以清晰的看出执行的频率的</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux -- linux下安装mysql（修改root密码）</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E4%B8%8B%E5%AE%89%E8%A3%85mysql%EF%BC%88%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>本来在segmentfault上找到一个很好的<a href="https://segmentfault.com/a/1190000012703513">安装教程</a>，一切也都很顺利，可是修改完root密码之后居然登录不上去了，只好重置root密码，这个过程中发现原来是mysql在一个版本的时候将存储用户密码的字段名给修改了，所以前面第一次对root用户的密码重置其实是有问题的</p>
<h3 id="mysql密码恢复"><a href="#mysql密码恢复" class="headerlink" title="mysql密码恢复"></a>mysql密码恢复</h3><p>大体流程是先去修改配置文件使得mysql的登录不需要密码，然后用root账户直接登录mysql，进入mysql数据库，用update语句修改user表中root对应的密码</p>
<ul>
<li>修改MySQL登录设置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br></pre></td></tr></table></figure>
在[mysqld]中加入skip-grant-tables保存退出，这个语句使得mysql登录可以不走密码验证</li>
<li>重启mysql服务使刚才的修改生效<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/init.d/mysqld restart</span><br></pre></td></tr></table></figure></li>
<li>登录修改root密码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/mysql/bin/mysql -uroot</span><br><span class="line"></span><br><span class="line">use mysql</span><br><span class="line">update user set authentication_string=password(&#x27;newPassword&#x27;) where user=&#x27;root&#x27;; </span><br><span class="line">flush privileges;</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></li>
<li>将配置文件修改回去，删除刚才加的那个语句，保存退出</li>
<li>重启mysql服务</li>
<li>现在一切ok了</li>
</ul>
<h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>安装完成后在命令行中输入mysql是找不到服务的，以为系统只默认扫描/usr/bin目录中的可执行文件，这时需要将mysqld所在的目录软链到/usr/bin去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s  /usr/local/mysql/bin/mysql  /usr/bin</span><br></pre></td></tr></table></figure>
<p>这样就可以直接在命令行中通过mysql访问了，没有试过重启后是否还生效</p>
<h3 id="启动报错"><a href="#启动报错" class="headerlink" title="启动报错"></a>启动报错</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看配置文件，里面包含了错误日志文件路径,查看日志来处理问题</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错：Can&#x27;t create/write to file &#x27;/var/run/mysqld/mysqld.pid&#x27;  </span></span><br><span class="line"><span class="comment"># 权限问题，而且还和是用root用户访问有关，执行以下命令再启动</span></span><br><span class="line">chown mysql:mysql /var/run/mysqld</span><br></pre></td></tr></table></figure>

<h3 id="用户创建和授权"><a href="#用户创建和授权" class="headerlink" title="用户创建和授权"></a>用户创建和授权</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--创建一个所有地址都能访问的用户，授予对所有表的所有权限--&gt;</span><br><span class="line">CREATE USER &#x27;firefly&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;firefly&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux -- Linux命令</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="网络调试"><a href="#网络调试" class="headerlink" title="网络调试"></a>网络调试</h2><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><ul>
<li>fping</li>
<li>traceroute</li>
<li>mtr</li>
<li>strace</li>
<li>dnspeep</li>
</ul>
<h3 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h3><p>安装这个依赖，使用命令：<code>iftop -PB</code>查看带宽使用情况</p>
<p><img src="/img/image-20230517120204412.png" alt="image-20230517120204412"></p>
<ul>
<li><p>TX网卡出向流量、RX网络累计流量、TOTAL累计流量</p>
</li>
<li><p>peak峰值流量（这里应该是58.0KB/s而不是带宽，*8为带宽）</p>
</li>
<li><p>rates表示2s、10s、40s的平均流量，所以这个数据是比较有参考价值的</p>
</li>
</ul>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h3 id="Hosts"><a href="#Hosts" class="headerlink" title="Hosts"></a>Hosts</h3><p>配置hosts</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">123.123.123.123 www.baidu.com</span><br><span class="line">124.123.123.123 www.qq.com</span><br></pre></td></tr></table></figure>

<h3 id="配置DNS服务"><a href="#配置DNS服务" class="headerlink" title="配置DNS服务"></a>配置DNS服务</h3><p>参考博客：<a href="https://www.cnblogs.com/yuhaohao/p/13889240.html">Linux配置/etc/resolv.conf详解</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/resolv.conf</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure>

<ul>
<li><p>nameserver定义DNS服务器地址，可以配置多个服务器，按配置顺序查找解析域名（找不到就找下一个解析服务器）</p>
</li>
<li><p>关闭本地DNS服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看运行状态</span></span><br><span class="line">systemctl status systemd-resolved.service</span><br><span class="line">systemctl stop systemd-resolved.service</span><br><span class="line"><span class="comment"># 关闭开机自启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> systemd-resolved.service</span><br></pre></td></tr></table></figure>

<ul>
<li><div style="color:#F56C6C">这个服务没有研究得很明白</div></li>
</ul>
</li>
</ul>
<h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>没试过</p>
<h2 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h2><ul>
<li><p>查看系统版本信息（Ubuntu还是CentOS）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure></li>
<li><p>系统版本red hat或者centos</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure></li>
<li><p>查看cpu信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure></li>
<li><p>新建用户(需要管理员权限)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser firefly</span><br><span class="line">passwd firefly</span><br><span class="line">whereis sudoers</span><br><span class="line">ls -l /etc/sudoers</span><br><span class="line">chmod -v u+w /etc/sudoers</span><br><span class="line"></span><br><span class="line">vi /etc/sudoers</span><br><span class="line">&lt;!--在root配置下面把刚创建的用户加上--&gt;</span><br><span class="line">root	ALL=(ALL) 	ALL</span><br><span class="line">firefly	  ALL=(ALL)       ALL</span><br><span class="line"></span><br><span class="line">chmod -v u-w /etc/sudoers</span><br></pre></td></tr></table></figure></li>
<li><p>查看用户的系统资源占用状况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 后面的root是用户名</span><br><span class="line">top -u root</span><br></pre></td></tr></table></figure></li>
<li><p>批量结束进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep -i chrome | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span></span><br><span class="line"></span><br><span class="line">&lt;!--正常的查看一个服务的运行状况是--&gt;</span><br><span class="line">ps aux | grep chrome    </span><br><span class="line">&lt;!--上面多了一个-i是忽略大小写的意思--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--将管道传来的数据中的第二个列打印到命令行--&gt;</span><br><span class="line">awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">&lt;!--也可以打印多个--&gt;</span><br><span class="line">awk <span class="string">&#x27;&#123;print $2,$3&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;!--将管道传过来的进程号全部<span class="built_in">kill</span>--&gt;</span><br><span class="line">xargs <span class="built_in">kill</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>修改root密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--前提是在root用户下--&gt;</span><br><span class="line">sudo passwd root</span><br><span class="line">&lt;!--之后将新密码输入两次--&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>查看网络端口使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -lnp</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><ul>
<li><p>远程服务器文件传输</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#上传</span><br><span class="line">#文档</span><br><span class="line">scp -P 2222 /home/lnmp0.4.tar.gz root@www.vpser.net:/root/lnmp0.4.tar.gz</span><br><span class="line"></span><br><span class="line">#文件夹</span><br><span class="line">scp -P 2222 -r /home/lnmp0.4/ root@www.vpser.net:/root/lnmp0.4/</span><br><span class="line"></span><br><span class="line">#下载</span><br><span class="line">#文档</span><br><span class="line">scp -P 2222 root@www.vpser.net:/root/lnmp0.4.tar.gz /home/lnmp0.4.tar.gz</span><br><span class="line"></span><br><span class="line">#文件夹</span><br><span class="line">scp -P 2222 -r root@www.vpser.net:/root/lnmp0.4/ /home/lnmp0.4/</span><br></pre></td></tr></table></figure></li>
<li><p>查看目录占用磁盘空间大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#子文件和子文件夹</span><br><span class="line">du -sh folderPaht/*</span><br><span class="line"></span><br><span class="line">#文件夹</span><br><span class="line">du -sh folderPath</span><br></pre></td></tr></table></figure></li>
<li><p>搜索文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先不记那么多用不到的功能，以后用到再补充</span><br><span class="line"></span><br><span class="line"># 在文件夹下的所有文件中搜索关键字以及他所在的行号</span><br><span class="line">grep -rn keyword ./</span><br><span class="line"></span><br><span class="line"># 使用正则表达式,这里只是一个比较常用的.*表示匹配任意数量的任意字符</span><br><span class="line">grep &#x27;500 .*https://brandfollowers&#x27; access.log</span><br><span class="line"></span><br><span class="line"># 通过-C可以打印出搜索目标前后的行</span><br><span class="line">grep -rn -C 1 &quot;调用API url: http://wan-flow-bps-service&quot; ./resop.log.2021-08-05_16</span><br><span class="line"></span><br><span class="line"># 只显示匹配的内容</span><br><span class="line">grep -o &#x27;if_name.*init_time&#x27; /root/telemetry/test/gpb/log.out</span><br></pre></td></tr></table></figure></li>
<li><p>压缩文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件或者文件夹打包为压缩文件</span></span><br><span class="line"><span class="built_in">zip</span> -r -q test.<span class="built_in">zip</span> /root/user/test</span><br><span class="line"></span><br><span class="line">tar –cvf test.tar /root/user/test</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">unzip test.<span class="built_in">zip</span></span><br><span class="line"><span class="comment"># 解压tgz文件，file.tgz是要解压的文件，file是解压后的文件或文件夹</span></span><br><span class="line">tar -xzvf file.tgz -C file</span><br></pre></td></tr></table></figure></li>
<li><p>sed</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--输出文件第10行内容--&gt;</span><br><span class="line">sed -n 10p file</span><br></pre></td></tr></table></figure></li>
<li><p>less<br>less不会像vi那样将所有数据加载到内存中，但实现了大多数vi操作模式下的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--显示行号展示文件--&gt;</span><br><span class="line">less -N file</span><br><span class="line"></span><br><span class="line">&lt;!--打开特定行--&gt;</span><br><span class="line">less +320123 filename</span><br><span class="line"></span><br><span class="line">&lt;!--通过less来展示历史命令，方便查看--&gt;</span><br><span class="line">history | less</span><br><span class="line"></span><br><span class="line">&lt;!--实时刷新，类似tail -f--&gt;</span><br><span class="line">less file.log</span><br><span class="line">打开后按F</span><br><span class="line"></span><br><span class="line">v 可以进行编辑</span><br><span class="line">100g 可以跳转到第100行</span><br><span class="line"></span><br><span class="line">&lt;!--打开另一个文件--&gt;</span><br><span class="line">:e file2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="开机启动项管理"><a href="#开机启动项管理" class="headerlink" title="开机启动项管理"></a>开机启动项管理</h2><ul>
<li>查看所有：<code>sudo systemctl list-unit-files</code>会用less的方式对项目进行展示</li>
<li>指定查看：<code>systemctl is-enabled servicename.service</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable *.service #开机运行服务</span><br><span class="line">systemctl disable *.service #取消开机运行</span><br><span class="line">systemctl start *.service #启动服务</span><br><span class="line">systemctl stop *.service #停止服务</span><br><span class="line">systemctl restart *.service #重启服务</span><br><span class="line">systemctl reload *.service #重新加载服务配置文件</span><br><span class="line">systemctl status *.service #查询服务运行状态</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux -- vultr服务器配置</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/vultr%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<ul>
<li><p>修改密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure></li>
<li><p>搭建ss</p>
</li>
<li><p>在~目录下创建并切换到shadowsocks目录</p>
</li>
<li><p>执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget –no-check-certificate  https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">./shadowsocks.sh <span class="number">2</span>&gt;&amp;<span class="number">1</span> | tee shadowsocks.log</span><br></pre></td></tr></table></figure></li>
<li><p>这里需要配置ss服务的参数：密码、端口、加密方式（建议使用aes-256-cfb）</p>
</li>
<li><p>最后界面上回显示红色标记的内容就是ss的连接信息了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mac -- IDEA家族快捷键</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac/IDEA%E5%AE%B6%E6%97%8F%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h1><ul>
<li>  文本内搜索：command+f</li>
<li>  文件树中选中文件夹内搜索：command+shift+f</li>
<li>  文本内替换：command+r</li>
<li>  全局搜索文件：双击shift唤出搜索框(可能会和输入法切换冲突)</li>
<li>  折叠代码：command+shift+- （可以选中部分内容进行折叠和展开操作）</li>
<li>  展开代码：command+shift++</li>
<li>  格式化代码：command+alt+l</li>
<li>  切换左右标签：command+shift+{}</li>
<li>  跳转文件头尾：command+fn+left/right</li>
<li>  回退跳转：command+[]</li>
<li>  优化import：control+option+o</li>
</ul>
<h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><ul>
<li>  f8 下一步</li>
<li>  f7 单步（无函数时同f8）</li>
<li>  option + f8 运行到光标所在行</li>
<li>  option + f8 测试语句</li>
<li>  control + f8 切换断点</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac -- Iterm2快捷键</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac/Iterm2%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<ul>
<li>  command + t：打开一个新tab</li>
<li>command + d：纵向分割屏幕打开一个新tab<ul>
<li>  command + []：左右切换panel</li>
<li>  command + w：关闭panel</li>
</ul>
</li>
<li>command + shift + d：横向分割屏幕打开一个新tab<ul>
<li>  command + opt + 上下箭头：上下切换panel</li>
</ul>
</li>
<li>  command + /：定位光标位置</li>
<li>  command + opt + b：命令回放（类似于视频的方式）</li>
<li>  command + ;：语法补全</li>
<li>  command + shift + h：打开粘贴历史</li>
<li>  command + alt + ;：高亮鼠标所在行</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac -- hexo安装</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac/hexo%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>hexo是一个开源的博客系统，对md有很好的支持，在本地安装后，可以推送到git上开启page即可使用github的服务器资源</p>
<h1 id="新设备搭建"><a href="#新设备搭建" class="headerlink" title="新设备搭建"></a>新设备搭建</h1><ul>
<li><p>  克隆git项目</p>
</li>
<li><p>环境依赖</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nodejs</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install --save hexo-admin</span><br><span class="line"><span class="comment"># 字数统计</span></span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="首次搭建"><a href="#首次搭建" class="headerlink" title="首次搭建"></a>首次搭建</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>依赖nodejs，这里不赘述nodejs安装方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装hexo依赖</span></span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹初始化一个hexo项目</span></span><br><span class="line"><span class="built_in">mkdir</span> blog</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 看下生成了一下目录文件</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">_config.landscape.yml node_modules          scaffolds             themes</span><br><span class="line">_config.yml           package.json          <span class="built_in">source</span>                yarn.lock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态部署和启动服务</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h2 id="git部署"><a href="#git部署" class="headerlink" title="git部署"></a>git部署</h2><ul>
<li><p>  在git上创建一个项目<a href="https://github.com/fireflyso/fireflyso.github.io">fireflyso/fireflyso.github.io</a></p>
</li>
<li><p>修改本地配置文件_config.yml</p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:fireflyso/fireflyso.github.io.git  #你的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>  安装部署插件：<code>npm install hexo-deployer-git --save</code></p>
</li>
<li><p>部署</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean   <span class="comment">#清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo d       <span class="comment">#自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h2><ul>
<li><p>安装主题，<a href="https://butterfly.js.org/posts/21cfbf15/">官方教程</a><br>  # 使用gitee安装，github网络不稳定<br>  git clone -b master <a href="https://gitee.com/immyw/hexo-theme-butterfly.git">https://gitee.com/immyw/hexo-theme-butterfly.git</a> themes/butterfly</p>
<pre><code>  # 修改hexo根目录_config.yml文件
  theme: butterfly

  # 安装渲染器（非必要）
  npm install hexo-renderer-pug hexo-renderer-stylus --save
</code></pre>
</li>
<li><p>安装admin插件<br>  npm install –save hexo-admin</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac -- mac快捷键</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac/mac%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul>
<li><p>  全局搜索：command + space</p>
</li>
<li><p>符号：<br>  ⌘（command）</p>
<pre><code>  ⌥（option）

  ⇧（shift）

  ⇪（caps lock）

  ⌃（control）
</code></pre>
</li>
</ul>
<h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><ul>
<li>  刷新：command + r</li>
<li>  打开控制台：option + command + c</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac -- mac环境搭建</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac/mac%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p>针对一个新的mac环境</p>
<h2 id="mac系统的iCloud账户"><a href="#mac系统的iCloud账户" class="headerlink" title="mac系统的iCloud账户"></a>mac系统的iCloud账户</h2><p>对一个啥也没有的系统来说一开始要登录一下自己的iCloud账户，后面才能顺利的使用app store和一些设置，然后可能就是要调一调计算机名称之类的，装自己用的IDE和常用软件</p>
<h2 id="重装brew"><a href="#重装brew" class="headerlink" title="重装brew"></a>重装brew</h2><p>如果不幸把自己的brew玩坏了（配数据源），可以通过一个大佬写的脚本进行重装</p>
<p><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; </code></p>
<h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><p>由于Python2.7是默认就存在的就不用在安装了，<a href="https://blog.csdn.net/qq_20881087/article/details/79417228">教程参考</a></p>
<ul>
<li><p>安装xcode</p>
<p>  xcode-select –install</p>
</li>
<li><p>安装Homebrew，注意这一步花的时间还挺长的，要等一会</p>
<p>  /usr/bin/ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>
</li>
<li><p>安装Python3</p>
<p>  brew install python3</p>
</li>
<li><p>  这个时候在命令行里面输入python3应该就能进入python3的解释器了，pip3和Python3进行了集成，不需要单独安装</p>
</li>
</ul>
<h2 id="iTerm"><a href="#iTerm" class="headerlink" title="iTerm"></a>iTerm</h2><p>这个比原生的terminal要好用一些（其实没有用过terminal）</p>
<ul>
<li>  设置字体大小：iTerm-&gt;Preferences-&gt;Profiles-&gt;Text-&gt;Font:  （设置16感觉很合适）</li>
</ul>
<h2 id="sshpass"><a href="#sshpass" class="headerlink" title="sshpass"></a>sshpass</h2><p>命令行ssh管理密码，省去了输入密码的步骤</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb
</code></pre>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令行直接调用的方式</span></span><br><span class="line">sshpass -p <span class="string">&#x27;password&#x27;</span> ssh -p <span class="number">22</span> root@<span class="number">119.23</span><span class="number">.34</span><span class="number">.118</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置为zsh别名,先打开.zshrc文件，如果用了别的shell工具，那就在对应的配置文件中添加别名</span></span><br><span class="line">vi ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入以下配置</span></span><br><span class="line">alias firefly=<span class="string">&quot;sshpass -p &#x27;password&#x27; ssh -p 22 root@119.23.34.118&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac -- ps</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac/ps/</url>
    <content><![CDATA[<h4 id="处理图片为透明"><a href="#处理图片为透明" class="headerlink" title="处理图片为透明"></a>处理图片为透明</h4><ul>
<li>一般都是想要将图片的白色区域变为透明<ul>
<li>将图片打开</li>
<li>在右侧图层中双击解锁图层，因为只打开了一张图片所以现在就只有这一个图层</li>
<li>在图片上右键菜单中找到‘色彩范围’</li>
<li>这时候鼠标放在图片上会变成吸管的图标，点击白色区域后点击色彩范围选择框中的确定，这时图片中白色的区域应该被自动选中了</li>
<li>按删除键，被选中的区域变为透明（如果按删除时弹出对话框让选乱七八糟的东西的话，应该是图层还处于锁定状态，解锁后删除会直接变为透明）</li>
<li>保存的时候保存格式为png，用过jpg的格式没法存储为透明</li>
<li>保存的时候如果想要降低图片占用空间的大小可以用“菜单”–“文件”–“存储为web格式”</li>
</ul>
</li>
<li>把图片的内容从白色变为黑色：ctrl + i</li>
<li>将图片中的一部分复制移动到别地方<ul>
<li>选择工具栏中的磁性套索工具（第三个工具中右击可见）</li>
<li>鼠标移动到图片上左击一下，然后移动鼠标会自动的跟着图形的边缘连线，区域选择完成后再次单击（command+j），这个时候会生成一个新的图层</li>
<li>选择第一个工具（移动）就可以自行移动图层到想要的位置</li>
</ul>
</li>
<li>在图片上生成透明区域：<ul>
<li>新建一个透明的幕布（反正就是新建就行了）</li>
<li>把要处理的图片置入（可以直接拖拽也可以在工具栏中找到置入）</li>
<li>用工具栏中的形状绘制工具（有个长方形的边角是圆弧的工具），在图片想要的位置画出自己需要的形状</li>
<li>将要修改的那张图片的图层上右击选择“栅格化图层”（ps里面好像把图层分为智能对象和栅格化对象，智能对象一般都不能直接修改）</li>
<li>在刚才绘制的图形（也就是最后需要的透明区域）上右键选择“建立选区”，然后确定，这个时候他的边缘应该会被标记出来</li>
<li>然后按删除键，最后再到这个要被删除的图层上点击眼睛的图表把它隐藏掉，这个时候原本的图片上就出现了透明的区域了</li>
</ul>
</li>
<li>图片处理<ul>
<li>一个图片被固定到画板上之后要重新选中它：command+t</li>
<li>等比例缩放图片：按住command+shift再缩放</li>
</ul>
</li>
<li>为一个区域填充颜色<ul>
<li>选中要填色的区域（不管用什么工具都行），alt+delete就会把现在颜色板上选择的颜色填充进去</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac -- vscode常用快捷键</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac/vscode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<ul>
<li>  md文件预览窗口呼出：打开md文件，command + k释放之后按v</li>
<li>  折叠代码：command + k + 0</li>
<li>  展开代码：</li>
<li>  回退：Ctrl + -</li>
<li>  为每个项目设置python虚拟环境</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac -- 实用软件</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac/%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<ul>
<li>  Transmit 这个软件可以用来将远程服务器上的文件以图形界面的形式展示出来（像是Windows里的资源管理器），然后可以通过拖动的方式上传下载文件</li>
<li>  iterm2 很好用的一个命令行工具，比原生的功能要多一些</li>
<li>  Sequel Pro 数据库连接工具，类似于Navicat</li>
<li>  Sublime Text 文本编辑工具，没用过原生的文本编辑器，这个挺好用的</li>
<li>  Charles 抓包工具</li>
<li>  snagit 截图软件，可以先找到mac破解版安装，然后找一个中文包下载后将所有文件复制到目录<code>/Applications/Snagit 2022.app/Contents/Resources</code>，重启即可</li>
<li>  jump desktop远程控制软件</li>
<li>  ishot一个简单的截图工具</li>
<li>  utools适配了各种插件的实用工具</li>
<li>  step two二次验证器</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>mac</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>windows -- OneNote</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/OneNote/</url>
    <content><![CDATA[<ol>
<li>OneNote无法创建新的笔记本，解决方法：win+r输入services.msc，在服务中找到webClient，开启，再试一下，应该就可以了</li>
</ol>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows -- eclipse</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/eclipse/</url>
    <content><![CDATA[<p>快捷键ctrl_alt+方向键 与eclipse冲突</p>
<p>        屏幕右键——图形属性——选项和支持——（左侧的）快捷键管理器——管理快捷键——禁用</p>
<ul>
<li>切换java jdk：window-&gt;preferences -&gt; java-&gt;installed jres 到这一步之后就可以选择切换了，点击add还可以添加新的jdk</li>
</ul>
<ul>
<li>给jsp页面设置默认编码：windows -&gt;preferences -&gt; 搜索jsp -&gt;打开jsp就可以设置encoding</li>
</ul>
<ul>
<li>关闭MyEclipse中的html或者jsp页面的可视化编辑界面：windows -&gt;　preferences -&gt; General -&gt; Editors -&gt;File Associations -&gt;以html为例，选中Myeclipse html Editor 点击Default。</li>
</ul>
<ul>
<li>将一个项目复制后创建的另一个项目需要修改它的context root，方法是在项目的配置中搜索 web project settings  ,修改context root名称为你想要的项目的名称；</li>
</ul>
<ul>
<li>如果一个项目上出现了一个比较大的颜色不深的红色的感叹号，表示这个项目中有的jar包失效了，一般导致的原因都是有一个已经被加载到项目中去的jar被我们手动的删除了，解决方法是在bulid path的配置里面把那个没有了的包移除；</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows -- java配置</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/java%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>java配置</p>
<p>2016年1月20日</p>
<p>14:45</p>
<p>java jdk配置：</p>
<p>        java_home:jdk的安装目录</p>
<p>        classpath: .</p>
<p>        path添加：；bin目录</p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows -- 一顿操作猛如虎</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E4%B8%80%E9%A1%BF%E6%93%8D%E4%BD%9C%E7%8C%9B%E5%A6%82%E8%99%8E/</url>
    <content><![CDATA[<p>windows下某个服务死掉了，一直启动或者一些异常死锁状态如何停止？</p>
<p>进入cmd（管理员）：wmic service where name=”service name” get/value</p>
<p>这时屏幕上会打印出该服务的信息，找到它的processId</p>
<p>taskkill /pid 刚才找出来的进程id</p>
<p>taskkill /F /pid PID    这个是强制停止</p>
<p>快捷键ctrl+e打开资源管理器时访问我的电脑</p>
<p>        打开我的电脑–左上角“文件”–更改文件和搜索选项–打开文件资源管理器时打开</p>
<p>快捷键ctrl_alt+方向键 与eclipse冲突</p>
<p>        屏幕右键——图形属性——选项和支持——（左侧的）快捷键管理器——管理快捷键——禁用</p>
<p>GPU和CPU</p>
<p>        CPU(Central Processing Unit)和GPU(Graphics Processing Unit)，他们都是计算处理器，内部结构大概是内存、控制器和计算模块。区别是CPU中内存和控制器占的比例要高得多，所以它对信息的处理能力要强很多，而GPU中计算模块的比例更高，所以它只做简单的逻辑处理，而进行大量的纯粹的运算，CPU一般核心都不会太多，而GPU核心都是上千个的。</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows -- 有道云笔记</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ol>
<li>广告屏蔽：（右侧截图中有确认可行的版本）</li>
</ol>
<p><img src="/img/C72A18808DC5493691E804EBCAC78C76.png"></p>
<ol>
<li><p>找到安装目录：C:\Program Files (x86)\Youdao\YoudaoNote\theme</p>
</li>
<li><p>打开build.xml，最好先备份一份</p>
</li>
<li><p>删除panelad标签ass属性里的 panelclient</p>
</li>
<li><p>AdWraperMid标签的bounds值修改为0，0，0，0</p>
</li>
<li><p>重启、关闭版本更新</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows -- 系统调整</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E7%B3%BB%E7%BB%9F%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<p>系统自身调整</p>
<p>2016年3月22日 </p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>Windows10安装后显卡有一个问题，在安装完显卡驱动后，右击刷新时，资源管理器占用的系统内存会不断增大，发生内存泄露，解决方法是：安装一个右键管家，把显卡的那几个选项去掉</p>
<h3 id="Windows更新（版本变更后不一定好用）"><a href="#Windows更新（版本变更后不一定好用）" class="headerlink" title="Windows更新（版本变更后不一定好用）"></a>Windows更新（版本变更后不一定好用）</h3><p>Windows10默认自动更新，解决方法：win+r输入gpedit.msc，计算机配置-&gt;管理模板-&gt;Windows组件-&gt;windows更新，在这个目录下把该禁用的都禁用了就行了</p>
<p>OneNote无法创建新的笔记本，解决方法：win+r输入services.msc，在服务中找到webClient，开启，再试一下，应该就可以了</p>
<h3 id="antimalware-service-executable占用资源"><a href="#antimalware-service-executable占用资源" class="headerlink" title="antimalware service executable占用资源"></a>antimalware service executable占用资源</h3><p>win10有一个服务antimalware service executable是在你进行磁盘读取时进行安全扫描的，会占用大量的cpu和磁盘读取速度，关闭方法：</p>
<p> win键+R键打开运行对话框框，输入gpedit.msc打开本地组策略编辑器（组策略）；</p>
<p>依次打开计算机配置-管理模板-Windows组件-Windows Defender；</p>
<p>如果要关闭Windows defender，则将“关闭 Windows Defender”项设置为“已启用”即可。</p>
<p>如果要保留Windows defender，只解决CPU占用和内存占用高的问题，则继续下列步骤；</p>
<p>打开“实时保护”，将里面的“不论何时启动实时保护，都会启动进程扫描”这一配置项设置为“已禁用”（此步骤最关键）；</p>
<p>打开“扫描”，将里面的以下几项设置为“已禁用”：</p>
<p>   （1）指定每天进行快速扫描的时间间隔；</p>
<p>   （2）仅当计算机处于打开但未使用状态才启动计划扫描；</p>
<p>   （3）指定每天进行快速扫描的时间；</p>
<p>   （4）指定每天的不同时间运行计划扫描；</p>
<p>     将“指定每周的不同时间运行计划扫描”设置为“从不”，并设置为“已启用”。</p>
<p>  </p>
<h3 id="台式电脑耳机连接问题"><a href="#台式电脑耳机连接问题" class="headerlink" title="台式电脑耳机连接问题"></a>台式电脑耳机连接问题</h3><p>台式电脑的音频服务可能出现问题，它默认检测机箱前面板的耳机和麦克插口，导致服务启动失败，表现为任务栏里的喇叭图标有一个小红叉，解决办法：打开控制面板，找到硬件和声音，Realtek高清晰音频管理器，然后看截图：</p>
<p><img src="/img/2F6233E826C14710985334C92EA7EF69.png"></p>
<p> </p>
<p> </p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows -- 解压版MySQL配置</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows/%E8%A7%A3%E5%8E%8B%E7%89%88MySQL%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>解压版的可以安装多个，不存在一个坏了之后去删注册表的事，所以配置解压版好一些，一下为具体步骤：</p>
<ol>
<li><p>下载一个解压版的MySQL</p>
</li>
<li><p>随便解压到硬盘的一个地方</p>
</li>
<li><p>配置path环境变量，在后面追加一个bin目录的路径</p>
</li>
<li><p>修改my.ini文件，这个文件不一定有，没有就自己创建一个就好，在MySQL的根目录里一定会有一些ini的配置文件，有时候有好多个，这些都是对MySQL的不同配置，按照服务的系统大小，都不是关键，选个一就好了，在里面的[mysqld] 下添加下面的内容：</p>
</li>
<li><p>basedir=C:\Program Files\MySQL\MySQL Server 5.6（mysql所在目录） </p>
</li>
</ol>
<p>datadir=C:\Program Files\MySQL\MySQL Server 5.6\data （mysql所在目录\data）</p>
<ol>
<li><p>以管理员身份运行cmd（一定要用管理员身份运行，不然权限不够），进入MySQL的bin目录下，运行 mysqld -install</p>
</li>
<li><p>在刚才的路径下运行net start mysql,这个是为了启动服务，这一步有可能一直卡着，是因为我们在之前可能通过手动启动mysqld服务了，进入电脑的详细服务里面把多出来的mysqld服务结束掉了</p>
</li>
<li><p>服务启动完成就可以登录了，初次登录root是没有密码的直接回车就好</p>
</li>
<li><p>经过上面的步骤之后，就可以在普通的cmd里面进入数据库了</p>
</li>
<li><p>补充一下如果是重装了系统的情况，那就只要配置path，在启动的时候如果报错了，就看一看第4步对应的路径是否正确</p>
</li>
<li><p>删除MySQL服务的方法：cmd（最好是管理员）sc delete mysql</p>
</li>
</ol>
<p>MySQL5.7.20版本解压配置</p>
<ul>
<li><p>下载解压版，这个地方最好下载对应系统位数的版本</p>
</li>
<li><p>将文件解压到任意文件夹，在环境变量 path中添加bin目录的路径</p>
</li>
<li><p>以管理员身份运行cmd（一定要用管理员身份运行，不然权限不够），进入MySQL的bin目录下，运行 mysqld -install</p>
</li>
<li><p>执行mysqld –initialize-insecure –user=mysql  进行初始化</p>
</li>
<li><p>执行net start MySQL</p>
</li>
</ul>
<p>差别：在5.7.18版本开始MySQL不再有init文件，也没有data文件夹，需要执行初始命令后才会生成data目录</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB -- InnoDB-存储引擎</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/InnoDB/InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><p><img src="/img/24417.png" alt="image"><br>上图为InnoDB存储引擎的架构，下面会对各个模块进行拆解</p>
<h3 id="1-1-后台线程"><a href="#1-1-后台线程" class="headerlink" title="1.1 后台线程"></a>1.1 后台线程</h3><ul>
<li>master Thread：负责将缓冲池中的数据异步的刷新到磁盘上，维护数据一致性</li>
<li>IO Thread：进行异步IO管理线程</li>
<li>Purge Thread：负责对undo页进行回收，在InnoDB1.0版本之前这个工作是放到master线程上进行处理的</li>
<li>Page Cleaner Thread：负责处理脏页的刷新工作</li>
</ul>
<h3 id="1-2-内存"><a href="#1-2-内存" class="headerlink" title="1.2 内存"></a>1.2 内存</h3><p><img src="/img/24420.png" alt="image"></p>
<h4 id="1-2-1-缓冲池"><a href="#1-2-1-缓冲池" class="headerlink" title="1.2.1 缓冲池"></a>1.2.1 缓冲池</h4><ul>
<li>本质就是一个缓存机制，帮助解决磁盘和CPU之间读写速度差距过大的问题，我们来具体看看InnoDB的缓存机制是怎么样的</li>
<li>大体的流程是通用的，CPU只面向内存进行读写，数据需要先加载到缓冲池中，如果数据页已经在缓冲池中那就可以直接使用这个叫做缓冲池命中，而缓冲池和磁盘的同步并不是每次页数据发生更改就会进行同步，而是依赖一种叫Checkpoint的机制</li>
<li>所以我们可以看出缓冲池的大小是很大程度上决定了数据库处理速度的，我测试了一下我个人的服务器上这个缓冲池的大小是一个G</li>
<li>从InnoDB1.0开始就允许存在多个缓冲池，</li>
</ul>
<h4 id="1-2-2-缓冲池管理"><a href="#1-2-2-缓冲池管理" class="headerlink" title="1.2.2 缓冲池管理"></a>1.2.2 缓冲池管理</h4><p>上面说了缓冲池是一片内存区域，现在我们来了解一下这片内存区域是如何进行管理的</p>
<p><strong>LRU(Latest Recent Used)</strong></p>
<p>最近最少使用算法，思想是使用频繁的页被放在LRU列表的前端，使用少的页放在尾端，当缓冲池中放不下新读取到的页时，首先释放LRU列表中尾端的页</p>
<ul>
<li>InnoDB中对LRU进行了一些优化，加入了一个midpoint位置，新读取到的页不是直接放到LRU的首部，而是放在这个midpoint位置，这个策略就是为了避免大量的读取页的时候将之前的热度页全给冲掉了（说的就是那种性能糟糕的查询或者全表查询读取了大量的页），默认情况下这个midpoint是LRU列表长度的3/8处（可以进行设置），InnoDB中将midpoint之后的列表成为old列表，之前的叫new列表，这里就和JVM命名思路相反了，这里的new才是热度数据  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看midpoint参数，默认值是37，即37%差不多3/8</span><br><span class="line">show variables like &#x27;innodb_old_blocks_pct&#x27;</span><br><span class="line"># 设置</span><br><span class="line">set global innodb_old_blocks_pct=38</span><br></pre></td></tr></table></figure></li>
<li>这里还有一个参数叫做innodb_old_blocks_time，表示页被放到mid后多久也就是old列表页中的数据存活多久之后会被放到new中，很有JVM分代的感觉了，具体的设置方法  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这里书上没有说这个1000的时间单位是什么</span><br><span class="line">set global innodb_old_blocks_time=1000;</span><br></pre></td></tr></table></figure></li>
<li>页从old部分加入到new的操作叫page made young，设置了innodb_old_blocks_time导致页没有从old部分转移到new的操作叫page not made young  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过这个命令可以看到数据库中页的信息以及一段时间内made young的操作次数（得往下拉）</span><br><span class="line">show engine innodb status</span><br></pre></td></tr></table></figure>
  <img src="/img/24369.png" alt="image"><br>  这里也简单的介绍一下：<ul>
<li>Buffer pool size表示共有多少个页x16k（默认每个页是16k）即缓冲池的总大小1.5G</li>
<li>这里的database pages就是上面图里面的data page，以及下面的old列表，之后还有pages made young的操作次数</li>
<li>Buffer pool hit rate就是指命中率，低于95%就可能是出现了LRU列表污染问题了</li>
<li>之后还有一个LRU len和unzip_LRU len这里的unzip是指压缩，上面不是说了默认一个页的大小是16k嘛，但是从InnoDB 1.0.x开始支持压缩页的功能，可以将16k的页压缩为1、2、4、8k，这里不详细介绍压缩的机制，大概是压缩率是不同的，所以刚才说的几个大小的空间是分开进行管理的，压缩完成后找对应大小的空间进行存储，如果对应大小的空间没有空闲页了就去找一个更大的空间的空闲页进行拆分，比如一个页压缩后是4k结果4k的空间没有空闲了就去将一个8k拆为两个4k一个用于存储，一个成为4k空闲页</li>
<li>在LRU列表中的页被修改之后就成了脏页，也就是缓冲数据与磁盘中的数据不一致，通过Checkpoint技术将脏页刷新回磁盘，所以Flush列表中的页即为脏页，脏页同时存在于LRU和Flush列表中，Modified db pages就是展示了脏页的数据</li>
</ul>
</li>
</ul>
<h4 id="1-2-3-重做日志缓冲"><a href="#1-2-3-重做日志缓冲" class="headerlink" title="1.2.3 重做日志缓冲"></a>1.2.3 重做日志缓冲</h4><p>就是重做日志的缓存，默认的值是8M，在一下三种情况下会将缓存刷新到磁盘中</p>
<ul>
<li>Master Thread每秒刷新一次</li>
<li>每个事务提交时刷新</li>
<li>重做日志缓冲剩余空间小于一半时</li>
</ul>
<h4 id="1-2-4-额外的内存池"><a href="#1-2-4-额外的内存池" class="headerlink" title="1.2.4 额外的内存池"></a>1.2.4 额外的内存池</h4><p>上面说了一些数据结构，例如缓冲池中帧缓冲和对应的缓冲控制对象（LRU、锁）等，这些对象本身占用的内存是从额外内存池中申请的</p>
<h2 id="二、CheckPoint技术"><a href="#二、CheckPoint技术" class="headerlink" title="二、CheckPoint技术"></a>二、CheckPoint技术</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>上面说了数据库通过缓冲的机制来协调CPU和磁盘之间的代沟，但是如果每次缓存中的数据页内容发生变化的时候就将数据刷新到磁盘的话IO开销会特别大（等于没有缓存），于是肯定是需要累积一部分的数据后再做刷新；</p>
<p>这样会产生一个新的问题，屯了一批脏页，如果在缓冲池将页刷新到磁盘的过程中发生宕机，那这部分的数据就不能恢复了，目前对于这个问题通用的解决方案是“Write Ahead Log”，即当事务提交时先写重做日志，再修改页（这里应该是写日志只需要一次寻址写入即可，而写页的话需要很多次的寻址？），出现宕机时还可以通过重做日志来完成数据的恢复（重做日志上面有说写入的机制，反正就是很及时，最多损失一秒的数据）</p>
<h3 id="2-2-机制探索"><a href="#2-2-机制探索" class="headerlink" title="2.2 机制探索"></a>2.2 机制探索</h3><p>现在有了缓存，也有了重做日志，进行设想，如果缓存和重做日志的容积都足够大的话，完全就不需要将数据刷新到磁盘了，正常运行的时候直接访问缓存，宕机了通过重做日志进行恢复；</p>
<p>问题在于内存比磁盘贵，重做日志也不好进行磁盘空间分配，整体来说是不合理的，及时都满足了，那发生宕机后需要将所有的重做日志都执行一遍可能要好几个月</p>
<p>于是CheckPoint技术出现了，解决以下几个问题</p>
<ul>
<li>缩短数据恢复时间：很好理解，CheckPoint之前的数据刷新过了不用再执行了（CheckPoint过程中发生宕机怎么办）</li>
<li>缓冲池不够用是，将脏页刷新到磁盘：LRU算法中的会溢出最近最少使用的页，如果溢出的是脏页，需要强制执行CheckPoint将脏页刷新到磁盘（这里是溢出的脏页还是所有脏页）</li>
<li>重做日志不可用时，刷新脏页：数据库对重做日志是循环的去写入的，当新的日志要去做覆盖的时候，如果被覆盖的日志内容还没有被刷新到磁盘，那必须强制CheckPoint</li>
</ul>
<h3 id="2-3-LSN"><a href="#2-3-LSN" class="headerlink" title="2.3 LSN"></a>2.3 LSN</h3><p><img src="/img/24397.png" alt="image"></p>
<p>通过Log Sequence Number来标记版本，仍然是在show engine innodb status命令中可以看到版本信息</p>
<h3 id="2-4-CheckPoint的详细机制"><a href="#2-4-CheckPoint的详细机制" class="headerlink" title="2.4 CheckPoint的详细机制"></a>2.4 CheckPoint的详细机制</h3><p>在上面的笔记中就提出了一些问题，CheckPoint到底是全量的将脏页刷新到磁盘还是局部的，这里来详细的说明，CheckPoint在InnoDB中有两种类型：</p>
<ul>
<li>Sharp CheckPoint：在数据库关闭的时候，全量刷新脏页</li>
<li>Fuzzy CheckPoint：局部刷新<ul>
<li>Master Thread CheckPoint：每一秒或十秒刷新一定比例的脏页，异步，请求操作不会被阻塞</li>
<li>Flush_LRU_List CheckPoint：InnoDB会保证LRU中保持有100个页可用，老版本中这个查询工作是在用户查询线程中进行的，会阻塞用户查询，新版本这个检查的工作被放到了独立的Page Cleaner线程中且默认数值变为了1024；检查出现空闲页不足时要将LRU尾部的页移除，如果这里面存在脏页则需要进行CheckPoint</li>
<li>Async/Sync Flush CheckPoint：都是为了保证重做日志的可用性，我们将没有进行过CheckPoint的日志内容定义为未处理（这里之所以会是两种处理方式，是由于老版本中Async会阻塞发现问题的用户查询线程，而Sync会阻塞所有用户线程；新版中都已经放到了Page Cleaner线程中，估计区别已经消失了）<ul>
<li>当未处理内容小于总量的75%时不需要刷新</li>
<li>当未处理内容大于75%小于90%时进行Async刷新，使得刷新后的未处理内容小于总量的75%</li>
<li>当未处理内容大于90%时进行sync刷新，使得刷新后的未处理内容小于总量的75%</li>
</ul>
</li>
<li>Dirty Page too much CheckPoint：当缓冲池中脏页占比大于75%时强制进行CheckPoint，刷新部分脏页</li>
</ul>
</li>
</ul>
<h2 id="三、Master-Thread的工作方式"><a href="#三、Master-Thread的工作方式" class="headerlink" title="三、Master Thread的工作方式"></a>三、Master Thread的工作方式</h2><h3 id="3-1-1-0-x之前的工作方式"><a href="#3-1-1-0-x之前的工作方式" class="headerlink" title="3.1 1.0.x之前的工作方式"></a>3.1 1.0.x之前的工作方式</h3><p>master thread具有最高的线程优先级,内部由主循环、后台循环、刷新循环、暂停循环组成.</p>
<h3 id="3-1-1-主循环-Loop"><a href="#3-1-1-主循环-Loop" class="headerlink" title="3.1.1 主循环(Loop)"></a>3.1.1 主循环(Loop)</h3><p>主循环内主要有两部分的操作:每秒钟执行的逻辑和每十秒执行的逻辑;</p>
<ul>
<li>每秒执行的逻辑:<br>日志缓冲刷新到磁盘,即使事务还没有提交</li>
<li>合并插入缓冲</li>
<li>至多刷新100个脏页到磁盘</li>
<li>如果当前没有用户活动,切换到后台循环<br>每十秒执行的逻辑:</li>
<li>刷新100个脏页到磁盘</li>
<li>合并至多5个插入缓冲</li>
<li>将日志缓冲刷新到磁盘</li>
<li>删除无用的Undo页</li>
<li>刷新100或10个脏页到磁盘<h3 id="3-1-2-后台循环-background-Loop"><a href="#3-1-2-后台循环-background-Loop" class="headerlink" title="3.1.2 后台循环(background Loop)"></a>3.1.2 后台循环(background Loop)</h3>当前没有用户活动或者数据库关闭时切换到这个循环,执行的操作如下</li>
<li>删除无用的Undo页</li>
<li>合并20个插入缓冲</li>
<li>跳回到主循环</li>
<li>不断刷新100个页直到符合条件(可能跳转到刷新循环中)</li>
</ul>
<h3 id="3-2-1-2-x之前的工作方式"><a href="#3-2-1-2-x之前的工作方式" class="headerlink" title="3.2 1.2.x之前的工作方式"></a>3.2 1.2.x之前的工作方式</h3><p>由于磁盘读写速度的加快,固态硬盘的出现,应对更高的写入场景时mater thread中对缓冲刷新到磁盘的限制显得太保守了,不能很好的发挥性能,所以做了一下的调整</p>
<ul>
<li>合并插入缓冲是,动态的决定合并的数量</li>
<li>刷新脏页时动态的决定刷新的数量<h3 id="3-3-1-2-x的工作方式"><a href="#3-3-1-2-x的工作方式" class="headerlink" title="3.3 1.2.x的工作方式"></a>3.3 1.2.x的工作方式</h3>再次优化了master thread的逻辑,将脏页刷新的工作分离到了单独的Page Cleaner Thread线程中,提高了系统并发性</li>
</ul>
<h2 id="四、InnoDB关键特性"><a href="#四、InnoDB关键特性" class="headerlink" title="四、InnoDB关键特性"></a>四、InnoDB关键特性</h2><ul>
<li>插入缓冲</li>
<li>两次写</li>
<li>自适应hash索引</li>
<li>异步IO</li>
<li>刷新领接页</li>
</ul>
<h3 id="4-1-插入缓冲"><a href="#4-1-插入缓冲" class="headerlink" title="4.1 插入缓冲"></a>4.1 插入缓冲</h3><ul>
<li><p>Insert Buffer</p>
<p>  对于主键索引由于数据存储是连续的（不连续属于设计不合理），所以插入操作速度很快，但是对于普通索引来说一般都是离散分布的，所以插入的效率不高（涉及数据的移动），于是为普通索引设计了Insert Buffer</p>
<p>  原理就是将数据插入的操作放到缓存里面，如果有多次对同一个索引的修改就可以进行合并插入，避免索引上数据多次的移动</p>
<p>  必须要满足两个条件：是辅助索引、索引不是唯一的</p>
<p>  从原理可以看出在一个写入密集型的系统中Insert Buffer对缓冲池的占用会很大，默认最大值是二分之一</p>
</li>
<li><p>Change Buffer</p>
<p>  本质是Insert Buffer的升级版，在Innodb 1.0.x中给update、delete操作也加入了缓存，分为了Insert、delete、purge，delete是将数据标记为删除，而purge是真正将记录删除</p>
<p>  <img src="/img/24578.png" alt="image"><br>  这里merged operations里面展示了insert、delete、purge的次数；而下面的discarded operations表示数据</p>
<h3 id="4-2-两次写"><a href="#4-2-两次写" class="headerlink" title="4.2 两次写"></a>4.2 两次写</h3><p>如果服务器在脏页刷新到磁盘的过程中出现了宕机，对应页的数据会被损坏（），这个时候通过重做日志无法修复（没有完整的页信息，只有操作信息），两次写即是为了解决这个问题<br><img src="/img/24910.png" alt="image"></p>
</li>
</ul>
<p>具体实现是：中内存和磁盘中开辟两个2M的空间作为缓存，先将脏页放到doublewrite buffer中，再刷新到磁盘（1M），注意这个时候由于着1M的空间是连续的顺序写入效率很高，如果发生宕机还可以用doublewrite中的数据进行恢复（内存中别的数据可以通过重做日志进行恢复）</p>
<p>部分文件系统本身提供了写失效防范机制，如ZFS文件系统，这个时候就可以关闭两次写，另外如果是主从结构中的从服务器可以进行关闭来提高速度（数据本来就备份）</p>
<h3 id="4-3-自适应hash索引（adaptive-hash-index-AHI）"><a href="#4-3-自适应hash索引（adaptive-hash-index-AHI）" class="headerlink" title="4.3 自适应hash索引（adaptive hash index AHI）"></a>4.3 自适应hash索引（adaptive hash index AHI）</h3><p>InnoDB存储引擎会自动为一些频繁查询的索引创建AHI（hash的时间复杂度为O(1)）,由于这些hash索引都是通过缓冲池中的B+树页创建，所以速度很快，且这个策略是存储引擎自己的机制不用人为的干涉</p>
<ul>
<li><p>创建的条件</p>
<ul>
<li>同一个sql结构访问了100次</li>
<li>页通过该模式访问了N次，N=页中记录*1/16</li>
</ul>
</li>
<li><p>启用后读取和写入速度提升2倍，负责索引的连接操作性能提高5倍<br><img src="/img/24980.png" alt="image"></p>
</li>
<li><p>同样可以通过<code>show engine innidb status</code>来查看AHI的工作情况，这里可以看到目前数据库中AHI的使用不是很好</p>
<h3 id="4-4-异步IO"><a href="#4-4-异步IO" class="headerlink" title="4.4 异步IO"></a>4.4 异步IO</h3><p>用户需进行数据查询时可能需要扫描磁盘上多个页的数据，这个时候只要发出一个页的IO请求后不必等待响应直接发出下一个IO请求，这就叫做异步IO，一看原理就知道很省时间</p>
</li>
<li><p>IO merge：单要访问的几个页是连续的（每个页大小是16k）时候就不用发起多个请求，直接从起点读取48k数据即可</p>
</li>
<li><p>Native AIO：1.1.x版本之前AIO是通过存储引擎的代码模拟实现的，之后提供了内核级别的AIO支持成为Native AIO，需要libaio库的支持，Windows和Linux都提供了支持，但是Mac OSX没有</p>
</li>
<li><p>AIO同样可以进行手动关闭</p>
</li>
<li><p>read ahead方式的读取都是通过AIO完成的，脏页的刷新，即磁盘的写入则全部由AIO完成</p>
</li>
</ul>
<h3 id="4-5-刷新领接页"><a href="#4-5-刷新领接页" class="headerlink" title="4.5 刷新领接页"></a>4.5 刷新领接页</h3><p>InnoDB提供了Flush Neighbor Page的特性，即是一个脏页刷新时检查所在区的所有页，如果是脏页则一起刷新，参考AIO可以进行IO merge操作，在机械硬盘上有显著的优势，需要考虑一下两个问题</p>
<ul>
<li>如果临近的脏页其实不怎么脏，之后又很快的变成了脏页？</li>
<li>==固态硬盘有着较高的IOPS==，是否还需要这个特性？</li>
</ul>
<p>结论是固态硬盘就不建议开这个特征了</p>
<h2 id="五、启动、关闭与恢复"><a href="#五、启动、关闭与恢复" class="headerlink" title="五、启动、关闭与恢复"></a>五、启动、关闭与恢复</h2><p>这里就简单说一下，关闭时候大概分为三个级别<code>innodb_fast_shutdown</code>取值0、1、2，每个级别对不同的启动方式</p>
<ul>
<li>0 完成所有的full purge和merge insert buffer，并将所有的脏页刷回磁盘，这个级别的问题在于  慢！</li>
<li>1 只需要将缓冲池中的一些脏页刷新到磁盘（估计就是一些已经进行刷新流程的数据），这是默认的级别</li>
<li>2 只将日志都写入日志文件（日志缓存很小好像是2M），操作极快，坏处是下次启动时需要进行事务恢复操作</li>
</ul>
<p>对于服务器意外宕机、手动kill mysql或者设置为2时启动的时候都需要进行恢复操作，可以通过<code>innodb_force_recovery</code>来配置恢复情况，默认为0，会对数据进行恢复，还有一些特殊情况，比如是alter表结构的时候发生了意外，数据库重启，这个时候如果进行自动恢复需要很长的时间，可以选择人为的干涉</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB -- InnoDB-文件</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/InnoDB/InnoDB-%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="参数文件"><a href="#参数文件" class="headerlink" title="参数文件"></a>参数文件</h2><p>这个可以直接视作配置文件，mysql通过这些参数来确定各类型文件的位置，以及设置一些内存分配和策略</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--通过这个命令可以看到具体的配置加载顺序--&gt;</span><br><span class="line">mysql --help | grep my.cnf</span><br><span class="line">输出：/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure>

<h3 id="什么是参数"><a href="#什么是参数" class="headerlink" title="什么是参数"></a>什么是参数</h3><p>键值对</p>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p>分为动态和静态，就是有些参数可以在数据库启动后修改仍然生效，有的必须预先设置才会生效</p>
<p>动态修改的时候分为global和session，字面意思</p>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>记录了启动、运行和关闭过程中的异常，遇到问题时查看这个日志可以进行问题定位</p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--查看是否开启慢查询--&gt;</span><br><span class="line">show variables like &#x27;slow_query_log&#x27;</span><br><span class="line">&lt;!--查看慢查询阈值--&gt;</span><br><span class="line">show variables like &#x27;long_query_time&#x27;</span><br><span class="line">&lt;!--查看当前日志记录的方式--&gt;</span><br><span class="line">show variables like &#x27;log_output&#x27;</span><br><span class="line">&lt;!--慢日志表查询--&gt;</span><br><span class="line">show variables like &#x27;log_output&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>所谓慢查询是运行时间超过某个阈值的sql，默认是10s</li>
<li>另一个是如果一个sql运行没有使用索引，也会被写入慢查询，通过<code>log_queries_not_using_indexes</code>进行配置，还有一个参数可以对这个类型的sql每分钟能写入慢查询日志的数量进行限制</li>
<li>通过mysqldumpslow 接慢查询日志文件，统计出执行时间最长的10条sql</li>
<li>还可以将慢查询记录放到表中，可以更方便直观抖进行分析，这个表叫slow_log，这个表使用的是CSV引擎，大数据量的查询效率不高，可以改为MyISAM，但是会消耗更多的性能</li>
</ul>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>会记录所有的请求信息，包括一些权限验证失败的请求</p>
<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>binary log也就是平时说的binlog，这个会记录所有对数据进行了修改的操作，select和show这类的查询操作不会进行记录，但如果是一个更新语句，即使这个语句没有真正的造成数据的改动也同样会被记录</p>
<ul>
<li>主要作用：<ul>
<li>恢复，这块举例说了在数据库全备份文件恢复后，进行point-in-time的恢复（这个和redis的混合备份比较像了）</li>
<li>复制，从库可以复制和执行binlog来进行数据同步（==所以要进行读写分离，是否只有一台机器负责写入，那么如果只有一台机器复制写的话，这个瓶颈如何处理==）</li>
<li>审计：==判断是否有注入攻击，这个不明白==</li>
</ul>
</li>
<li>默认是不会启动的，官方说启动这个日志会使得性能下降1%，但从收益来看是完全可以接受的</li>
<li>max_binlog_size：配置文件大小，默认1G，超过后会创建新的文件</li>
<li>binlog_catch_size：使用事务时，会将未提交的事务binlog日志写入到缓存中，这个参数控制单个事务分配的缓存空间大小，如果事务的binlog大于了该配置会将binlog写入到一个临时文件中，所以可以看到如果配置过大浪费空间，配置过小性能降低  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--查看binlog配置大小--&gt;</span><br><span class="line">show variables like &#x27;binlog_cache_size&#x27;</span><br><span class="line">输出：binlog_cache_size	1048576</span><br><span class="line"></span><br><span class="line">&lt;!--查看使用情况--&gt;</span><br><span class="line">show global status like &#x27;binlog_cache%&#x27;</span><br><span class="line">结果：磁盘使用次数很少，配置没问题</span><br><span class="line">Binlog_cache_disk_use	34</span><br><span class="line">Binlog_cache_use	404051762</span><br></pre></td></tr></table></figure></li>
<li>sync_binlog：binlog写磁盘流程有事务缓存操作的，这个配置默认为0即不开启同步，带来的问题就是缓存中的数据会丢失；开启同步后的问题是事务还没有被提交就被写入日志了，这时候发生了宕机，启动的时候由于事务没有提交会被回滚，但是二进制文件中记录了该事务的信息不能回滚，可以通过设置 <code>innodb_support_xa</code> 为1来解决，同时这个配置会确保binlog和InnoDB存储引擎数据文件的同步</li>
<li>binlog-do-db：决定哪些binlog需要写入，binlog-ignore-db：哪些binlog不需要写入，这俩默认都为空即使说所有binlog都写入</li>
<li>log-slave-update：如果是slave库，那就不需要将master复制过来执行的binlog再进行记录了</li>
<li>binlog_format：影响日志文件的格式，在5.1之前没有这个参数，binlog的格式都是基于SQL语句（statement）级别；导致的问题是主从同步时rand、uuid等函数或者触发器可能会导致数据不一致；且默认的隔离级别repeatable read也是由于这个格式关系，如果使用read committed会出现类似丢失更新的现象，5.1之后格式可配置<ul>
<li>statement：SQL语句</li>
<li>row：记录表的行更改情况，解决了statement的问题，这个时候可以将隔离级别设置为read committed来获得更好的并发性；坏处是日志文件的体积会有增加，网络传输的消耗增加；原因是假如用一个SQL修改10w行数据，statement只需要记录SQL即可（200b），但是row需要将这10w行修改都记录下来（13M）差距非常非常大</li>
<li>mixed：就是上述两个混用，默认使用statement，再statement可能会出现问题的情况下会使用row，这里不一一列举</li>
</ul>
</li>
</ul>
<h2 id="套接字文件"><a href="#套接字文件" class="headerlink" title="套接字文件"></a>套接字文件</h2><p>==Unix系统通过套接字进行数据库连接的时候会创建一个.sock文件==</p>
<h2 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h2><p>MySQL服务启动的时候会把服务的PID写入这个文件</p>
<h2 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h2><p>由于MySQL是插件式存储引擎的体系结构关系，真正表中的数据存储是交给存储引擎来进行决策的，但是表结构定义的记录都是以frm为后缀的文件进行存储的</p>
<h2 id="InnoDB存储引擎文件"><a href="#InnoDB存储引擎文件" class="headerlink" title="InnoDB存储引擎文件"></a>InnoDB存储引擎文件</h2><p>上面介绍的文件都是MySQL自己规范中的文件，下面介绍InnoDB存储引擎自己特有的文件</p>
<h3 id="表空间文件"><a href="#表空间文件" class="headerlink" title="表空间文件"></a>表空间文件</h3><p><img src="/img/25207.png" alt="image"></p>
<p>InnoDB表数据分为三部分，表结构定义文件是由MySQL进行管理的，表中的数据可以存储在共享表空间中也可以单独进行存储（也可以指定几个表的数据存储在一起），一般都会分开进行存储，需要做数据清理的时候比较快捷</p>
<h3 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h3><p>redo log，这个之前已经介绍过基础的运行原理了，为了保证数据的可靠性，每个InnoDB至少有一个重做日志组，每个组下至少有两个重做日志文件，用户还可以设置多个镜像日志文件组放到不同的磁盘上来提高可靠性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">innodb_log_file_size    //每个重做日志文件的大小</span><br><span class="line">innodb_log_files_in_group   //一个组内重做日志文件数量</span><br><span class="line">innodb_mirrored_log_group   //镜像文件组数量</span><br><span class="line">innodb_log_group_home_dir   //日志文件组路径</span><br></pre></td></tr></table></figure>
<ul>
<li>每个组内，默认是两个日志文件，进行循环写入，一个满了写到第二个文件，第二个满了再次写到第一个文件（单个文件最大限制为512G）</li>
<li>关于重做日志的大小，不能设置太大，那样数据恢复的时间会很长，也不能太小，可能导致一个事务的日志需要多次切换日志文件，且会导致频繁进行async CheckPoint导致性能抖动</li>
<li>redo log和binlog的区别<ul>
<li>binlog会记录所有与MySQL有关的日志文件（修改相关），它是MySQL的日志机制之一，而redo log是InnoDB的只存储引擎本身的事务文件</li>
<li>内容上binlog记录的是逻辑操作（statement、row和mixed都是）记录的是事务的具体操作（开发者写的SQL语句，人能看懂），而redo log记录的是数据页的更改的物理情况（人看不懂）</li>
<li>写入时间不同，binlog只在事务提交前进行提交（事务执行中使用了缓存，binlog相当于只记录执行成功的SQL语句），redo log是在事务进行中就不断的进行记录了（事务过程中页的数据不断的被修改）</li>
</ul>
</li>
<li>重做日志的流程是从缓存中写入到磁盘，这个过程每次写入512字节，也就是一个扇区的大小，由于扇区已经是写入的最小单位所以不会出现写到一半失败而导致数据损坏的问题，不需要doublewirte</li>
<li>重做日志缓存刷新到磁盘的情况，第一是master进程每秒执行一次，第二是事务提交的时候，通过<code>innodb_flush_log_at_trx_commit</code>进行配置，取值有0、1、2<ul>
<li>0表示不在事务提交时进行刷新，完全进行这个工作交给master</li>
<li>1表示将缓冲同步刷新到磁盘，这个时候持久性可以得到保障（不能再去考虑缓冲刷新的过程中宕机，这种原子粒度的丢失无法避免）</li>
<li>2表示异步的进行刷新，也就是通知操作系统去做，这个时候如果服务器宕机，那这些数据就丢失了，如果只是MySQL挂了，那文件系统缓存还在可以正常恢复</li>
</ul>
</li>
<li>redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB -- InnoDB-索引</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/InnoDB/InnoDB-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="索引与算法"><a href="#索引与算法" class="headerlink" title="索引与算法"></a>索引与算法</h1><h2 id="存储索引概述"><a href="#存储索引概述" class="headerlink" title="存储索引概述"></a>存储索引概述</h2><p>InnoDB支持的几种索引：B+树（不是二叉binary，是balance）、全文、hash</p>
<p>B+数这个后面展开讲，hash是自适应的不受人为的干涉，全文这里也没讲是啥</p>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><p>这里就是简单的介绍一下相关的算法和结构</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>需要数据本身就排好序的，折半查找</p>
<h3 id="二叉查找树和平衡二叉树"><a href="#二叉查找树和平衡二叉树" class="headerlink" title="二叉查找树和平衡二叉树"></a>二叉查找树和平衡二叉树</h3><p>二叉查找树就一个左小右大的二叉树，不要求平衡，性能不是很高</p>
<p>平衡二叉树就是平衡的二叉查找树，平衡二叉树的查询性能是比较高的，最高的是最优二叉树，但这个东西构建和维护的开销大，一般只需要建立一个平衡二叉树</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><img src="https://ynote-resource-dl.lx.netease.com/ydl/resource?key=qq7AE1C3EC95D8BC3B8E19DFC70C1C83F1/5D92DB116C784279AE10A6613E638A43&mime=image/png&name=image.png&reqId=3c0c1e25-702c-449c-b49c-e1cda8a312d5&ts=1611313960750&type=NOS&sign=001ca2857676405f28d76d149c3377f4" alt="image"></p>
<p>这个图可以很好的说明B+树的基础机构</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>这里就简单说一下</p>
<ul>
<li>如果叶子节点和它的父节点都没满的话，就直接插入，这个时候最理想</li>
<li>如果叶子节点满了但是它的父节点还没满的话，那就分裂子节点把子节点的中间值放到父节点去</li>
<li>如果叶子节点和它的父节点都满了的话，就要先分裂子节点，再分裂父节点</li>
<li>另外如果叶子节点满了，但是做兄弟节点没满的话不会直接做分裂，左兄弟会检查做旋转操作来节省开销</li>
</ul>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>它这里给每个节点设置最少也有有一半的数据，如果低于了一半那就需要做节点的合并，具体的合并规则这里不展开说了</p>
<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><ul>
<li>首先聚簇索引是指行数据会存储在B+树的叶子结点上，非聚簇索引的叶子节点上存储的上聚簇索引的索引数据也就是主键</li>
<li>InnoDB的表数据就是通过一颗主键聚簇索引进行存储的</li>
<li>聚簇索引在磁盘上存储的时候是逻辑上连续的，由于叶子结点通过双向链表进行了连接，物理页不要求完全连续（会多出寻址时间）</li>
</ul>
<h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>也就是非聚簇索引</p>
<ul>
<li>如果查询的数据在辅助索引上没有那就需要去聚簇索引上查询，叫做回表</li>
</ul>
<h3 id="B-树索引的分裂"><a href="#B-树索引的分裂" class="headerlink" title="B+树索引的分裂"></a>B+树索引的分裂</h3><p>B+树索引的分裂并不总是从页中间开始，会做一些优化来决定是向左还是向右分裂</p>
<h3 id="B-树索引的管理"><a href="#B-树索引的管理" class="headerlink" title="B+树索引的管理"></a>B+树索引的管理</h3><ul>
<li>创建和删除的语句这里就不列举了</li>
<li>查看索引信息时有一个参数比较重要，cardinality可以叫做基数，这个数越大索引能发挥更好的性能，这个值是预估出来的不完全准确，可以通过analyze table来主动的让InnoDB对基数进行重新统计</li>
</ul>
<h3 id="索引创建-amp-删除的方法"><a href="#索引创建-amp-删除的方法" class="headerlink" title="索引创建&amp;删除的方法"></a>索引创建&amp;删除的方法</h3><p>5.5之前使用的方法：</p>
<ul>
<li>创建一张临时表</li>
<li>把原表数据导入到临时表中</li>
<li>删除原表、重命名临时表</li>
</ul>
<h4 id="Fast-Index-Creation"><a href="#Fast-Index-Creation" class="headerlink" title="Fast Index Creation"></a>Fast Index Creation</h4><p>InnoDB 1.0开始支持Fast index creation，对于辅助索引的创建，中表上面加一个S锁，创建的过程中不需要重新建表，速度和可用性都提高了很多</p>
<p>弊端是表加了S锁之后只读，对于写入的事务不能处理，只限定与辅助索引</p>
<h4 id="online-schema-change"><a href="#online-schema-change" class="headerlink" title="online schema change"></a>online schema change</h4><p>FB发明的，后来被官方集成了，大致方法也没读懂，创建一个新表进行alter table操作，将数据导入新表，创建一个detail表用来记录导入过程中发生的数据修改，最后将detail表中的数据通过日志刷新到新表，删除原表、重命名新表</p>
<h4 id="online-DDL"><a href="#online-DDL" class="headerlink" title="online DDL"></a>online DDL</h4><p>mysql 5.6版本开始支持，允许辅助索引创建的同时进行DML的操作，一下几类DDL支持在线方式：</p>
<ul>
<li>辅助索引的创建和删除</li>
<li>改变自增长值</li>
<li>添加或删除外键约束</li>
<li>列的重命名<br>实现原理是，在DDL过程中发生的DML操作写入到缓存中，等DDL完成后将缓冲写入表</li>
</ul>
<h2 id="Cardinality值"><a href="#Cardinality值" class="headerlink" title="Cardinality值"></a>Cardinality值</h2><p>基数、选择性</p>
<h3 id="Cardinality统计"><a href="#Cardinality统计" class="headerlink" title="Cardinality统计"></a>Cardinality统计</h3><p>一直进行统计的话太消耗资源了，触发统计的策略：</p>
<ul>
<li>表中1/16的数据已经发生过变化</li>
<li>数据修改次数超过20e</li>
<li>执行analyze table、show table status、show index以及访问information_schema架构下tables和statistics表时<br>统计方法：对8个叶子节点进行采样分析（如果数据总量不超过8个叶子结点那统计出来的就是精确值）</li>
</ul>
<h2 id="B-树索引的使用"><a href="#B-树索引的使用" class="headerlink" title="B+树索引的使用"></a>B+树索引的使用</h2><p>OLTP应用：对数据进行访问，使用索引是很不错的<br>OLAP应用：对数据进行规模化统计，索引只适合在表关联查询的时候以及时间字段（经常会从时间维度进行统计）</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>和普通索引的结构是一样的，只是索引列是多个<br><img src="https://github.com/fireflyso/Img/blob/master/markdown/1061617952424.jpg?raw=true" alt="image"></p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>mysql5.0以上才支持，由于辅助索引上能拿到所需的信息就不要再做回表操作了</p>
<h3 id="优化器选择不使用索引的情况"><a href="#优化器选择不使用索引的情况" class="headerlink" title="优化器选择不使用索引的情况"></a>优化器选择不使用索引的情况</h3><ul>
<li>访问数据两超过总体的20%时会直接做表扫描（聚簇索引），可以强制指定使用索引</li>
</ul>
<h3 id="索引提示"><a href="#索引提示" class="headerlink" title="索引提示"></a>索引提示</h3><ul>
<li><code>select * from table use index(index_a) where a=1 and b=2</code>建议优化器使用索引index_a至于优化器听不听那就不好说了</li>
<li><code>select * from table force index(index_a) where a=1 and b=2</code>强制制定优化器使用索引index_a</li>
</ul>
<h3 id="muliti-range-read优化"><a href="#muliti-range-read优化" class="headerlink" title="muliti-range read优化"></a>muliti-range read优化</h3><p>MySQL 5.6开始支持，目的是减少磁盘随机访问的次数，原理是通过辅助索引进行批量查询时，将从辅助索引上拿到的主键值进行排序再去组建索引上进行查找</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB -- InnoDB-表</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/InnoDB/InnoDB-%E8%A1%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><h2 id="组织索引表"><a href="#组织索引表" class="headerlink" title="组织索引表"></a>组织索引表</h2><p>InnoDB中表都是根据主键顺序组织存放的，叫做索引组织表，InnoDB中每张表中都要有一个主键，如果没有显式的创建主键，会自行选择或者创建主键</p>
<ul>
<li>判断表中是否存在为空唯一的索引，有就让该列成为主键（多个索引时已第一个符合条件的索引为主键）</li>
<li>如果没有则自动创建一个6字节大小的指针（==不知道这个自动创建的指针的并发分配是怎么样的==）</li>
<li>==这里提到了两个键同一起作为主键可以查看一下==</li>
</ul>
<h2 id="InnoDB逻辑存储结构"><a href="#InnoDB逻辑存储结构" class="headerlink" title="InnoDB逻辑存储结构"></a>InnoDB逻辑存储结构</h2><p><img src="/img/25295.png" alt="image"></p>
<p>解释一下上面这个图，Tablespace就不说了，Segment（段）就索引的叶子节点，Extent（区）一个段由多个区组成，一个区由多个Page组成，page中存储着Row行数据，下面展开说一下</p>
<h3 id="Tablespace"><a href="#Tablespace" class="headerlink" title="Tablespace"></a>Tablespace</h3><p>这个东西之前说过了，可以是放到共享的，也可以是每个表独立的，注意每个表独立的时候，其实独立存储的数据是表内行数据、索引和插入缓冲Bitmap页，其他类的数据（回滚undo、插入缓冲索引页、系统事务信息、二次写double write buffer等）还是放到共享空间中的，所以有的情况下共享空间还是会不断的增长</p>
<h3 id="段-segment"><a href="#段-segment" class="headerlink" title="段 segment"></a>段 segment</h3><p>常见的段有数据段、索引段、回滚段等</p>
<ul>
<li>数据段就是叶子节点</li>
<li>索引段就是非叶子节点</li>
<li>回滚节点后面会讲</li>
</ul>
<h3 id="区"><a href="#区" class="headerlink" title="区"></a>区</h3><p>由连续的页组成的空间，区的大小是固定的1M，页一开始的大小是16k，后来可以手动设置为2k、4k、8k，于是一个页中就有对应的512、256、128、64个页</p>
<p>一个段是由开始的32个碎片页和之后的区组成的，如果新建一个表，这个表占用的空间是96k而不是1M，为了避免一些小表和undo段浪费空间，一开始的时候段中只有6个碎片页，随着数据的增多，最多分配32个碎片页也就是512k，之后就会分配连续的页来进行数据存储了</p>
<h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>page也可以叫block块，是InnoDB磁盘管理的最小单位，常见的页类：</p>
<ul>
<li>数据页</li>
<li>undo页</li>
<li>系统页</li>
<li>事务数据页</li>
<li>插入缓冲位图页</li>
<li>插入缓冲空闲列表页</li>
<li>未压缩的二进制大对象页</li>
<li>压缩的二进制对象页</li>
</ul>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>数据按行进行存储，每个页最多能存放16k/2 - 200行的记录，即7992行数据</p>
<h2 id="4-3-InnoDB行记录格式"><a href="#4-3-InnoDB行记录格式" class="headerlink" title="4.3 InnoDB行记录格式"></a>4.3 InnoDB行记录格式</h2><p>目前有两种记录格式compact和redundant，redundant是对老版本的兼容，所以可以认为就是使用compact格式</p>
<h3 id="compact行记录格式"><a href="#compact行记录格式" class="headerlink" title="compact行记录格式"></a>compact行记录格式</h3><p><img src="/img/25344.png" alt="image"></p>
<ul>
<li>变长字段长度列表（==这里可能有varchar指定长度的误区==）<ul>
<li>如果列的长度小于255字节，用1字节表示</li>
<li>大于255字节，用2字节表示</li>
<li>这里存储的是一行数据中所有varchar类型长度总和，最大限制为65535，==之前的想法是两个字节也就是2的16次方为38528，无符号时最多可以表示65536，是错的，不知道这里是怎么存储的==</li>
</ul>
</li>
<li>null标志位，标记该行中是否有null值，有就为1</li>
<li>记录投信息，固定占用5字节（40位），记录内容大概是：行是否被删除、改记录拥有的记录数、索引堆中该记录的排序记录、记录类型（普通、B+树节点指针等）、下一条记录的相对位置</li>
<li>列数据就是用户定义的数据，注意Null不占用该部分的任何空间（实际是占有之前的标志位），另外还有两个隐藏列：事务ID列和回滚指针列分别是6、7字节，如果没有定义主键的话还会有一个6字节的rowid</li>
</ul>
<h3 id="redundant行记录格式"><a href="#redundant行记录格式" class="headerlink" title="redundant行记录格式"></a>redundant行记录格式</h3><p><img src="/img/25375.png" alt="image"></p>
<p>老版本的记录方式了，不进行太详细的解释</p>
<ul>
<li>同样的字段长度偏移列表</li>
<li>记录头中有一个字段叫n_fields占用10位，这就就是为什么表最多能有1023个列</li>
<li>列数据</li>
</ul>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>行溢出数据就是指某些没有直接存放在页里面的数据，存放的是真实数据存放的指针，通常认为text和BLOB等大对象会这样存放，但实际上varchar也可能溢出，BLOB也可能不溢出</p>
<p>关于varchar：</p>
<ul>
<li>首先我们认为varchar能存放65535，实际上真正去创建表字段的时候最大允许设置65532；</li>
<li>varcahr(n)这里的n只的是字符数，而上面的65532是指字节，也就是说如果设置格式为GBK那就最多只能存32767，设置格式UTF8最多只能存21845</li>
</ul>
<p>关于溢出存储策略：</p>
<ul>
<li>准则是避免一个页只存一条数据，一个页最少要存储两条数据，由于页的大小为16k即16384字节，所以最大不发生溢出存储的varchar长度为8098（还会留出一部分空间存储页的结构信息，后面会讲，这里16384-8098*2 = 188字节）</li>
<li>对于之前提到的text和BLOB也是一样的如果数据小于8k的话就不会进行溢出存储</li>
<li>溢出存储时的结构：只存储前768个字节的前缀，剩下的存储到BLOB页中<img src="/img/25526.png" alt="image"></li>
</ul>
<h3 id="Compressed和Dynamic行记录格式"><a href="#Compressed和Dynamic行记录格式" class="headerlink" title="Compressed和Dynamic行记录格式"></a>Compressed和Dynamic行记录格式</h3><p>InnoDB 1.0.x之后引入了新的文件格式，之前我们讲到的compact和redundant格式称为Antelope，新的文件格式称为Barracuda（Compressed和Dynamic）</p>
<p>新的格式会将溢出的数据（BLOB页中的数据）进行完全的溢出存储，数据页中只存储20字节的指针，结构如下<img src="/img/25556.png" alt="image"></p>
<p>另外Compressed格式的另一个功能是对行数据进行zlib算法压缩，所以对BLOB、Text、varchar之类的大长度类型存储效率比较好</p>
<h3 id="Char类型"><a href="#Char类型" class="headerlink" title="Char类型"></a>Char类型</h3><p>之前认为char是定长的，实际从MySQL 4.1版本之后char(n)这里的n也变成了字符长度，同样的问题出现了，如果字段的字符集是多字节（比如GBK、UTF8），这个时候InnoDB存储的时候是采用和varchar一样的机制（会在变长字段长度中记录它的长度）</p>
<h2 id="页的结构"><a href="#页的结构" class="headerlink" title="页的结构"></a>页的结构</h2><p>这个数据官方没有出说明文档，这是看源码分析出来的，版本变更不一定准确，作为结构探索的产考</p>
<p>数据页由7个部分组成：<img src="/img/25593.png" alt="image"></p>
<ul>
<li>File Header 文件头 38 byte</li>
<li>Page Header 页头  56 byte</li>
<li>Infimun和supremum records</li>
<li>User Records 用户记录，就是行记录</li>
<li>Free Space 空闲空间</li>
<li>Page Directory 页目录</li>
<li>File Trailer 文件结尾信息 8 byte</li>
</ul>
<h3 id="file-header"><a href="#file-header" class="headerlink" title="file header"></a>file header</h3><p><img src="/img/25598.png" alt="image"></p>
<p>这里的东西太细不一个个过，主要的作用</p>
<ul>
<li>维护页的完整性，通过对比刷新版本号来检查是否存储写入磁盘过程中是否发生过异常</li>
<li>定位页，双向链表中前后页的指针</li>
<li>标记表空间</li>
</ul>
<h3 id="page-header"><a href="#page-header" class="headerlink" title="page header"></a>page header</h3><p><img src="/img/25614.png" alt="image"></p>
<ul>
<li>用户数据在页中的记录位置和行数</li>
<li>维护可用空间指针</li>
<li>维护已删除的数据空间指针</li>
<li>维护最后插入记录指针</li>
<li>维护页在索引树中的位置，0x00代表叶节点，即第0层</li>
<li>记录当前页属于哪个索引</li>
</ul>
<h3 id="Infimum和Supremum-Record"><a href="#Infimum和Supremum-Record" class="headerlink" title="Infimum和Supremum Record"></a>Infimum和Supremum Record</h3><p><img src="/img/25626.png" alt="image"></p>
<p>本质就是索引节点的标记数据，对应了最小和最大索引值</p>
<h3 id="User-Record-和-Free-Space"><a href="#User-Record-和-Free-Space" class="headerlink" title="User Record 和 Free Space"></a>User Record 和 Free Space</h3><p>就是用户的记录（链表）和空闲可用的空间（用链表维护，被删除的空间也会加入到链表中）</p>
<h3 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h3><p>将页中的数据指针（每个指针称为槽）进行存放，这里是一个稀疏目录，一个槽中可能有多个指针，查询将页加载到内存之后，在内存中进行二叉查找，这个过程很快所以一般都忽略掉了</p>
<h2 id="Named-File-Formats机制"><a href="#Named-File-Formats机制" class="headerlink" title="Named File Formats机制"></a>Named File Formats机制</h2><p>InnoDB会不断的对页的存储格式进行更新，新的文件格式总数包含之前的文件格式，InnoDB已经通过a-z动物名的方式预留了很多的格式名称，以后会挨个进行实现<img src="/img/25663.png" alt="image"></p>
<p>查看方式<code>show VARIABLES like &#39;innodb_file_format&#39;</code></p>
<h2 id="约束-constraint"><a href="#约束-constraint" class="headerlink" title="约束 constraint"></a>约束 constraint</h2><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><p>实现的几种方式：</p>
<ul>
<li>通过数据类型来约束数据值的范围和满足特定条件</li>
<li>外键约束</li>
<li>编写触发器</li>
<li>default约束强制数据域完整性</li>
</ul>
<p>InnoDB提供的几种约束：主键、唯一键、外键、默认值、非空</p>
<h3 id="约束的创建和查找"><a href="#约束的创建和查找" class="headerlink" title="约束的创建和查找"></a>约束的创建和查找</h3><p>这个就不过多的进行介绍了，创建表和修改表结构的时候都可以设置上面提到的约束，查看语句这里不一一列举</p>
<h3 id="约束和索引的区别"><a href="#约束和索引的区别" class="headerlink" title="约束和索引的区别"></a>约束和索引的区别</h3><p>约束是一个逻辑概念用来保证数据完整性，索引是一个数据结构代表数据物理存储的方式</p>
<p>==唯一性约束的实现是怎么样的==</p>
<h3 id="对错误数据的约束"><a href="#对错误数据的约束" class="headerlink" title="对错误数据的约束"></a>对错误数据的约束</h3><p>MySQL运行非法或错误的数据插入或更新，会自动转换为一个合法值</p>
<h3 id="ENUM-和-set约束"><a href="#ENUM-和-set约束" class="headerlink" title="ENUM 和 set约束"></a>ENUM 和 set约束</h3><p>比如性别这种，只支持male或者female可以用enum来实现，别的输入会报错</p>
<h3 id="触发器与约束"><a href="#触发器与约束" class="headerlink" title="触发器与约束"></a>触发器与约束</h3><p>MySQL5.1之后提供了比较完善的触发器机制，最多可以为一个表创建6个触发器：insert、update、delete的before和after；通过触发器可以定制化约束</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>这个不常使用，这里也没有更细致的介绍</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>虚拟表，没有实际的物理存储</p>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><p>作为一个抽象装置，也能起到安全层的作用（我们是用ES代替了视图），可以直接对视图进行更新，本质是更新了对应的基表的数据</p>
<h3 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h3><p>InnoDB不支持</p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><h3 id="分区概述"><a href="#分区概述" class="headerlink" title="分区概述"></a>分区概述</h3><p>将一个表或者索引分解为多个更小、更可管理的部分；逻辑上只有一个表物理上由多个物理分区组成，每个分区都是独立的对象，可以独自处理也可以作为更大对象的一部分来处理</p>
<p>分区分为水平（按记录行）和垂直分区（按列），MySQL只支持水平分区</p>
<p>同时分为局部分区和全局分区，局部就是把数据和索引都进行独立的存放，全局值数据进行分区存放但是索引在一个对象中进行管理，MySQL只支持局部分区</p>
<p>当一个数据插入时，如果分区未定义（不再已定义的分区中），InnoDB会抛出异常，且如果批量插入中有一个这样的异常数据，所有数据都不会被插入（看成一个事务）</p>
<p>分区字段必须是表结构中唯一性索引的一部分（所有包含唯一性约束的索引的一部分即可，比如联合唯一索引的一个字段），如果表中没有唯一性约束，那就可以用任意字段进行分区</p>
<p>key分区的时候，需要将分区数量设置为质数（3、7、11、13、17），不然会出现数据不能均匀分布的情况，==且不知道为什么只有将分区key作为主键组成部分才分区成功了==</p>
<h3 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h3><p>MySQL支持以下几种分区：</p>
<ul>
<li>range：将给定列连续的按区间进行分区</li>
<li>list：对比range分区面向的是离散的值</li>
<li>hash：根据用户自定义的表达式返回值来进行分区</li>
<li>key：根据MySQL数据库提供的哈希函数来进行分区</li>
</ul>
<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>最常见的一种分区方式，比如通过id进行分区的时候，会将数据按指定的区间划分在磁盘上由独立的ibd文件进行存储（正常就是一个idb文件）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">partition by range(id)(</span><br><span class="line">    partition p0 values less than (10),</span><br><span class="line">    partition p1 values less than (20)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>优化场景：</p>
<ul>
<li>通过id分区，可以提高指定id查询的速度</li>
<li>通过时间进行分区，比如销售表，这个时候如果要进行年度数据的统计速度会得到提升，当然查询的时候也要根据分区的逻辑进行SQL编写</li>
</ul>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>和range很接近，只是分区值是离散的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">partition by range(id)(</span><br><span class="line">    partition p0 values in (1,3,5,7,9),</span><br><span class="line">    partition p1 values in (0,2,4,6,8)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><p>目的是将数据均匀的分不到预先定义的各个分区中,两种hash分区方式，linear在增加、删除、合并和拆分上更快捷，缺点是数据分布不是特别均衡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--hash分区--&gt;</span><br><span class="line">partition by hash (year(b)) partitions 4;</span><br><span class="line">&lt;!--linear hash分区--&gt;</span><br><span class="line">partition by linear hash (year(b)) partitions 4;</span><br></pre></td></tr></table></figure>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>和hash差不多，区别是hash可以指定函数进行分区，key使用MySQL提供的函数进行分区，同样有linear关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">partition by key (b) partitions 4;</span><br></pre></td></tr></table></figure>

<h4 id="columns"><a href="#columns" class="headerlink" title="columns"></a>columns</h4><p>这个东西是MySQL5.5之后开始支持的，上面说的4中分区方式都有一个前提就是分区字段类型要是整型，如果不是需要通过函数转换为整型，而columns可以看做是range和list的进化，可以直接使用非整型数据进行分区</p>
<h3 id="子分区"><a href="#子分区" class="headerlink" title="子分区"></a>子分区</h3><p>在分区基础上再进行分区，也称为符合分区；MySQL允许在range和list的分区上再进行hash或key的子分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--这样会创建3*2 共计6个分区--&gt;</span><br><span class="line">partition by range(year(b))</span><br><span class="line">subpartition by hash (to_days()b)</span><br><span class="line">subpartitions 2(</span><br><span class="line">    partition p0 values less than (1990),</span><br><span class="line">    partition p1 values less than (2000),</span><br><span class="line">    partition p2 values less than maxvalue</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>子分区还可以显式的对名字进行指定，这个时候必须每个子分区都列出来，并且名字不能重复</li>
<li>子分区可以用于特别大的表，在多个磁盘建分配分配数据和索引</li>
</ul>
<h3 id="分区中的null值"><a href="#分区中的null值" class="headerlink" title="分区中的null值"></a>分区中的null值</h3><p>MySQL允许对null做分区，策略上MySQL会把null看成一个比所有非null都小的值，于是不同的分区策略下null的处理也不同</p>
<ul>
<li>range中，会把null放到最左边的分区</li>
<li>list分区下要使用null的话必须显式的指定哪个分区中放入null</li>
<li>hash和key中函数会把含有null值的记录返回为0</li>
</ul>
<h3 id="分区的性能"><a href="#分区的性能" class="headerlink" title="分区的性能"></a>分区的性能</h3><p>比如我们认为1000w数据的索引树高度为3，100w数据高度为2，通过主键hash分为10个分区，这个时候通过主键进行查询可以节省一次IO，但是如果是对别的索引进行查询的时候，会对10个子索引进行查询，也就是20次IO，速度反而变慢了，所以设计的时候需要结合场景</p>
<h3 id="在表和分区间交换数据"><a href="#在表和分区间交换数据" class="headerlink" title="在表和分区间交换数据"></a>在表和分区间交换数据</h3><p>创建两个一样的表，一个定义分区，一个不定义分区，这个时候可以通过<code>alter table ... exchange partition</code>将数据进行交换，没有想出应用场景，这里也没有介绍</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 一、初识Kafka</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Kafka/%E4%B8%80%E3%80%81%E5%88%9D%E8%AF%86Kafka/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="初识Kafka"><a href="#初识Kafka" class="headerlink" title="初识Kafka"></a>初识Kafka</h1><h2 id="发布与订阅消息系统"><a href="#发布与订阅消息系统" class="headerlink" title="发布与订阅消息系统"></a>发布与订阅消息系统</h2><ul>
<li>业务开始的时候只是简单的想收集一些数据指标，但随着业务扩展和需要收集的指标维度增加，这个简单的数据收集也变得复杂</li>
<li>混沌的发布与订阅<br><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-11/hundun.png" alt="image"></li>
<li>为了解决这个混沌的系统，创建了一个独立的服务来接收各个业务的数据，并为下游提供查询服务，于是成了下面的样子<br><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-11/sampleserver.png" alt="image"></li>
<li>但是问题又来了，别的同事也有类似的需求，也在做同样的事情，数据被重复的处理<br><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-11/fuzhaserver.png" alt="image"></li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka就是一个独立的发布订阅系统，为了解决上述的问题，简单的说，Kafka支持对同一个数据流的多个发布者和多个订阅者（重复消费），下面介绍一些基础概念</p>
<ul>
<li>消息和批次<ul>
<li>消息：Kafka的数据单元，也可以看作是数据库中多一行数据，不过Kafka中消息没有格式要求</li>
<li>批次：一组消息，如果每个消息都单独的进行发送网络开销比较大，所以同一个主题和分区的消息会分批次的发送，所以在Kafka中不需要手动的进行批量推送（mysql就没有这个优化），不过会带来数据延时的问题，需要做平衡</li>
</ul>
</li>
<li>模式：上面提到Kafka的消息没有格式上的要求，所以搞了个模式来定义消息内容，关系到数据的序列化、解析之类操作方式，所以不同的模式之间不一定兼容，常用的模式是apche Avro</li>
<li>主题和分区：可以理解为表和分区，Kafka会保证分区内的数据有序，但是一个消费者可以同时消费多个分区，所以如果有顺序需求的场景需要把数据放入同一个分区中，一个分区最多只能被一个消费者消费</li>
<li>生产者：消息的创建者，通常情况下，消息会被均衡地分布在分区中，如果有消息键写入指定分区的需求可以使用分区器，为消息键做散列来保证相同的键在相同的分区中，分区器支持自定义</li>
<li>消费者：<ul>
<li>偏移量：消费者通过偏移量来区分已经读取过的消息，偏移量是一个递增整数，偏移量是按分区隔离的不能跨分区，偏移量会被保存在zookeeper或者Kafka中，消费者关闭或者重启偏移量不会丢失</li>
<li>消费者群组：多个消费者组成一个群组，每个分区只会被群组内的一个消费者读取，消费者和分区之间大映射叫所有权关系</li>
</ul>
</li>
<li>broker：一个独立大Kafka服务叫做broker，单个broker可以处理数千个分区已经每秒百万级的消息量</li>
<li>集群：由多个broker组成，每个集群都有一个broker充当集群控制器大角色（选举而来）；在集群中一个分区从属于一个broker（首领），一个分区可以分配给多个broker，这个会发生分区复制，来提供消息冗余（备份）</li>
<li>保留消息：Kafka的一个重要特性，可以配置一定时间过期或者达到一定大小过期；所以Kafka消息重量不会超过配置大小</li>
<li>多集群：镜像数据类型分离、安全需求隔离、多数据中心（灾难恢复），Kafka消息复制机制只在单个集群内，多集群之间用mirrormaker来实现</li>
</ul>
<h2 id="为什么选择Kafka"><a href="#为什么选择Kafka" class="headerlink" title="为什么选择Kafka"></a>为什么选择Kafka</h2><ul>
<li>多个生产者</li>
<li>多个消费者：支持多个消费者互不影响的消费一个消息流，消费者还可以组成群组来共享一个消息流</li>
<li>基于磁盘的数据存储：应对流量高峰数据可以根据策略持久化到本地，消费者也可以被关闭，消息会继续保存在Kafka中</li>
<li>伸缩性：可以通过扩展broker数量来形成集群，进而扩展可容纳的数据量，以及应对个别broker失效的情况</li>
<li>高性能：通过横向扩展生产者、消费者和broker，可以轻松处理巨大的消息流</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 三、生产者</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Kafka/%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><p>就是往Kafka中写入数据的应用程序，Kafka自己提供了生产者，也有很多第三方实现的客户端（我们当然以python为例）</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="/img/16384359440191638435944005.png"></p>
<h2 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from kafka import KafkaProducer, KafkaConsumer, TopicPartition</span><br><span class="line">KafkaProducer(</span><br><span class="line">    bootstrap_servers=[&#x27;&#123;&#125;:&#123;&#125;&#x27;.format(KAFKA_HOST, KAFKA_PORT)],</span><br><span class="line">    key_serializer=lambda k: json.dumps(k).encode(),</span><br><span class="line">    value_serializer=lambda v: json.dumps(v).encode()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>bootstrap_servers</li>
<li>key_serializer</li>
<li>value_serializer</li>
</ul>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>发送的流程：消息先被放入缓冲区，然后使用单独的线程发送到服务器端，send()会返回一个包含RecordMetadata的Future对象</p>
<p>不用考虑发送消息时可能发生的错误或者服务器端可能发生的错误，需要考虑序列化异常、缓冲区溢出或者发送线程被中断的异常</p>
<h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p><code>producer.send(topic, message, partition=0).get()</code></p>
<ul>
<li>可重试的异常，比如连接错误（再次建立连接）、“no leader”通过重新为分区选举首领解决，Kafka producer可以配置成自动重试，多次重试后仍无法解决问题程序会收到一个重试异常</li>
<li>无法通过重试解决的问题，比如消息太大，这样producer会直接抛出异常</li>
</ul>
<h3 id="异步消息发送"><a href="#异步消息发送" class="headerlink" title="异步消息发送"></a>异步消息发送</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer.send(topic, data_info, partition=partition).add_errback(on_send_error).add_callback(on_send_success)</span><br><span class="line"></span><br><span class="line">def on_send_error(excp):</span><br><span class="line">    pass</span><br><span class="line">    </span><br><span class="line">def on_send_success(record_metadata):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<ul>
<li>有一个配置可以指定，生产者在没有收到成功回调之前最多能发送多少个消息</li>
</ul>
<h2 id="生产者的配置"><a href="#生产者的配置" class="headerlink" title="生产者的配置"></a>生产者的配置</h2><p>已经介绍了一些重要的需要定制化的配置，还有一些作为调优，但通常使用默认值即可的配置也介绍一下</p>
<ul>
<li>acks：指定必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的<ul>
<li>=0 生产者完全不对结果进行确认，会出现消息丢失，但是效率最高</li>
<li>=1 但集群首领收到消息，生产者会收到来自服务器的成功响应，如果首领没有收到消息（首领节点崩溃新首领还没有选举出来），生产者会收到一个错误响应，为避免消息丢失，生产者会重发消息，这个时候客户端同步调用的话就会产生延迟，如果是回调方式可以缓解延迟问题</li>
<li>=all 所有参与复制的节点全部收到消息才会返回成功，效率最低</li>
</ul>
</li>
<li>buffer.memory：生产者内存缓冲区的大小，如果应用程序发送消息的速度超过了发送到服务器的速度，会导致这个缓冲占满，这个时候会根据block.on.buffer.full决定是立即抛出异常还是把send()进行阻塞（一段时间） 0.9.0.0版本里变成max.block.ms表示抛出异常前阻塞的时间</li>
<li>compression.type：指定消息压缩的方法，snappy、gzip，snappy性能和效率比较平衡，gzip比较占用CPU压缩效率也更高</li>
<li>retries：生产者收到可重试的错误时，重试的次数（默认情况下，重试的时间间隔为100ms）</li>
<li>batch.size：多条消息需要呗发送到同一个分区的时候会被放到同一个批次里面，此参数配置一个批次的内存大小（字节，不是消息数量）</li>
<li>linger.ms：一个批次最长的等待时间，到了时间即使空间没有满也会发送</li>
<li>client.id：任意字符串，服务器用它来识别消息的来源</li>
<li>max.in.flight.requests.per.connection：指定生产者在收到服务器响应之前可以发送多少个消息，如果设置为1，==那么回调方式也变为了同步发送==，但可以保证消息时按照发送的顺序写入服务器的</li>
<li>timeout.ms、request.timeout.ms 和 metadata.fetch.timeout.ms：生产者发送数据时等待服务器响应的时间</li>
<li>max.block.ms：上面说过，缓冲区满了之后send()阻塞的时间</li>
<li>max.request.size：控制生产者发送请求大小</li>
<li>receive.buffer.bytes 和 send.buffer.bytes：tcp socket接收和发送数据包的缓冲区，-1的时候使用操作系统的默认值，如果客户端和服务器之间处于不同的数据中心，可以适当增大这个值</li>
</ul>
<p>补充说明：Kafka可以保证统一额分区里的消息时有序的，也就是说如果生产者按照一定的顺序发送消息，broker就会按序写入分区，如果retries不为0，同时max.in.flight.requests.per.connection也大于1的话，第一个批次消息写入失败，第二个批次写入成功，第一个批次重试成功，那么顺序就反了，如果严格要求有序，那么建议retries还是不要为0，把max.in.flight.requests.per.connection设为1，不过这样会严重影响生产者的吞吐量</p>
<h2 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h2><p>这里讲了自定义和Avro序列化器的大致逻辑，但是没用过没看出什么东西，后面用到了再看吧</p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一，显式的制定分区</span></span><br><span class="line">producer.send(topic, value, partition=random.randint(<span class="number">0</span>, <span class="number">4</span>)).add_errback(on_send_error)</span><br><span class="line"><span class="comment"># 方式二，通过key取hash进行分区映射</span></span><br><span class="line">producer.send(topic=topic, key=<span class="string">&#x27;device_name&#x27;</span>, value=value).add_errback(on_send_error)</span><br><span class="line"><span class="comment"># 方式三，随机分配</span></span><br><span class="line">producer.send(topic=topic, value=value).add_errback(on_send_error)</span><br></pre></td></tr></table></figure>

<ul>
<li>Kafka如果指定了key且使用了默认的区分器的话，就会根据key进行hash映射到分区中，也就是同一个key会一直被放到同一个分区，且这里的散列算法是Kafka的，和调用的语言无关，当然如果分区数量发生了改变散列相应改变（telemetry项目中我手动去实现了这个功能，其实毫无必要）</li>
<li>如果没有指定key，分区器会使用轮询算法将消息均衡的分布到各个分区</li>
<li>也可以去实现自定义分区器，telemetry那块也算吧，不过没有调用官方的接口是通过业务侧完成的</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 个人实践-安装和基础介绍</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Kafka/%E4%B8%AA%E4%BA%BA%E5%AE%9E%E8%B7%B5-%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用docker进行安装，很简单，中docker笔记中记录了，<a href="https://zhuanlan.zhihu.com/p/279784873">安装参考教程</a></p>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--进入kafka容器--&gt;</span><br><span class="line">docker exec -it kafka bash</span><br><span class="line"></span><br><span class="line">cd /opt/kafka/bin</span><br><span class="line"></span><br><span class="line">&lt;!--创建一个主题--&gt;</span><br><span class="line">kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 2 --topic kafka_demo</span><br><span class="line"></span><br><span class="line">&lt;!--查看主题--&gt;</span><br><span class="line">kafka-topics.sh --zookeeper zookeeper:2181 --list</span><br><span class="line"></span><br><span class="line">&lt;!--查看主题下的消息数量--&gt;</span><br><span class="line">kafka-run-class.sh kafka.tools.GetOffsetShell --topic firefly --time -1 --broker-list localhost:9092 --partitions 0</span><br><span class="line"></span><br><span class="line">&lt;!--删除主题--&gt;</span><br><span class="line">kafka-topics.sh --zookeeper zookeeper:2181 --delete --topic mykafka</span><br><span class="line"></span><br><span class="line">&lt;!--配置消息过期时间--&gt;</span><br><span class="line">cd /opt/kafka/bin</span><br><span class="line">./kafka-configs.sh --zookeeper zookeeper:2181 --alter --entity-name telemetry_message --entity-type topics --add-config retention.ms=600000</span><br><span class="line"></span><br><span class="line">&lt;!--查看过期时间--&gt;</span><br><span class="line">./kafka-configs.sh --zookeeper zookeeper:2181 --describe --entity-name telemetry_message --entity-type topics</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 二、Kafka的配置说明</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Kafka/%E4%BA%8C%E3%80%81Kafka%E7%9A%84%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h1><h2 id="broker配置"><a href="#broker配置" class="headerlink" title="broker配置"></a>broker配置</h2><h3 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h3><ul>
<li>broker.id：broker的标识符，在集群中必须是唯一的</li>
<li>port：默认是9092</li>
<li>zookerper.connect：指定zookeeper服务的地址和端口</li>
<li>log.dirs：指定Kafka消息持久化路径，可以是一组逗号隔开的本地文件系统路径，会按分区把数据写入这些路径</li>
<li>num.recover.threads.per.data.dir<ul>
<li>Kafka会使用线程池来处理日志片段，但只有中服务器启动或关闭的时候才会用到，来并发的处理数据</li>
<li>如果有三个目录，且本参数设置为8，则会有24个线程并发处理</li>
</ul>
</li>
<li>auto.create.topics.enable：Kafka的主题可以不创建直接使用，生产者推送数据的时候会自动创建主题（消费也会触发），这个参数用来配置是否自动创建</li>
</ul>
<h3 id="主题的默认配置"><a href="#主题的默认配置" class="headerlink" title="主题的默认配置"></a>主题的默认配置</h3><ul>
<li>num.partitions<ul>
<li>分区数量</li>
<li>分区数量是个很重要的参数，由于一个分区最多被一个消费组中的一个消费者消费（其实就是最多就只能被一个消费者消费），所以分区数量是消费的瓶颈，需要综合生产速度和单个消费速度来决定分区的数量</li>
<li>还要考虑磁盘空间和带宽因素</li>
<li>分区数越多内存占用越多，首领选举需要的时间越长，所以不能单纯的扩展分区数量</li>
</ul>
</li>
<li>log.retention.ms：数据保留时间，默认是一周</li>
<li>log.retention.bytes：每个分区的存储空间，默认是1G（上面的时间和这个空间，只要有一个条件符合就会触发删除）</li>
<li>log.segment.bytes<ul>
<li>要先介绍一下，Kafka日志被分为段，当消息填满一个片段的时候，这个片段就会被关闭写入到一个文件，打开一个新的片段来接收消息，片段被关闭后才开始过期等待（主要原因还是为每个消息做独立的过期管理开销太大）</li>
<li>这个参数就是配置片段的大小，同样就需要根据业务来决定配置大小，太小，那么会频繁的关闭和分配新文件，带来频繁IO开销，太大，如果过来的数据量小，那数据过期时间可能会远超我们的预期（一个片段1G，每天过来100M消息，十天后数据开始过期等待，如果我们期望一周过期，实际却是17天才过期）</li>
</ul>
</li>
<li>log.segment.ms：应该是为了平衡上面的空间设置，达到这个时间条件时一个片段也会关闭</li>
<li>message.max.bytes：指定单个消息的最大长度，超过这个长度会报错，可以通过压缩来传递更多消息</li>
</ul>
<h2 id="硬件选择"><a href="#硬件选择" class="headerlink" title="硬件选择"></a>硬件选择</h2><ul>
<li>磁盘吞吐量：SSD会是更好的选择，但也要考虑价格，可以通过挂载多块机械硬盘来实现IO并发（分区指定到不同磁盘的目录上）</li>
<li>磁盘容量：取决于需要存储的数据（数据规模和保留时长）</li>
<li>内存：消费者需要把日志片段加载到缓存中进行读取</li>
<li>网络：带宽应该是最大的瓶颈，生产者、消费者、集群复制都需要占用带宽，别的性能都可以通过broker来进行扩展</li>
<li>CPU：要求较小，数据压缩和解压以及设置偏移量会用到</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-11/jiqun.png" alt="image"></p>
<h3 id="需要多少个broker"><a href="#需要多少个broker" class="headerlink" title="需要多少个broker"></a>需要多少个broker</h3><ul>
<li>第一是考虑磁盘需求，假如需要10T，每个broker有2T空间，那至少要5个broker，如果启用了复制（一个备份的情况），那就要翻倍为10个broker</li>
<li>第二是性能：需要考虑broker的网络吞吐能力，如何面对洪峰等</li>
</ul>
<h3 id="broker配置-1"><a href="#broker配置-1" class="headerlink" title="broker配置"></a>broker配置</h3><ul>
<li>一个集群中所有的broker需要配置相同的zookeeper服务</li>
<li>配置独立等id</li>
</ul>
<h2 id="生产环境调优"><a href="#生产环境调优" class="headerlink" title="生产环境调优"></a>生产环境调优</h2><ul>
<li>垃圾回收器选项：这个其实就是使用了JAVA的垃圾回收</li>
<li>数据中心：最好把broker安装到不同的机架，这样一个broker出现问题时，还有别的备份活着</li>
<li>zookeeper：虽然Kafka对zookeeper的占用不高，但为了避免不确定因素，最好还是不要和别的程序共享zookeeper服务</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 五、深入Kafka</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Kafka/%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5Kafka.md/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="深入Kafka"><a href="#深入Kafka" class="headerlink" title="深入Kafka"></a>深入Kafka</h1><p>这里主要讨论以下三个话题</p>
<ul>
<li>Kafka如何进行复制</li>
<li>Kafka如何处理来自生产者和消费者的请求</li>
<li>Kafka的存储细节（文件&amp;索引等）</li>
</ul>
<h2 id="集群成员关系"><a href="#集群成员关系" class="headerlink" title="集群成员关系"></a>集群成员关系</h2><ul>
<li>Kafka使用zookeeper来维护集群成员信息</li>
<li>每个broker都有一个唯一ID，不能冲突，broker启动的时候会在zookeeper中创建一个临时节点信息，卡夫卡组件订阅zookeeper来获取broker的状态信息</li>
<li>broker停机或者其他异常时，其启动时在zookeeper上创建的临时节点信息会消失，组件也就会被告知该broker被移除</li>
<li>另外如果是正常关闭了broker，那么它的ID还会在别的地方进行存储，如果这个时候再用这个ID去启动一个全新的broker，那它会拥有旧broker的分区和主题</li>
</ul>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><ul>
<li>控制器是第一个加入集群的broker，相比普通成员它会额外负责首领的选举</li>
<li>第一个broker加入集群时在zookeeper中创建临时节点并把自己注册为控制器，之后的节点进来发现有控制器了就不会再注册控制器，如果控制器关闭了，那它对应的临时节点消失，其余的成员会收到通知，第一个尝试注册的broker会成为新的控制器</li>
<li>当控制器发现一个broker离开集群的时候，会为对应的分区（以这个broker为首领的分区）选取新的首领，选取策略很简单，遍历分区副本列表的下一个副本</li>
<li>当控制器发现一个broker加入集群的时候，通过ID判断broker是否包含现有分区的副本，如果有发送通知给这个broker让它从对应的首领那里复制消息</li>
</ul>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>Kafka使用主题来组织数据，主题被分为若干个分区，每个分区有多个副本，本质上是为了达成分布式性能扩展和高可用</p>
<ul>
<li><p>首领副本：为了保证一致性，所有生产者和消费者请求都由首领进行处理（没有读写分离策略）</p>
</li>
<li><p>跟随者副本：就是备份，从首领复制消息</p>
</li>
<li><p>跟随者为了同步数据发起的请求和消费者请求是一样的，跟随者发送请求消息1、2、3，在收到这三个请求响应前不会再发送请求，如果跟随者发送了请求4那么首领就知道这个跟随者已经收到了前三个请求的响应，以此首领便知道了跟随者的同步进度</p>
</li>
<li><p>如果一个跟随者10s内没有发起请求或者请求的数据不是最新的，这个跟随者被标记为不同步，失去被选举为首领的资格</p>
</li>
<li><p>除了当前首领，还有一个首选首领，反正就是高级备胎（还有一个配置可以让这个备胎直接转正，当然前提是没被标记为不同步）</p>
</li>
</ul>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>Kafka使用一个基于TCP的二进制协议，指定了请求消息的格式已经broker如何对请求作出响应</p>
<ul>
<li><p>broker会运行一个acceptor线程监听端口，会创建一个连接从客户端获取请求消息，并放入请求队列</p>
</li>
<li><p>IO线程负责处理请求队列，通常请求有两种类型</p>
<ul>
<li><p>生产请求：生产者发送的写入请求</p>
</li>
<li><p>获取请求：消费者发送和跟随者副本发送的读请求</p>
<p><img src="/img/16387901463811638790146296.png"></p>
</li>
</ul>
</li>
<li><p>之前讲过，只有首领才能处理请求，如何保证向首领发起请求：</p>
<ul>
<li>Kafka客户端通过一个元数据缓存（类似路由表）来确定该往哪个broker发起请求，这个缓存是会定时更新的</li>
<li>当然也可能在更新之前首领已经发生了变更，请求被发送到一个错误的broker，这个时候会得到一个‘非分区首领’的错误响应，这个时候客户端会先刷新缓存再重试请求</li>
</ul>
<p><img src="/img/16387901908301638790190813.png"></p>
</li>
</ul>
<h3 id="生产请求"><a href="#生产请求" class="headerlink" title="生产请求"></a>生产请求</h3><p>之前说过生产请求可以设定acks（0、1、all），来定义消息写入成功策略，首领收到生产请求时会做一些验证</p>
<ul>
<li>权限校验</li>
<li>acks值合法判断</li>
<li>如果acks为all，是否有足够多的副本保证消息的安全写入（什么意思呢，我们可以通过另一个配置来指定副本数量，如果不满足broker可以拒绝处理新消息）</li>
</ul>
<p>之后消息会被写入本地磁盘，对Linux系统来说会写到文件系统缓存，并不保证合适被刷新到磁盘（mysql也有类似机制，原因是文件系统缓存只有在操作系统挂了才会丢失）</p>
<p>当消息被写入首领分区后，会根据acks来决定何时响应，0、1会立即响应，all会等到别的副本复制完成再响应</p>
<h3 id="获取请求"><a href="#获取请求" class="headerlink" title="获取请求"></a>获取请求</h3><p>流程和生产请求很接近</p>
<ul>
<li><p>验证主题分区已经偏移量是否存在，已经读取权限</p>
</li>
<li><p>客户端指定broker最多可以从一个分区里返回多少数据，避免大量数据耗尽客户端分配的内存</p>
</li>
<li><p>同样客户端还可以指定数据返回的下限，这样通过消息累积来减少发送次数（当然还有超时策略，避免一直不响应）</p>
<p><img src="/img/16387910606451638791060635.png"></p>
</li>
<li><p>另外不是所有数据都可以被消费，必须被足够多的副本复制的消息才认为是安全的才可以被消费，从而避免消费端的不一致（a消费了，首领崩了新的首领上没有这个数据，b无法消费到这个数据）        <img src="/img/16387912194471638791219436.png"></p>
</li>
</ul>
<h3 id="其他请求"><a href="#其他请求" class="headerlink" title="其他请求"></a>其他请求</h3><p>还有一些broker内部使用的请求，这里不展开</p>
<h2 id="物理存储"><a href="#物理存储" class="headerlink" title="物理存储"></a>物理存储</h2><p>Kafka的基本存储单元是分区，分区无法在broker上再细分，也无法在一个broker的多个磁盘上再细分</p>
<h3 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h3><p>考虑一个场景，6个broker，主题下有10个分区，复制系数为3，该如何进行分配，需要满足一下的几个条件</p>
<ul>
<li>分区在broker见平均分配，也就是每个broker分到5个副本</li>
<li>确保每个副本分布在不同的broker上</li>
<li>如果broker指定了机架信息，尽可能把分区的副本分配到不同的机架上</li>
</ul>
<p>实现方式：</p>
<ul>
<li>随机选一个broker比如4，用轮询的方式给每个broker分配分区来确定首领分区位置，也就是0分区的首领为4，1分区的首领为5，2分区的首领为1</li>
<li>轮询的方式来分配副本，0分区的第一个跟随者副本在5，第二个跟随者副本在1</li>
<li>如果配置了机架信息，那就不是按照数字来轮询broker，而是按照交替机架的方式来选择broker</li>
<li>磁盘空间问题，broker的分区分配不会去考虑不同broker之间磁盘可用空间的问题，后续会介绍相关策略</li>
</ul>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>保留数据上Kafka的一个基本特征，其实之前就介绍过Kafka的数据过期策略</p>
<ul>
<li>把分区分为若干个片段，默认每个片段包含1G或者一周的数据</li>
<li>正在被写入的片段叫做活跃片段，活跃片段永远不会被删除</li>
<li>带来的问题上消息的过期时间可能会和预期相差较大</li>
</ul>
<h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>Kafka把消息和偏移量保存在文件里，保存的数据格式与从生产者发送过来或者发送给消费者的消息格式是一样的，使用了相同的消息格式进行磁盘存储和网络传输，所以Kafka可以使用零复制技术给消费者发送消息，不同加载到缓存（不知道怎么实现的），同时也避免了broker对数据进行解压缩和再压缩</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>消费者可以从Kafka的任意可用偏移量位置开始读取消息，是因为Kafka为每个分区维护了一个索引，把偏移量映射到片段文件和在文件里的位置</p>
<p>索引也被分成片段，Kafka不维护索引的校验和，出现损坏是会重新生成索引，所以删除索引是安全的</p>
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>Kafka有一个策略，可以让key只保留最新的消息，比如生产者不断的往key里面set 1、2、3，这个key只会保留最后一个值（不是很理解，其实大多数场景下，过程数据也有意义）</p>
<h3 id="被删除的事件"><a href="#被删除的事件" class="headerlink" title="被删除的事件"></a>被删除的事件</h3><p>这又是一个特定场景：当一个生产者将离开系统时，我们希望清理Kafka和数据库中的对应数据，这个时候可以给Kafka对应的key发送一个值为null的消息，之前的值会被清理，这个消息被称为墓碑消息，会保留一段时间（可以配置），这个时候消费者发现这个null就可以去做数据库清理（需要自行确保消费者不会离线导致错过墓碑消息，墓碑消息最终会被Kafka清理）</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 六、可靠的数据传递</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Kafka/%E5%85%AD%E3%80%81%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="可靠数据传递"><a href="#可靠数据传递" class="headerlink" title="可靠数据传递"></a>可靠数据传递</h1><h2 id="可靠性保证"><a href="#可靠性保证" class="headerlink" title="可靠性保证"></a>可靠性保证</h2><p>关系型数据库可靠性保证一般是ACID（原子、一致、隔离、持久）</p>
<p>那么Kafka提供哪些方面的保证呢</p>
<ul>
<li>分区消息的顺序，同一个生产者往同一个分区写入消息，那么Kafka会保证消息会按生产者写入的顺序进入分区，且消费者会按这个顺序进行消费</li>
<li>只有当消息被写入分区的所有同步副本时（不一定写入磁盘了，可能是交付给了文件系统缓存），才被认为是已提交</li>
<li>只要还有一个副本是活跃的，那么已经提交的消息就不会丢失</li>
<li>消费者只能读取已提交的消息</li>
</ul>
<p>Kafka只是提供了这些基础的保证，需要结合场景进行配置来达到数据的可靠性</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>Kafka的主题被分为多个分区，分区可以是在线的也可以是离线（不可用）的，每个分区可以有多个副本，其中一个为首领，所有事件都由首领处理，其余副本会自动从首领同步数据，跟随者需要满足以下条件才被认为是同步的</p>
<ul>
<li>与zookeeper见有一个活跃的会话（6s内发送过心跳）</li>
<li>过去10s内从首领获取过消息</li>
<li>过去10s内从首领哪里获取过最新的消息</li>
</ul>
<p>如果一个或多个副本在同步和非同步间快速切换，通常是因为JVM不恰当的垃圾回收配置导致的；一个滞后的同步副本会导致生产和消费者变慢；非同步副本也滞后，但是不会对性能产生影响</p>
<h2 id="broker配置"><a href="#broker配置" class="headerlink" title="broker配置"></a>broker配置</h2><p>broker有3个参数会影响Kafka消息存储的可靠性</p>
<h3 id="复制系数"><a href="#复制系数" class="headerlink" title="复制系数"></a>复制系数</h3><p>也就是会有几个副本，默认是3个，更多的副本数量会带来更高的数据可靠性，同时也带来硬件成本的增加，当然如果生产者设置了严格的acks的话，更多的副本也可能带来性能的下降，所以还是要结合数据的重要程度来进行配置</p>
<h3 id="不完全的首领选举"><a href="#不完全的首领选举" class="headerlink" title="不完全的首领选举"></a>不完全的首领选举</h3><p>有的情况下，如果首领宕机了，但是没有跟随者副本是完全同步的话，可以通过unclean.leader.election来配置是否允许不同步的副本称为首领，默认是True</p>
<h3 id="最少同步副本"><a href="#最少同步副本" class="headerlink" title="最少同步副本"></a>最少同步副本</h3><p>也就是说最少要有几个同步状态的副本时，首领才会继续接收生产者消息</p>
<h2 id="在可靠的系统里使用生产者"><a href="#在可靠的系统里使用生产者" class="headerlink" title="在可靠的系统里使用生产者"></a>在可靠的系统里使用生产者</h2><ul>
<li>配置合适的发送确认参数</li>
<li>配置生产者重试参数</li>
<li>额外的错误处理</li>
</ul>
<h2 id="在可靠的系统里使用消费者"><a href="#在可靠的系统里使用消费者" class="headerlink" title="在可靠的系统里使用消费者"></a>在可靠的系统里使用消费者</h2><h3 id="消费者的可靠性配置"><a href="#消费者的可靠性配置" class="headerlink" title="消费者的可靠性配置"></a>消费者的可靠性配置</h3><ul>
<li>group，通过分组来协调消费者</li>
<li>auto.offset.reset：指定了在没有偏移量可提交（消费者首次启动时）活着请求的偏移量在broker上不存在时，消费者的行为<ul>
<li>earliest：从分区的开始位置读取数据</li>
<li>latest：从分区的末尾开始读取数据</li>
</ul>
</li>
<li>enable.auto.commit：这是一个重要的参数，决定消费者是否自动提交偏移量<ul>
<li>自动提交：好处是省事，轮询过程中自动提交已经处理过的偏移量，缺点是可能出现重复消费，比如消费者在自动提交之前停止了，或者消息如果被交到另一个线程去处理，那么很可能还没有被处理完之前偏移量就已经被提交了</li>
</ul>
</li>
</ul>
<h3 id="显式提交偏移量"><a href="#显式提交偏移量" class="headerlink" title="显式提交偏移量"></a>显式提交偏移量</h3><ul>
<li>总在处理完时间后再提交，如果所有的业务操作都是在轮询里面完成的，且不需要和别的轮询产生耦合，那可以使用自动提交或者在轮询结束时进行手动提交</li>
<li>提交频度，如果每次轮询完成都提交性能会低一些，多次轮询完成后手动提交一次性能高一些，但可能出现重复消费</li>
<li>确保对题啊急哦对偏移量心里有数：确保是在消息被处理完成之后再提交</li>
<li>消费者可能需要重试：一个恶心的场景，2号消息被处理成功了，但是1号消息失败了，这个时候如果提交偏移量2的话，1就被覆盖提交了<ul>
<li>第一种处理，遇到可重试错误是，提交最后一个处理成功的偏移量，吧还没处理好的消息保存到缓存中，调用消费者的pause方法确保且他轮询不会返回数据，保持轮询的同时进行重试处理，如果超出重试次数失败那消息会被丢失，且记录错误，调用resume方法继续轮询</li>
<li>第二种处理，把错误写入一个独立的主题进行处理</li>
</ul>
</li>
<li>消费者可能需啊哟维护状态：比如轮询得到平均值，这个时候可以把这个结果值和偏移量一起保存到主题上，Kafka提供这样的一个极致</li>
<li>长时间处理：如果消费逻辑非常耗时，那不能一直处理，这样没有心跳broker会认为消费者消亡了，这个时候可以使用连接池</li>
<li>仅一次传递：指一次消费，介绍了几种方式都是依赖外部容器进行唯一性校验，本质上Kafka没有单次消费策略</li>
</ul>
<h2 id="验证系统可靠性"><a href="#验证系统可靠性" class="headerlink" title="验证系统可靠性"></a>验证系统可靠性</h2><p>就是通过各种边界情况去对系统进行测试</p>
<ul>
<li>配置验证</li>
<li>应用程序验证</li>
<li>在生产环境监控可靠性</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka -- 四、消费者</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Kafka/%E5%9B%9B%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="消费者和群组"><a href="#消费者和群组" class="headerlink" title="消费者和群组"></a>消费者和群组</h3><ul>
<li><p>可以单独的创建一个消费来对某个主题消息进行消费，但是可能一个消费者速度跟不上</p>
</li>
<li><p>扩展单个消费者为消费者群组，一个群组中的消费者订阅的是同一个主题，Kafka会去控制消费者和分区之间的关联，群组中每个消费者接收主题一部分分区的消息<br><img src="/img/16384404073521638440407283.png"></p>
</li>
<li><p>通过扩展消费者数量来提高消费速度，需要注意不要让消费者数量超过分区，多出来的消费者会被闲置</p>
<p><img src="/img/16384406997861638440699768.png"></p>
</li>
<li><p>如上图，两个群组可以互不干扰的消费同一个主题</p>
</li>
</ul>
<h3 id="消费者和分区再均衡"><a href="#消费者和分区再均衡" class="headerlink" title="消费者和分区再均衡"></a>消费者和分区再均衡</h3><p>考虑一些操作或者异常情况：</p>
<ul>
<li>添加新分区</li>
<li>关闭群组中的某个消费者或群组中某个消费者异常消亡</li>
</ul>
<p>这些情景下会发生分区重分配，分区的所有权从一个消费者转移到另一个消费者，叫做再均衡</p>
<ul>
<li>消费者通过向群组协调器borker（从broker集群中指派出来的，且不同的群组可以有不同的协调器）发送心跳来维持它和群组的从属关系以及对分区的所有权关系</li>
<li>消费者会在轮询消息或提交偏移量时发送心跳，如果消费者停止发送心跳时间足够长，回话就会过期，协调器会认为它已经死亡，触发一次再均衡</li>
<li>如果一个消费者崩溃，协调器会等待几秒钟确认它死亡了才触发再均衡</li>
<li>如果一个消费者被清理（正常的关闭），它会主动通知协调器，协调器会立即触发一次再均衡</li>
<li>后续的章节会讨论心跳发送频率和回话过期时间该如何结合情景进行配置</li>
<li>分区分配流程：第一个加入群组的消费者会成为群主，群主去获取群成员列表并负责给每个成员分配分区，只有群主能看到完整信息，普通成员只能看到自己的配置</li>
</ul>
<h2 id="创建Kafka消费者"><a href="#创建Kafka消费者" class="headerlink" title="创建Kafka消费者"></a>创建Kafka消费者</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">consumer = KafkaConsumer(</span><br><span class="line">  bootstrap_servers=<span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(KAFKA_HOST, KAFKA_PORT),</span><br><span class="line">  group_id=<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">  key_deserializer=<span class="keyword">lambda</span> k: json.loads(k).encode(),</span><br><span class="line">  value_deserializer=<span class="keyword">lambda</span> v: json.loads(v).encode()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>只有bootstrap_servers是必要的</li>
<li>key_deserializer和value_deserializer可以不设置，后续自己手动处理，不过一般认为是必要参数，把序列化过程标准化</li>
</ul>
<h2 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h2><p><code>consumer.subscribe(topics=[])</code></p>
<p>一个消费者可以订阅多个主题</p>
<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">consumer = KafkaConsumer(...)</span><br><span class="line"><span class="keyword">for</span> message <span class="keyword">in</span> consumer:</span><br><span class="line">     key = message.key</span><br><span class="line">     value = message.value</span><br></pre></td></tr></table></figure>

<p>这里再贴一下java是如何轮询的：</p>
<p><img src="/img/16384429474231638442947397.png"></p>
<p><strong>Java里面还有一个while(true)，但是python挺怪的直接遍历consumer对象即可，后面可以研究一下</strong>，从Java可以看出本质是IO多路复用方式进行实现的</p>
<p>关于线程安全：最好是一个消费者一个线程，无法让一个线程运行多个消费者，也不能保证多个线程安全共享一个消费者</p>
<h2 id="消费者的配置"><a href="#消费者的配置" class="headerlink" title="消费者的配置"></a>消费者的配置</h2><p>这里我没有处理过真实的消费场景，暂时跳过</p>
<h2 id="提交和偏移量"><a href="#提交和偏移量" class="headerlink" title="提交和偏移量"></a>提交和偏移量</h2><h2 id="再均衡监听器"><a href="#再均衡监听器" class="headerlink" title="再均衡监听器"></a>再均衡监听器</h2><h2 id="从特定偏移量出开始消费"><a href="#从特定偏移量出开始消费" class="headerlink" title="从特定偏移量出开始消费"></a>从特定偏移量出开始消费</h2><h2 id="如何退出"><a href="#如何退出" class="headerlink" title="如何退出"></a>如何退出</h2><h2 id="反序列化器"><a href="#反序列化器" class="headerlink" title="反序列化器"></a>反序列化器</h2><h2 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h2><ul>
<li>如果一个主题只需要一个消费者就能完成消息的处理，那就没必要加入群组，省去了再均衡之类的操作</li>
<li>消费者可以订阅主题后获得主题下的所有分区，然后把所有分区都订阅一遍</li>
<li>需要注意的是，这样的情况下如果主题添加了新的分区这个消费者是不能自动订阅的<ul>
<li>定期的迭代订阅主题的分区</li>
<li>主题添加分区的时候重启消费者服务</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB -- 一、基础知识</title>
    <url>/2023/04/26/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MongoDB/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p><img src="/img/Mongodb.png" alt="Mongodb"></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li>文档是mongo中数据的基础单元，类似于mysql中的行</li>
<li>集合类似于表</li>
<li>每个文档都有一个特殊的唯一键<code>_id</code></li>
<li>mongo自带一个JS shell，可用于管理</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>文档是键值对的一个有序集合，例如：<code>&#123;&quot;greeting&quot; : &quot;Hello, world!&quot;&#125;</code></p>
<ul>
<li>文档的键是字符串（<code>\0</code>不能使用，空字符用于表示键的结尾；<code>.</code>和<code>$</code>具有特殊意义是保留字符，尽量避免使用）</li>
<li>键值不仅区分类型，同样会区分大小写</li>
<li>文档不能有重复的键</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>是一组文档，类似于表的概念</p>
<h3 id="动态模式"><a href="#动态模式" class="headerlink" title="动态模式"></a>动态模式</h3><p>集合是动态模式的，一个集合里面的文档可以是各式各样的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;greeting&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Hello, world!&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;foo&quot;</span> <span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以上两个文档可以存储在同一个集合里面，这就和mysql大不相同了，既然所有结构的文档都可以存储在同一个集合里面，那集合这个层级存在的意义是什么</p>
<ul>
<li>方便管理，对开发者来说也是很好的数据隔离策略</li>
<li>分开存储在查询效率上会更高</li>
<li>相同类型的文档在逻辑上存在关联，放到一起存储方便批量的查询（同样会被写入磁盘）</li>
<li>方便索引的创建</li>
</ul>
<p>其实本质还是关系型数据库思维大行其道，当前的程序设计都是在这个基础上搭建的，导致mongo只能去迎合，不然就会成为小众服务</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>本质上没什么特别的，和key一样别用<code>\0 . $</code>，且别以system.进行开头，这是系统集合保留前缀</p>
<h3 id="子集合"><a href="#子集合" class="headerlink" title="子集合"></a>子集合</h3><p>比如blog.posts和blog.authors，这两个集合都是博客系统的，但本质上和叫blog的集合没有关系（很可能根本没有这个集合），类似于命名空间</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>没啥好说的</p>
<h2 id="shell简介"><a href="#shell简介" class="headerlink" title="shell简介"></a>shell简介</h2><p>类似于mysql的命令行交互模式，不过mongo的shell说基于javascript的，所有支持所有js原生库，它是mongo的一个客户端，可以在里面进行操作</p>
<p>mongo的继承操作命令就不放到这里了</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li><p>null</p>
<p> <code>&#123;&quot;x&quot; : null&#125;</code></p>
</li>
<li><p>布尔：只有两个值true和false</p>
</li>
<li><p>数值：默认会使用64位浮点数，也可以显式的指定</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;x&quot;</span> <span class="punctuation">:</span> NumberInt(<span class="string">&quot;3&quot;</span>)<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;x&quot;</span> <span class="punctuation">:</span> NumberLong(<span class="string">&quot;3&quot;</span>)<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>字符串</p>
</li>
<li><p>日期：精确度为毫秒</p>
</li>
<li><p>正则表达式：<code>&#123;&quot;x&quot; : /foobar/i&#125;</code> 这个给我整不会了，后面再看使用场景吧</p>
</li>
<li><p>数组</p>
</li>
<li><p>内嵌文档</p>
</li>
<li><p>对象ID：<code>&#123;&quot;_id&quot; : ObjectId()&#125;</code> 12字节的ID，文档的唯一标识</p>
<ul>
<li>ObjectId是’_id’的默认类型，不同的机器都能用全局唯一的同种方法方便地生成它，由于mongo在设计的时候就是分布式数据库，所以没有使用通用的自增主键，虽然更节省空间，但是在分布式节点上维护其唯一性更麻烦一些</li>
<li>使用12字节的存储空间，由24个十六进制数字组成的字符串</li>
<li>如果文档插入时没有指定_id系统会自动生成一个，但更建议在客户端进行生成，即使是对mongo这样扩展性非常好的数据库，扩展应用仍然会比扩展数据库层容易得多，能在客户端做的事情尽量在客户端做减轻服务器压力</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB -- 三、索引</title>
    <url>/2023/04/26/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MongoDB/%E4%B8%89%E3%80%81%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p><img src="/img/Mongodb.png" alt="Mongodb"></p>
<h1 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h1><h2 id="索引的创建和分析"><a href="#索引的创建和分析" class="headerlink" title="索引的创建和分析"></a>索引的创建和分析</h2><ul>
<li>分析语句<code>db.index_test.find(&#123;&#39;name&#39;: &#39;yjvud&#39;&#125;).explain()</code> 不是很靠谱，和文档里面展示的内容不同没看出什么信息</li>
<li>创建索引<code>db.index_test.ensureIndex(&#123;&#39;name&#39;: 1&#125;)</code> 创建后再进行分析查看，可以看到索引方案被使用了</li>
<li>创建复合索引<code>db.index_test.ensureIndex(&#123;&#39;age&#39;: 1, &#39;name&#39;: 1&#125;)</code><ul>
<li>Mongo里面复合索引逆序不能生效，也就是说上面的索引只能通过年龄定位后顺序的拿出名称，要从z-a的获取名称的话效率就很低了，需要再创建一个索引<code>db.index_test.ensureIndex(&#123;&#39;age&#39;: 1, &#39;name&#39;: -1&#125;)</code>，当然单个索引不需要，这个后面看具体的数据结构就知道原因了</li>
</ul>
</li>
<li>覆盖索引，和mysql里面一样存在回表操作</li>
<li>隐式索引，复合索引同样存在前缀原则，这些属于隐式索引</li>
</ul>
<h2 id="操作符如何使用索引"><a href="#操作符如何使用索引" class="headerlink" title="$操作符如何使用索引"></a>$操作符如何使用索引</h2><p>使用经验太少，结论是用这个操作符之后大多数的操作不一定能使用索引，使用的时候最好进行确认</p>
<ul>
<li>$where和$exists无法使用索引</li>
<li>范围查询，使用复合索引的时候尽量将精确匹配的条件放到前面，其实就是通过一个个字段来尽量缩小查询范围</li>
<li>$or查询，mongo中一次查询只能使用一个索引，但是如果两个语句通过or进行连接的时候可以使用两个索引，本质可以看成两次查询，然后将查询结果进行合并</li>
</ul>
<h2 id="索引对象和数组"><a href="#索引对象和数组" class="headerlink" title="索引对象和数组"></a>索引对象和数组</h2><h3 id="索引嵌套文档"><a href="#索引嵌套文档" class="headerlink" title="索引嵌套文档"></a>索引嵌套文档</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sid&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.2.3.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Springfield&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NY&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于这样一个文档，可以为之字段创建索引<code>db.users.ensureIndex(&#123;&quot;loc.city&quot; : 1&#125;)</code>，其索引结构和普通索引没有区别</li>
<li>当然也可以对整个嵌套文档建立索引<code>db.users.ensureIndex(&#123;&quot;loc&quot; : 1&#125;)</code>，不过这个时候只有使用与子文档字段顺序完全匹配的查询才能使用该索引<code>db.users.find(&#123;&quot;loc&quot; : &#123;&quot;ip&quot; : &quot;123.456.789.000&quot;， &quot;city&quot; : &quot;Shelbyville&quot;， &quot;state&quot; : &quot;NY&quot;&#125;&#125;&#125;))</code></li>
</ul>
<h3 id="索引数组"><a href="#索引数组" class="headerlink" title="索引数组"></a>索引数组</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20220101&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20220102&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;just so so&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对数组中的元素创建索引<code>db.blog.ensureIndex(&#123;&quot;comments.date&quot; : 1&#125;)</code>，比如获取一段时间内评论次数最多的文章，这个时候会将数组中的每个元素都创建索引条目（数量规模会很大）</li>
<li>与上面的嵌套文档不同，不能把数组作为一个实体创建索引，<code>db.blog.ensureIndex(&#123;&quot;comments&quot; : 1&#125;)</code>这个时候实际上是对数组中的每个字段创建索引</li>
<li>数组上创建的索引并不包含位置信息，也就是说无法通过下角标对数据进行过滤，比如<code>comments.4</code></li>
<li>为了避免数据爆炸增长，mongo不允许一个索引中出现多个数组字段，假如创建索引<code>&#123;&quot;x&quot; : 1， &quot;y&quot; : 1&#125;</code>，这个时候x和y不能同时为数组，注意两个都可以是数组元素，只是不能同时为数组</li>
<li>多键索引，对于索引的键，如果某个文档中这个键的内容是一个数组，那这个索引会被标记为多键索引，即使后续所有数组文档都被删除也不会变回非多键索引，只有把索引删除再重建；多键索引可能会比非多键索引慢一些，因为可能会有多个索引条目指向同一个文档，返回结果集时需要进行去重</li>
</ul>
<h2 id="索引基数"><a href="#索引基数" class="headerlink" title="索引基数"></a>索引基数</h2><p>就是指同一个索引中数据的不重复度，和mysql中一样</p>
<h2 id="explain-和hint"><a href="#explain-和hint" class="headerlink" title="explain()和hint()"></a>explain()和hint()</h2><p>由于我这里没有拿到符合预期的结果，暂时不对这个方法进行分析了</p>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><ul>
<li>创建唯一索引<code>db.index_test.ensureIndex(&#123;&#39;age&#39;: 1&#125;, &#123;&quot;unique&quot; : true&#125;)</code></li>
<li>检查唯一性抛出异常时会影响效率，注意这里说的是抛出异常才会影响效率，检查好像影响不大（<div style="color:red;">没有缓存穿透的问题？</div>），所以这里建议是只有少量重复数据时才使用，别用来作为数据校验</li>
<li>如果一个文档对于字段没有值，那么索引里面会存储为null，对于唯一索引来说只能有一个文档允许索引字段没有值，因为第二个过来还会尝试存储为null就重复了</li>
<li>索引的存储桶有大小限制，要小于1024，超过就无法存储到索引中了，也就是说对应的文档不能在索引中找到</li>
<li>创建唯一索引可能会失败，因为已有的数据存在重复，这个时候有一个关键字dropdups可以强制创建，原理是保留第一个文档，删除其余重复文档，要谨慎使用</li>
</ul>
<h3 id="复合唯一索引"><a href="#复合唯一索引" class="headerlink" title="复合唯一索引"></a>复合唯一索引</h3><ul>
<li>创建复合唯一索引<code>db.index_test.ensureIndex(&#123;&#39;age&#39;: 1, &#39;name&#39;: 1&#125;, &#123;&quot;unique&quot; : true&#125;)</code></li>
<li>复合键同时重复时抛出异常</li>
</ul>
<h3 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h3><ul>
<li>注意这里的稀疏索引和关系型数据库中的稀疏索引不是一回事，mongo里面只是说不需要将每个文档都作为索引条目</li>
<li>刚才说了对于多个没有值的文档无法创建唯一索引，这个时候可以通过稀疏索引来解决，也就是说只要求有值的文档值不重复</li>
<li>对于非唯一稀疏索引，如果一个文档的索引键没有值，那么这个文档就不会出现在索引中，也就是只对有值的文档建立索引，这个时候如果进行非查询结果会和非稀疏索引不同</li>
</ul>
<h2 id="管理索引"><a href="#管理索引" class="headerlink" title="管理索引"></a>管理索引</h2><p>mongo中有一个保留集合system.indexes，这里面存储了索引元信息</p>
<ul>
<li>修改索引：并没有修改的方法，只能删除重建，创建索引的时候会锁定集合，可以选择后台创建，但是创建的速度会慢一些</li>
<li>在已有文档上创建索引比创建好索引后再插入数据要快</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB -- 二、操作命令</title>
    <url>/2023/04/26/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MongoDB/%E4%BA%8C%E3%80%81%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="/img/Mongodb.png" alt="Mongodb"></p>
<h1 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h1><ul>
<li>进入命令行：到服务器上运行（当然前提是使用docker方式进行安装的）<code>docker exec -it  mongodb  mongo admin</code></li>
<li>通过navicat连接：正常输入用户名密码即可（注意要将开放服务器对应端口的防火墙）</li>
</ul>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><ul>
<li>创建数据库<ul>
<li><code>use db_name</code></li>
<li>mongo不需要使用类似create这样的关键字来显式的创建数据库</li>
</ul>
</li>
<li>查看数据库<code>show dbs</code>，注意上面我们使用use命令创建的数据库必须要插入数据之后才会被展示到dbs的结果列表中</li>
<li>查看当前数据库<code>db</code></li>
</ul>
<h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.first_table.insert(&#123;&#x27;name&#x27;: &#x27;liuxulu&#x27;&#125;)</span><br><span class="line">db.first_table.find()</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;61c0386a55fe7a268eff2b6d&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;liuxulu&quot;</span> &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由于没有指定<code>_id</code>，这个时候mongo会给文档自动增加一个<code>_id</code></li>
</ul>
<h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p><code>db.first_table.insertMany([&#123;&#39;key0&#39;:0&#125;,&#123;&#39;key1&#39;:1&#125;, &#123;&#39;key2&#39;: 2&#125;])</code></p>
<ul>
<li>显然批量插入可以有效减小请求次数从而提高写入效率（目前还不确定服务端是否有相关的优化）</li>
<li>目前mongo能接受的最大消息长度为48M，如果批量插入内容超出，多数的驱动会自动把请求进行拆分</li>
<li>如果执行批量插入过程中的一个文档插入失败，那么在这这个文档之前的数据会被成功插入，这个文档及以后的文档会全部失败，也可以通过配置continueOnError来让后面的文档继续插入</li>
</ul>
<h3 id="插入校验"><a href="#插入校验" class="headerlink" title="插入校验"></a>插入校验</h3><p>MongoDB只会进行最基本的检查</p>
<ul>
<li>有无<code>_id</code></li>
<li>文档必须小于16MB（后续可能会进行扩展）</li>
</ul>
<p>基于Mongo的这个特点导致的是很容易被插入非法数据，所以应该要严格的限制信任的源才能访问数据库（当然基本所有的驱动都会对数据进行合法校验来补齐这个短板）</p>
<h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除所有文档</span></span><br><span class="line">db.first_table.remove()</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">过滤删除</span></span><br><span class="line">db.first_table.remove(&#123;&#x27;key1&#x27;:1&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除集合</span></span><br><span class="line">db.first_table.drop()</span><br></pre></td></tr></table></figure>

<p>drop就类似于mysql中的truncate，remove删除的是内容会保留集合元数据，drop会直接把整个集合删掉，优点是速度非常快</p>
<h2 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h2><h3 id="文档替换"><a href="#文档替换" class="headerlink" title="文档替换"></a>文档替换</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.<span class="property">first_table</span>.<span class="title function_">update</span>(&#123;<span class="string">&quot;_id&quot;</span> : <span class="title class_">ObjectId</span>(<span class="string">&quot;61c0386a55fe7a268eff2b6d&quot;</span>)&#125;, &#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;liuxulu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line">db.<span class="property">first_table</span>.<span class="title function_">update</span>(&#123;<span class="string">&quot;_id&quot;</span> : <span class="title class_">ObjectId</span>(<span class="string">&quot;61c0386a55fe7a268eff2b6d&quot;</span>)&#125;, &#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>注意这种方式会将原本的文档内容进行完全的替换，而不是局部字段内容的修改</li>
<li>这里我们直接用id对数据进行了定位，如果使用的是别的字段来进行过滤，必须要保证结果的唯一性，不然修改会报错（我不李姐，如果本身就是想要批量修改呢）</li>
</ul>
<h3 id="使用修改器"><a href="#使用修改器" class="headerlink" title="使用修改器"></a>使用修改器</h3><ul>
<li><p>$set</p>
<ul>
<li><p><code>db.first_table.update(&#123;&quot;_id&quot; : ObjectId(&quot;61c0386a55fe7a268eff2b6d&quot;)&#125;, &#123;&quot;$set&quot;: &#123;&quot;age&quot;: 25&#125;&#125;)</code></p>
</li>
<li><p>对指定字段内容进行修改</p>
</li>
</ul>
</li>
<li><p>$unset</p>
<ul>
<li><code>db.first_table.update(&#123;&quot;_id&quot; : ObjectId(&quot;61c0386a55fe7a268eff2b6d&quot;)&#125;, &#123;&quot;$unset&quot;: &#123;&quot;age&quot;: 25&#125;&#125;)</code></li>
<li>删除指定的字段</li>
</ul>
</li>
<li><p>$inc：累加数字，不能用于别的类型</p>
</li>
<li><p>$push：向数组末尾添加一个元素，如果数组还不存在则初始化一个新数组</p>
</li>
<li><p>$pop：删除数组末端的一个元素</p>
</li>
<li><p>还有一些修改器，不一一列举</p>
</li>
</ul>
<h2 id="写入安全机制"><a href="#写入安全机制" class="headerlink" title="写入安全机制"></a>写入安全机制</h2><p>Mongo同样提供应答式写入和非应答式写入，不太重要的数据可以使用非应答式写入来提高速度</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全文查询</span></span><br><span class="line">db.first_table.find()</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单条件查询</span></span><br><span class="line">db.first_table.find(&#123;&#x27;name&#x27;: &#x27;liuxulu&#x27;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">多条件</span></span><br><span class="line">db.first_table.find(&#123;&#x27;name&#x27;: &#x27;liuxulu&#x27;, &#x27;age&#x27;: 25&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定返回的字段，这里<span class="built_in">id</span>默认返回，可以显式指定不返回</span></span><br><span class="line">db.first_table.find(&#123;&#x27;name&#x27;: &#x27;liuxulu&#x27;&#125;, &#123;&#x27;name&#x27;: 1, &#x27;age&#x27;: 1, &#x27;_id&#x27;: 0&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">范围查询</span></span><br><span class="line">db.first_table.find(&#123;&#x27;age&#x27;: &#123;&quot;$gte&quot; : 18, &quot;$lte&quot; : 30&#125;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不等于</span></span><br><span class="line">db.first_table.find(&#123;&#x27;name&#x27;: &#123;&#x27;$ne&#x27; : &#x27;liuxulu&#x27;&#125;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span>查询</span></span><br><span class="line">db.first_table.find(&#123;&#x27;name&#x27;: &#123;&#x27;$in&#x27; : [&#x27;liuxulu&#x27;, &#x27;firefly&#x27;]&#125;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nin查询，<span class="keyword">in</span>的反义查询</span></span><br><span class="line">db.first_table.find(&#123;&#x27;name&#x27;: &#123;&#x27;$nin&#x27; : [&#x27;liuxulu&#x27;, &#x27;firefly&#x27;]&#125;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or查询</span></span><br><span class="line">db.first_table.find(&#123;</span><br><span class="line">	&quot;$or&quot;:[</span><br><span class="line">		&#123;&#x27;name&#x27;: &#123;&#x27;$nin&#x27; : [&#x27;liuxulu&#x27;, &#x27;firefly&#x27;]&#125;&#125;,</span><br><span class="line">		&#123;&#x27;age&#x27;: 25&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">not查询，注意not后面必须要接一个判断语句</span></span><br><span class="line">db.first_table.find(&#123;&#x27;name&#x27;: &#123;&#x27;$not&#x27;:&#123;&#x27;$in&#x27; : [&#x27;liuxulu&#x27;, &#x27;firefly&#x27;]&#125;&#125;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">null判断</span></span><br><span class="line">db.first_table.find(&#123;&#x27;name&#x27;:null&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="数组查询"><a href="#数组查询" class="headerlink" title="数组查询"></a>数组查询</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据案例</span></span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;61c0386a55fe7a268eff2b6d&quot;), &quot;name&quot; : &quot;liuxulu&quot;, &quot;age&quot; : 25, &quot;fruit&quot; : [ &quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot; ] &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断是否包含某个元素</span></span><br><span class="line">db.first_table.find(&#123;&quot;fruit&quot; : &quot;banana&quot;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时包含多个元素</span></span><br><span class="line">db.first_table.find(&#123;&quot;fruit&quot; : &#123;&quot;$all&quot;: [&quot;banana&quot;, &quot;apple&quot;]&#125;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对数组相等进行判断</span></span><br><span class="line">db.first_table.find(&#123;&quot;fruit&quot; : [&quot;apple&quot;, &quot;banana&quot;, &quot;peach&quot;]&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">size判断</span></span><br><span class="line">db.first_table.find(&#123;&quot;fruit&quot; : &#123;&quot;$size&quot;: 3&#125;&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">由于size不能盒gt、lt进行配合，无法直接做到对数组长度进行范围过滤，变通的方式是创建一个额外的字段size来对数组长度进行记录，当对数据进行push或者pop之类的操作的时候使用inc来同步修改size的数值，后面就可以通过对size使用gt、lt来进行过滤了</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">slice，只返回数值的部分元素</span></span><br><span class="line">db.first_table.find(&#123;&quot;_id&quot;: ObjectId(&quot;61c0386a55fe7a268eff2b6d&quot;)&#125;, &#123;&quot;_id&quot;: 0, &quot;fruit&quot;: &#123;&quot;$slice&quot;: -1&#125;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var cursor = db.collection.find();</span><br><span class="line">while (cursor.hasNext()) &#123;</span><br><span class="line">	obj = cursor.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>游标在语句构建的时候请求没有真的发给数据库，等到cursor.hasNext()方法调用的时候才会查询服务器</li>
<li>客户端每次只会取前100个结果（或者是4M数据），当客户端将结果耗尽之后会通过一个ge tMore请求获取更多的结果</li>
<li>注意一下游标的释放，游标在服务端是需要占用内存资源的（保存查询状态嘛），正常来说客户端在释放掉游标资源的时候会告诉服务端同样进行清理，当然服务器会有一个10分钟超时清理的机制来避免内存泄露</li>
</ul>
<h3 id="limit、ship、sort"><a href="#limit、ship、sort" class="headerlink" title="limit、ship、sort"></a>limit、ship、sort</h3><p>这三个通用方法，不介绍功能，使用的时候要注意以下的情况</p>
<ul>
<li><p>避免使用skip略过大量结果：skip的原理是把符合条件的结果查询出来然后丢弃指定数量多结果后进行返回</p>
</li>
<li><p>分页问题</p>
<ul>
<li>方式之一就是用skip，弊端就是越往后效率就越低，经验来看数据量要控制在1w以内</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var page1 = db.foo.find(criteria).limit(100)</span><br><span class="line">var page2 = db.foo.find(criteria).skip(100).limit(100)</span><br><span class="line">var page3 = db.foo.find(criteria).skip(200).limit(100)</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二是最多提供前1w条数据，其实对用用户来说给到更多的结果也没有意义，应该通过添加过滤条件来进行数据定位</li>
<li>方式三结合场景来构建查询条件，比如按时间排序，每页的查询都从前一页最后一个数据开始查询即可（点赞数量排序之类的也类似），其实是方式二的变种，缺点是对数据更新频繁的库很可能导致查询出现脏数据</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB -- 特殊集合和索引</title>
    <url>/2023/04/26/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MongoDB/%E7%89%B9%E6%AE%8A%E9%9B%86%E5%90%88%E5%92%8C%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p><img src="/img/Mongodb.png" alt="Mongodb"></p>
<h1 id="特殊集合和索引"><a href="#特殊集合和索引" class="headerlink" title="特殊集合和索引"></a>特殊集合和索引</h1><h2 id="固定集合"><a href="#固定集合" class="headerlink" title="固定集合"></a>固定集合</h2><p>之前介绍的集合都是随着文档插入规模不断变大的，固定的集合是规模是固定的，结构和循环队列类似，如果没有空间了，就替换最老的文档</p>
<ul>
<li><p>创建：和普通集合不同，固定集合需要显式的进行创建，创建后其属性就不能再被改变了</p>
</li>
<li><p>自然排序：固定集合可以按数据插入的顺序读取数据</p>
</li>
<li><p>循环游标：类似于tail -f，可以持续的从集合中获取数据，只适用于固定集合</p>
</li>
<li><p>没有_id索引的集合</p>
<ul>
<li>允许一个集合不需要_id索引，可以提高数据插入效率</li>
<li>2.2版本以前固定集合默认是没有id索引的</li>
</ul>
</li>
</ul>
<h2 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h2><p>固定集合中内容会被自动覆盖，控制不是很灵活，TTL（time to live index）生命周期索引，允许为每一个文档设置一个超时时间</p>
<p>TTL是创建一个索引，对指定字段（时间类型）的数据进行比对，超过设置的过期时间之后该文档会被删除，这里清理的频率上每分钟，所以不能保证秒级别的过期时间</p>
<h2 id="全文本索引"><a href="#全文本索引" class="headerlink" title="全文本索引"></a>全文本索引</h2><p>类似于ES的索引，mongo中可能还不是很成熟，对性能的影响可能会很大，需要衡量好再使用</p>
<h2 id="地理空间索引"><a href="#地理空间索引" class="headerlink" title="地理空间索引"></a>地理空间索引</h2><p>mongo支持几种地理空间索引，可以用来进行相关数据的存储和查询</p>
<h2 id="GridFS存储文件"><a href="#GridFS存储文件" class="headerlink" title="GridFS存储文件"></a>GridFS存储文件</h2><p>是mongo的大型二进制文件存储机制，如果已经使用了mongo的技术栈可以考虑使用，来作为一个文件存储工具</p>
<p>优点：</p>
<ul>
<li>自动进行分布式平衡和复制，是一种扩容和安全性保障机制</li>
<li>可以在一个目录下存储大量文件，且存储会比较集中</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能较低，不如直接从文件系统中访问快（估计是抛出网络传输因素之后也更慢的意思）</li>
<li>不能增量更新</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL -- SQL注入</title>
    <url>/2023/01/03/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MySQL/SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h1 id="Django-ORM"><a href="#Django-ORM" class="headerlink" title="Django ORM"></a>Django ORM</h1><h2 id="模型查询"><a href="#模型查询" class="headerlink" title="模型查询"></a>模型查询</h2><p>使用Django自己提供的模型层语法进行数据查询可以防止SQL注入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">asns = FpingAsn.objects.<span class="built_in">filter</span>(operator_id__in=operators).values_list(<span class="string">&#x27;asn&#x27;</span>, flat=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>



<h2 id="使用原生SQL"><a href="#使用原生SQL" class="headerlink" title="使用原生SQL"></a>使用原生SQL</h2><p>方式一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line">cursor = connection.cursor()</span><br><span class="line">query_sql = <span class="string">&quot;select count(*) from automatic_product.subinterface where is_alloc = 1 and site_id = &#x27;&#123;&#125;&#x27; and app_id is not null and status = &#x27;ok&#x27;&quot;</span>.<span class="built_in">format</span>(site.<span class="built_in">id</span>)</span><br><span class="line">cursor.execute(query_sql)</span><br><span class="line">used_count = cursor.fetchall()</span><br></pre></td></tr></table></figure>

<ul>
<li>这种方式下，不能防止SQL注入，需要把参数拆开查询</li>
</ul>
<p>方式二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">id_str = <span class="string">&quot;中国电信 or 1=1 --&quot;</span></span><br><span class="line">sql = <span class="string">&quot;select * from fping_operator where name = %s&quot;</span></span><br><span class="line">fs = FpingOperator.objects.raw(sql, [id_str])</span><br></pre></td></tr></table></figure>

<ul>
<li>raw通过这种方式也可以防止sql注入，类似于execute，但是自己拼接sql字符串后调用raw不能防sql注入</li>
</ul>
<h1 id="pymysql"><a href="#pymysql" class="headerlink" title="pymysql"></a>pymysql</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&quot;xxx&quot;</span>, port=<span class="number">3306</span>, user=<span class="string">&quot;xxx&quot;</span>, passwd=<span class="string">&quot;xxx&quot;</span>, db=<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">&#x27;delete from stu where name = %s and age = %s&#x27;</span></span><br><span class="line"></span><br><span class="line">cursor.execute(sql, (<span class="string">&#x27;tom&#x27;</span>, <span class="number">19</span>))   <span class="comment"># 参数为元组格式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>pymysql 的 execute 支持参数化 sql，通过占位符 %s 配合参数就可以实现 sql 注入问题的避免</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据持久化 -- 前车之覆</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MySQL/%E5%89%8D%E8%BD%A6%E4%B9%8B%E8%A6%86/</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="varchar字段排序、求和"><a href="#varchar字段排序、求和" class="headerlink" title="varchar字段排序、求和"></a>varchar字段排序、求和</h3><p>排序varchar字段（里面装的本来就是数字），user_age字段是varchar类型，加0即可，这是最简单的方式，还有些别的字符类型还有对应的转化方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select user_name,user_age from user order by user_age+0 asc;</span><br><span class="line"></span><br><span class="line">select sum(user_age+0) from user;</span><br></pre></td></tr></table></figure>

<h3 id="timestemp设置默认值"><a href="#timestemp设置默认值" class="headerlink" title="timestemp设置默认值"></a>timestemp设置默认值</h3><p>两种方式，一种是设置为该字段最小值（<font color="red">1970-01-01 08:00:01 ~ 2038-01-19 11:14:07</font>），这里不推荐设置为<font color="red">0000-00-00 00:00:00</font>，不是所有版本都兼容这个值；第二种是当前时间<font color="red">CURRENT_TIMESTAMP</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create_at timestamp null default &#x27;1970-01-01 08:00:01&#x27; comment &#x27;test&#x27;</span><br><span class="line">create_at timestamp null default CURRENT_TIMESTAMP comment &#x27;test&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="国家、语言"><a href="#国家、语言" class="headerlink" title="国家、语言"></a>国家、语言</h3><p>国家和语言的存储通常使用代码的方式</p>
<ul>
<li>国家的域名缩写长度是2，所以用char(2)；</li>
<li>语言的缩写是zh-CN，有的是两位，所以用char(5)</li>
</ul>
<p>性别用0和1表示</p>
<h3 id="字段允许为null"><a href="#字段允许为null" class="headerlink" title="字段允许为null"></a>字段允许为null</h3><ul>
<li>单列索引不会存储null值，可能会得到不符合预期的结果  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where name != &#x27;shenjian&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="单记录查询"><a href="#单记录查询" class="headerlink" title="单记录查询"></a>单记录查询</h3><p>如果明确知道只有一条结果，那么加上limit 1可以提高效率（明确告诉它，让它主动停止游标移动）</p>
<h3 id="把计算放到业务层"><a href="#把计算放到业务层" class="headerlink" title="把计算放到业务层"></a>把计算放到业务层</h3><p>原理是多次调用的时候传入相同的sql，才可以利用查询缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from order where date &lt; = CURDATE()</span><br><span class="line">优化后：</span><br><span class="line">$curDate = date(&#x27;Y-m-d&#x27;);</span><br><span class="line">$res = mysql_query(</span><br><span class="line">    &#x27;select * from order where date &lt; = $curDate&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="重复数据处理"><a href="#重复数据处理" class="headerlink" title="重复数据处理"></a>重复数据处理</h3><ul>
<li>查询</li>
<li>删除<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 完整语句</span><br><span class="line"></span><br><span class="line"># </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="offset问题"><a href="#offset问题" class="headerlink" title="offset问题"></a>offset问题</h3><p>产考：<a href="https://blog.csdn.net/AinUser/article/details/72803175">https://blog.csdn.net/AinUser/article/details/72803175</a></p>
<ul>
<li><p>下面这个命令会扫描10010条数据丢弃前10000条数据，一般适用于做分页（有排序条件，最好给排序字段建立索引），且不要把offset的值设得过大（建议不要超过10000），不然还是会很慢</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table limit 10 offset 10000</span><br></pre></td></tr></table></figure></li>
<li><p>如果只是想按id每次拿出10条数据来做处理，那么可以用下面的命令做替换</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where id &gt; 10000 limit 10</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ES自动同步对数据带来性能问题"><a href="#ES自动同步对数据带来性能问题" class="headerlink" title="ES自动同步对数据带来性能问题"></a>ES自动同步对数据带来性能问题</h3><p>ES索引自动同步走binlog可以解决大部分的性能问题，但是携带的关联查询还是需要走sql，需要根据场景进行优化</p>
<h3 id="大表数据条件删除"><a href="#大表数据条件删除" class="headerlink" title="大表数据条件删除"></a>大表数据条件删除</h3><p>商品表有5000w数据，占用了50G+的磁盘空间，对失效数据进行删除后只保留了300w数据，数据库自动释放了部分空间，还有40G的磁盘占用</p>
<p>进行手动释放：<code>OPTIMIZE TABLE shopify_product</code> ，需要注意，这个时候会加读写锁，看情况使用，另外的方式是新建一个表迁移数据，删除原表（影子备份）</p>
]]></content>
      <categories>
        <category>数据持久化</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>数据持久化 -- 字段类型详解</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MySQL/%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>MySQL数值类型分为两类，整数和浮点数</p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>整体来说就是根据实际使用的时候尽量选内存占用最小的</p>
<ul>
<li>tinyint：1字节，（-128，127）基本上用来表示状态的字段适合用这个类型</li>
<li>smallint：2字节，范围是（-32768，32767）</li>
<li>mediumint：3字节，（-8388608，8388607）</li>
<li>int、integer：4字节，（-2147483648，2147483647）</li>
<li>bigint：8字节，范围大到无法想象</li>
</ul>
<p>对于上面的这些整数类型特性上基本一致只是能存储的值不同，最常见的问题是int(2)和int(3),这里的2和3只是一个宽度显示器，并不会影响到数值的存储；例如int(2)同样可以完整的存储100，只是只能展示两位</p>
<p>再说一下unsigned和zerofill两个关键字</p>
<ul>
<li>unsigned：表示无符号，不表示负数，这样字段的内存中就能多出一位来存储数值，比如修饰tinyint的时候它的范围变成了0-255</li>
<li>zerofill：用0来真补输出的值，且当这个关键字修饰时也会自动出现unsigned关键字效果</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li>float：float（7，3）表示总长度不超过7，且小数点后带三位数字</li>
<li>double</li>
<li>decimal</li>
</ul>
<p>浮点数用的很少，就不详细研究了，unsigned和zerofill两个关键字同样适用且效果和修饰整数的时候相同</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>char</li>
<li>varchar</li>
<li>tinyblob</li>
<li>tinytext</li>
<li>blob</li>
<li>text</li>
<li>mediumblob</li>
<li>mediumtext</li>
<li>longblob</li>
<li>longtext</li>
</ul>
<h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><ul>
<li>date</li>
<li>time</li>
<li>year</li>
<li>datetime</li>
<li>timestamp</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>数据持久化 -- 操作命令</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MySQL/%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="服务启动与登录"><a href="#服务启动与登录" class="headerlink" title="服务启动与登录"></a>服务启动与登录</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Linux上mysql安装后都能在/etc/init.d/下找到mysqld,安装的方法不同会导致命令行中不一定能直接找到mysql命令，可以添加到别名中去</span></span><br><span class="line">/etc/init.d/mysqld start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录,回车后输入密码</span></span><br><span class="line">mysql -h localhost -P part -u username -p</span><br></pre></td></tr></table></figure>

<h1 id="SQL-Structured-Query-Language-结构化查询语言-语句"><a href="#SQL-Structured-Query-Language-结构化查询语言-语句" class="headerlink" title="SQL(Structured Query Language  结构化查询语言)语句"></a>SQL(Structured Query Language  结构化查询语言)语句</h1><h2 id="DDL-Data-Definition-Language-数据定义语言"><a href="#DDL-Data-Definition-Language-数据定义语言" class="headerlink" title="DDL(Data Definition Language)数据定义语言"></a>DDL(Data Definition Language)数据定义语言</h2><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show database;</span><br></pre></td></tr></table></figure>

<h4 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use database;</span><br></pre></td></tr></table></figure>

<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database[if not exists] newDBName;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database dbName;</span><br></pre></td></tr></table></figure>


<h4 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a>修改数据库编码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter database dbName character set utf8;</span><br></pre></td></tr></table></figure>

<h4 id="查看所有数据表"><a href="#查看所有数据表" class="headerlink" title="查看所有数据表"></a>查看所有数据表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table tableName(</span><br><span class="line">    id int primary key auto_increment,  </span><br><span class="line">    name varchar(8) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户名&#x27;, </span><br><span class="line">    create_at timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">    update_at timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><ul>
<li>添加字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tableName add(rowName varchar(8));</span><br><span class="line">alter table cloud_pipe_idc add(config varchar(128) not null default &#x27;&#x27; comment &#x27;接口配置&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>修改字段类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tableName modify rowName varchar(8);</span><br></pre></td></tr></table></figure>

<ul>
<li>修改字段名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tableName change oldName newName varchar(8);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除字段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table tableName drop rowName;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改表名称</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table oldName rename to newName;</span><br></pre></td></tr></table></figure>

<h2 id="DML-Data-Manipulation-Language-数据操作语言"><a href="#DML-Data-Manipulation-Language-数据操作语言" class="headerlink" title="DML(Data Manipulation Language)数据操作语言"></a>DML(Data Manipulation Language)数据操作语言</h2><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into tableName(row1,row2) values(data1,data2);</span><br></pre></td></tr></table></figure>

<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tableName set row = &#x27;data&#x27; where row1 = &#x27;data1&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul>
<li>部分数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from tableName where row = &#x27;data&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>清空表:逐行删除表中所有的数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from tableName;</span><br></pre></td></tr></table></figure></li>
<li>重置表：直接删除表然后再重新创建一个新表，属于DDL操作，速度快但是无法回滚<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truncate table tableName;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DCL-Data-Control-Language-数据控制语言"><a href="#DCL-Data-Control-Language-数据控制语言" class="headerlink" title="DCL(Data Control Language)数据控制语言"></a>DCL(Data Control Language)数据控制语言</h2><ul>
<li>创建用户<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user username@localhost identified by &#x27;password&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>用户授权<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># dbName是指要对那个数据进行授权</span><br><span class="line">grant create,alter,drop on dbName.* to username@localhost;</span><br></pre></td></tr></table></figure></li>
<li>撤销授权<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">revoke create,alter,drop on dbName.* from username@localhost;</span><br></pre></td></tr></table></figure></li>
<li>用户权限查看<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show grants for username@localhost;</span><br></pre></td></tr></table></figure></li>
<li>修改用户密码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这个貌似已经随着MySQL的版本发生了变更，用到的时候再更新过来</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="DQL-Data-Query-Language-数据查询语言"><a href="#DQL-Data-Query-Language-数据查询语言" class="headerlink" title="DQL(Data Query Language)数据查询语言"></a>DQL(Data Query Language)数据查询语言</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul>
<li>查询所有列<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tableName;</span><br></pre></td></tr></table></figure></li>
<li>查询指定列<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select rowName1,rowName2 from tableName;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><ul>
<li>普通查询<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tableName where factorOne and factorTwo;</span><br><span class="line">select * from tableName where factorOne or factorTwo;</span><br><span class="line">select * from tableName where rowName in (&#x27;valueOne&#x27;,&#x27;valueTwo&#x27;,&#x27;valueThree&#x27;);</span><br><span class="line"># 关于值为空的判断，is null有的时候并不生效可以用 = &#x27;&#x27;来做判断</span><br><span class="line">select * from tableName where rowName is null;</span><br><span class="line">select * from tableName where rowName is not null;</span><br></pre></td></tr></table></figure></li>
<li>模糊查询<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里的一个_表示任意匹配一个字符(经过测试至少可以匹配字母、数字和中文)，这里要抛去字段的类型，即使是int类型的像是id之类的数据也是要写到&#x27;&#x27;中的</span></span><br><span class="line">select * <span class="keyword">from</span> tableName where rowName like <span class="string">&#x27;__&#x27;</span>;</span><br><span class="line"><span class="comment"># %模糊匹配0-n个字符，意思说这个占位符可以代表任意几个字符</span></span><br><span class="line">select * <span class="keyword">from</span> tableName where rowName like <span class="string">&#x27;%haha%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>去重<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct rowName from tableName;</span><br></pre></td></tr></table></figure></li>
<li>排序<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 升序</span><br><span class="line">select * from tableName order by rowName desc;</span><br><span class="line"># 降序</span><br><span class="line">select * from tableName order by rowName asc;</span><br><span class="line"># 多重排序,先按照rowOne的值进行升序排列，如果有相同的值再按照rowTwo降序排列</span><br><span class="line">select * from tableName order by rowOne deac,rowTwo asc;</span><br></pre></td></tr></table></figure></li>
<li>聚合函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 计数</span><br><span class="line">select count(*) from tableName where factor;</span><br><span class="line"></span><br><span class="line"># 求和</span><br><span class="line">select sum(rowName) from tableName where factor;</span><br><span class="line"></span><br><span class="line"># 平均数</span><br><span class="line">select avg(rowName) from tableName where factor;</span><br><span class="line"></span><br><span class="line"># 最大最小值</span><br><span class="line">select max(rowName),min(rowName) from tableName;</span><br></pre></td></tr></table></figure></li>
<li>分组查询<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select row1,sum(row2) from tableName group by row1;</span><br><span class="line"># 二次过滤</span><br><span class="line">select row1,sum(row2) from tableName group by row1 having sum(row2) &gt; 10;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul>
<li>内连接<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tableA,tableB;</span><br><span class="line">select * from tableA inner join tableB</span><br></pre></td></tr></table></figure></li>
<li>外连接<ul>
<li>左连接</li>
<li>右连接</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>数据持久化 -- 数据库优化</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<ul>
<li>明确要查找的字段，别用select *尽量用上覆盖索引</li>
<li>遇到比较长的字符串时，考虑使用前缀索引或者hash索引</li>
<li>尽量定义自增长的主键，如果用一个唯一的业务数据来当主键的时候，如果不是int类型，普通索引的叶子节点存储它的时候会占用更多的空间</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>数据持久化 -- 数据库性能分析命令</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="一、查看数据库表占用空间大小"><a href="#一、查看数据库表占用空间大小" class="headerlink" title="一、查看数据库表占用空间大小"></a>一、查看数据库表占用空间大小</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select TABLE_NAME,concat(truncate((DATA_LENGTH+INDEX_LENGTH)/1024/1024,2),&#x27;M&#x27;),TABLE_ROWS FROM information_schema.TABLES where TABLE_SCHEMA=&#x27;ins_rank&#x27;</span><br></pre></td></tr></table></figure>
<p>上面的语句会依次输出ins_rank数据库中表对空间占用的情况，单位是M，来一一解释关键字和函数的意义</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li><p>concat函数–联合字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--这个函数的作用就是将两个字段拼接到一个字段中做显示--&gt;</span><br><span class="line">select concat(10,&#x27;M&#x27;) as lenge</span><br></pre></td></tr></table></figure></li>
<li><p>round()–四舍五入，虽然这里没有用到，还是可以留个印象，MySQL里面有这么个函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">select <span class="built_in">round</span>(column_name,decimals) <span class="keyword">from</span> table_name</span><br><span class="line"><span class="comment"># 这里decimals表示精确度，返回小数点后几位</span></span><br></pre></td></tr></table></figure></li>
<li><p>truncate()–截取字段函数，案例中使用了truncate就没有使用round</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">truncate(X,D)</span><br><span class="line"># 这里的X是要做处理的数据</span><br><span class="line"># 这里的D表示对数据处理的方式</span><br><span class="line"># 案例一：D小于0</span><br><span class="line">select truncate(123.456,-2)</span><br><span class="line">结果：100</span><br><span class="line"># 案例二：D等于0</span><br><span class="line">select truncate(123.456,0)</span><br><span class="line">结果：123</span><br><span class="line"># 案例二：D大于0</span><br><span class="line">select truncate(123.456,2)</span><br><span class="line">结果：123.45</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p>在介绍关键字之前说另一个东西，关于数据库表的一些信息像是空间占用、记录行数、更新时间、字段等都在informatioin_schema数据库中的TABLES表里面有记录，所以上面的语句是从这个地方去做的一个查询</p>
<ul>
<li>TABLE_SCHEMA : 数据库名</li>
<li>TABLE_NAME：表名</li>
<li>ENGINE：所使用的存储引擎</li>
<li>TABLES_ROWS：记录数，即表的行数</li>
<li>DATA_LENGTH：数据大小</li>
<li>INDEX_LENGTH：索引大小</li>
<li>CREATE_TIME：创建时间</li>
<li>UPDATE_TIME：最近更新时间</li>
<li></li>
</ul>
<h3 id="二、查看SQL语句执行详情"><a href="#二、查看SQL语句执行详情" class="headerlink" title="二、查看SQL语句执行详情"></a>二、查看SQL语句执行详情</h3><h4 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPLAIN select * from ins_kol where id = 100000</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="/img/14552.png" alt="执行结果"></p>
<ul>
<li>id是该sql在执行序列中的编号，这里只有一句所以就没什么意义了，id值越大，优先级越高</li>
<li>select_type：查询类型<ul>
<li>SIMPLE：简单的 select 查询,不使用 union 及子查询</li>
<li>PRIMARY：最外层的 select 查询</li>
<li>UNION：UNION 中的第二个或随后的 select 查询,不 依赖于外部查询的结果集</li>
<li>DEPENDENT UNION：UNION 中的第二个或随后的 select 查询,依 赖于外部查询的结果集</li>
<li>SUBQUERY：子查询中的第一个 select 查询,不依赖于外 部查询的结果集</li>
<li>DEPENDENT SUBQUERY：子查询中的第一个 select 查询,依赖于外部 查询的结果集</li>
<li>DERIVED：用于 from 子句里有子查询的情况。 MySQL 会 递归执行这些子查询, 把结果放在临时表里。</li>
<li>UNCACHEABLE SUBQUERY：结果集不能被缓存的子查询,必须重新为外 层查询的每一行进行评估。</li>
<li>UNCACHEABLE UNION：UNION 中的第二个或随后的 select 查询,属 于不可缓存的子查询 </li>
</ul>
</li>
<li>table：查询指向的表</li>
<li>partitions：这个应该是由于这里的表做了分区才有了这个参数，表示数据最后是落在哪个分区中的</li>
<li>type：表的连接类型<ul>
<li>system：表中只有一行，即常量</li>
<li>const：单表中最多有一个匹配行，如primary key或unique index</li>
<li>eq_ref： 对于前面的每一行，在此表中只查询一条记录，也就是多表连接中使用primary key或unique index</li>
<li>ref： 与eq_ref类似，区别在于不是使用primary key或unique index，而是使用普通索引</li>
<li>ref_or_null： 与ref类型，区别在于条件中包含对null的查询</li>
<li>index_merge： 索引合并优化</li>
<li>unique_subquery： in的后面是一个查询主键字段的子查询</li>
<li>index_subquery： 与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询  </li>
<li>range： 单表中的范围查询</li>
<li>index： 对于前面的每一行，都通过查询索引来得到数据</li>
<li>all： 对于前面的每一行，都通过扫描全表来得到数据</li>
<li>(一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题)</li>
<li>possible_keys： 查询时可能用到的索引</li>
<li>key： 查询时实际使用到的索引，如果没有选择索引，键是NULL</li>
<li>key-len： 索引字段的长度 如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li>rows： 扫描行的数量</li>
<li>Extra： 执行情况的说明和描述 也是关键参考项之一，但是这里没有遇到再补充</li>
</ul>
</li>
</ul>
<h4 id="show-profiles查看执行时间"><a href="#show-profiles查看执行时间" class="headerlink" title="show profiles查看执行时间"></a>show profiles查看执行时间</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--查看数据库版本，大概要5.0之后的版本才支持这个功能--&gt;</span><br><span class="line">show variables like &quot;%version%&quot;</span><br><span class="line">&lt;!--功能默认是关闭的，查看状态--&gt;</span><br><span class="line">show variables like &quot;%pro%&quot;</span><br><span class="line">&lt;!--激活这个功能，重启之后会失效，所以最好每次都检查一下状态--&gt;</span><br><span class="line">set profiling = 1</span><br><span class="line">&lt;!--查询语句--&gt;</span><br><span class="line">select * from ins_insight_user where id = 1000</span><br><span class="line">select * from ins_kol where id = 100000</span><br><span class="line">&lt;!--查看刚才执行的SQL用时信息--&gt;</span><br><span class="line">show profiles</span><br><span class="line">&lt;!--查看第一条语句各个操作的用时情况--&gt;</span><br><span class="line">show profile for query 1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据持久化</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>数据持久化 -- 索引、分表</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MySQL/%E7%B4%A2%E5%BC%95%E3%80%81%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li>mysql主键是默认会创建索引的，外键不清楚，现在用得不多了</li>
<li>数据量超过300的表应该有索引</li>
<li>经常与其他表进行连接的表，在连接字段上应该建立索引</li>
<li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引</li>
<li>索引应该建在选择性高的字段上，即重复度低（能过滤80%以上的数据时就适合创建索引）</li>
<li>索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引</li>
<li>复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替</li>
<li>频繁进行数据操作的表，不要建立太多的索引</li>
<li>删除无用的索引，避免对执行计划造成负面影响</li>
<li>查看索引方法 </li>
<li>失效场景<ul>
<li>负向条件查询（如何实现not in）</li>
<li>前导模糊查询</li>
<li>函数</li>
</ul>
</li>
</ul>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><ul>
<li>分区索引建立</li>
<li>分区条件</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL -- 问题记录1</title>
    <url>/2023/04/22/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/MySQL/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<p><img src="/img/image-20230425170540653.png" alt="image-20230425170540653"></p>
<h2 id="一、普通索引和唯一索引的选择"><a href="#一、普通索引和唯一索引的选择" class="headerlink" title="一、普通索引和唯一索引的选择"></a>一、普通索引和唯一索引的选择</h2><p>这里讨论当一个字段比如身份证号码，我们已经确定他是唯一了，该给他创建唯一索引还是普通索引</p>
<ul>
<li>查询<ul>
<li>唯一索引的查询只要查到第一个符合条件的数据后就会返回</li>
<li>普通索引查询到符合条件的数据后还会往后查询直到找到第一条不符合条件的数据后才返回，其实就是要把所有符合条件的数据都找到，当数据已经是唯一的时候就相当于指针会往后多查找一次消耗基本可忽略</li>
<li>结论：对于查询来说两者差距可以忽略不计</li>
<li>疑问：==对于已知是唯一的数据手动做limit 1是不是能解决查询上的差异==</li>
</ul>
</li>
<li>插入<ul>
<li>唯一索引由于要去做数据唯一性校验所以不能用上change buffer机制</li>
<li>普通索引可以直接用change buffer，且不用做唯一性校验</li>
<li>结论：change buffer的内容不在这里详细讲，插入时普通索引是要优于唯一索引的</li>
</ul>
</li>
<li>案例<ul>
<li>将普通索引改成唯一索引后大量的插入操作导致数据库的内存命中率降低</li>
</ul>
</li>
<li>结论：尽量使用普通索引，将唯一性校验放到业务代码里面去做，不要把压力转移到数据库 </li>
</ul>
<h2 id="二、为什么优化器会选错索引"><a href="#二、为什么优化器会选错索引" class="headerlink" title="二、为什么优化器会选错索引"></a>二、为什么优化器会选错索引</h2><p>有时候我们创建了索引，但优化器最终没有去使用</p>
<ul>
<li>优化器的工作原理（粗略）<ul>
<li>判断本次操作需要扫描多少行数据，这个是主要的依据<ul>
<li>对于索引来说判断需要依赖一个叫cardinality（基数）的参数，这个参数就是指这个索引中有多少个不同的值，基数越大索引性能越好</li>
<li>可以查看表中每个索引的基数情况  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from aliexpress_product_info</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>考虑索引需要回表操作</li>
<li>考虑排序因素</li>
</ul>
</li>
<li>场景<ul>
<li>频繁修改数据的场景中，需要频繁的进行基数的预估统计，可能导致不准确</li>
<li>当使用的索引在通过基数预估来计算出要扫描的行和直接在主键索引上进行扫描的差距不大时，为了节约反表的成本，优化器直接到主键上全表扫描（这里问题出在基数估算错误），可以让数据库重新对索引基数进行估算  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--执行前该表主键的基数是980W，估算后为664w，差距还是很大的--&gt;</span><br><span class="line">analyze table aliexpress_product_info</span><br></pre></td></tr></table></figure></li>
<li>如果有两个索引a、b，语句中同时使用到两个字段做过滤，索引a需要扫描1k行而索引b需要1w，但是最终要用b字段做排序的话，优化器还是会使用b，对一些差距特别大的情况我们可以强制指定使用索引  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t force index(a) where ...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>结论<ul>
<li>学会分析索引的基数来判断索引的性能</li>
<li>手动更新索引基数</li>
<li>强制指定使用索引，它有一个坏处如果后续索引修改了名称那么需要改SQL，所以一般不会在业务上用</li>
</ul>
</li>
</ul>
<h2 id="三、如何优化字符串类型数据的索引"><a href="#三、如何优化字符串类型数据的索引" class="headerlink" title="三、如何优化字符串类型数据的索引"></a>三、如何优化字符串类型数据的索引</h2><ul>
<li>直接给字符串创建索引，这样的话会增加存储空间的占用</li>
<li>使用前缀索引，可以节省空间，但是从索引上取到的数据不一定符合条件需要回到主键索引上进行核对，增加了扫描次数<ul>
<li>这个地方给出的案例是邮箱，只存储前几个字符，但实际上感觉实用性一般，为了节省大概一半的字段索引空间查询的时候性能会有降低，整体收益不是很高，但对于一些比较长的字符串来说如果能通过头部的一些字符就能有比较好的区分度的话，这个时候对空间占用的优化就比较明显了</li>
<li>另一个案例给出了身份证号码，进行倒置存储，因为后面的6位是标识性的编号，对倒置后的前6个字符设置前缀索引，这个时候查询需要用到reverse函数</li>
<li>将不能使用覆盖索引，覆盖索引就是指比如业务查询只需要主键ID和索引字段信息时，全量的索引其实就不需要做回标操作了，但前缀索引必须要回去做整个字段数据的核对</li>
<li>判断前缀数据重复度<code>select count(distinct left(product_url_md5,16)) as L from shopify_product</code></li>
</ul>
</li>
<li>使用hash字段，将一个长的字符串进行crc32()计算后会得到一个int类型的数值，为这个数值创建一个字段，然后给这个字段添加索引，这样来达到减少索引空间占用的目的<ul>
<li>注意这个crc32函数计算出来的结果可能会有重复（实际几率很小），所以业务侧在进行查询的时候还是要对原字段进行匹配，相当于是使用hash进行进行索引定位，然后判断数据是否匹配</li>
</ul>
</li>
</ul>
<h2 id="四、自增主键为什么出现不连续的现象"><a href="#四、自增主键为什么出现不连续的现象" class="headerlink" title="四、自增主键为什么出现不连续的现象"></a>四、自增主键为什么出现不连续的现象</h2><ul>
<li>表中有字段被设置了唯一性，数据插入的时候会先为数据分配自增主键（如果没有显式指定的话），这个时候自增主键的计数器已经进行了累加，再之后进行数据插入的时候如果检测到唯一字段冲突会报错，但是自增主键的计数器已经被累加了，后续的插入会在这个数字基础上继续累加，于是就出现了数据的空洞</li>
<li>事务回滚也会导致不连续，原理和上面一条差不多</li>
</ul>
<h2 id="五、order-by的实现"><a href="#五、order-by的实现" class="headerlink" title="五、order by的实现"></a>五、order by的实现</h2><p>MySQL会为每个线程分配一片内存空间来对数据进行排序，叫做sort_buffer，MySQL有两种排序的方式，全字段排序和rowid 排序</p>
<ul>
<li>第一种，将查询结果中需要的数据都拿出来，然后对order by的字段进行排序，排序方式是快速排序，这种方式叫做全字段排序</li>
<li>第二种，如果查询的字段很多，全都放到内存里面的话，对内存的占用会很大，所以可以只将需要排序的字段和id加载到内存中，排序完成后再通过ID取到需要的别的字段数据，这种方式叫做rowid 排序</li>
</ul>
<p>MySQL排序的时候可能是在内存中进行，也可能写入磁盘进行，主要看分配的内存空间是否能够放下需要排序的数据，核心的思想仍然是能在内存中处理就在内存中进行处理</p>
<p>如果一个字段本身就已经完成了排序，那么这个时候就不再需要虚拟表来进行排序，直接就能取到需要的数据</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门简介</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Redis/Redis%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="1-特性"><a href="#1-特性" class="headerlink" title="1.特性"></a>1.特性</h1><ul>
<li>速度快，基于内存，能达到10w QPS（每秒查询速度）</li>
<li>基于键值对，它的value中支持5种数据结构</li>
<li>单线程模式，天生线程安全</li>
<li>支持持久化</li>
<li>主从复制、高可用、分布式、水平扩容</li>
</ul>
<h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h1><ul>
<li>缓存：提供键值过期时间，提供最大内存控制和内存溢出后的淘汰策略</li>
<li>排行榜：通过列表和有序集合很方便构建各种排行榜系统</li>
<li>计数器：设置超时时间来实现限流？</li>
<li>消息队列：这个还是比不上专业的消息队列的</li>
</ul>
<h1 id="3-安装配置"><a href="#3-安装配置" class="headerlink" title="3.安装配置"></a>3.安装配置</h1><ul>
<li><p>单机的安装就是下载安装没有什么好说的，使用Docker安装最为方便</p>
</li>
<li><p>主从配置这里不详细记录，参考：<a href="https://juejin.im/post/5b76e732f265da4376203849">文章</a></p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><ul>
<li>到<a href="https://redis.io/download">官网</a>下载压缩包</li>
<li>将压缩包解压到/usr/local目录下：/usr/local/redis-5.0.5<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="built_in">cd</span> redis-5.0.5</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动，启动之前修改一下整个Reddit文件夹的权限，不然用起来不方便</span></span><br><span class="line">sudo <span class="built_in">chmod</span> 777 redis-5.0.5</span><br><span class="line">redis-server redis.conf</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">docker run -itd --name redis -p 7936:6379 redis --requirepass cds-cloud@2022</span><br><span class="line"><span class="comment"># 查看容器30分钟内日志</span></span><br><span class="line">docker logs --since 30m redis</span><br><span class="line"><span class="comment"># 进入交互命令行</span></span><br><span class="line">docker <span class="built_in">exec</span> -it redis redis-cli</span><br><span class="line"><span class="comment"># 注意设置了密码，所以使用的时候需要先进行身份认证</span></span><br><span class="line">auth cds-cloud@2022</span><br></pre></td></tr></table></figure>




<h2 id="Python调用"><a href="#Python调用" class="headerlink" title="Python调用"></a>Python调用</h2><h3 id="安装与测试"><a href="#安装与测试" class="headerlink" title="安装与测试"></a>安装与测试</h3><ul>
<li>安装对应库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install redis</span><br></pre></td></tr></table></figure></li>
<li>调用测试<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis </span><br><span class="line"><span class="comment"># host是redis主机，需要redis服务端和客户端都启动 redis默认端口是6379</span></span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, decode_responses=<span class="literal">True</span>)   </span><br><span class="line">r.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;luoyang&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(r.get(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r.get(<span class="string">&#x27;name&#x27;</span>)))</span><br></pre></td></tr></table></figure></li>
<li>开启redis服务，如果有修改配置文件中redis运行的端口就调整成对应的端口即可</li>
<li>运行上面的脚本应该就能输出存储的内容了</li>
</ul>
<h3 id="基础方法"><a href="#基础方法" class="headerlink" title="基础方法"></a>基础方法</h3><ul>
<li>存储数据<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储数字</span></span><br><span class="line">red.<span class="built_in">set</span>(<span class="string">&#x27;age&#x27;</span>,<span class="number">23</span>)</span><br><span class="line"><span class="comment"># 存储字符串</span></span><br><span class="line">red.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;luoyang&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置过期时间，单位s</span></span><br><span class="line">red.<span class="built_in">set</span>(<span class="string">&#x27;temp&#x27;</span>,<span class="string">&#x27;test_data&#x27;</span>,ex=<span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>获取数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取对应的value</span><br><span class="line">red.get(&#x27;age&#x27;)</span><br><span class="line"># 模糊匹配所有key</span><br><span class="line">red.keys(&#x27;na*&#x27;)</span><br><span class="line"># 查看过期时间,返回值有三种，-2已过期，-1没有设置过期时间，正数剩余过期时间</span><br><span class="line">red.ttl(&#x27;temp&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis内存模型</title>
    <url>/2023/05/04/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Redis/Redis%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="/img/redis1111.png" alt="redis1111"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>内容测试基于Redis版本：7.0.10</li>
<li>参考博客：<a href="https://www.cnblogs.com/kismetv/p/8654978.html">深入学习Redis（1）：Redis内存模型</a></li>
</ul>
<h1 id="一、内存统计和分类"><a href="#一、内存统计和分类" class="headerlink" title="一、内存统计和分类"></a>一、内存统计和分类</h1><h2 id="1-1-1-内存统计命令"><a href="#1-1-1-内存统计命令" class="headerlink" title="1.1.1 内存统计命令"></a>1.1.1 内存统计命令</h2><p>注意info这个命令可以输出Redis服务相关的所有信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info memory</span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:1108392</span><br><span class="line">used_memory_human:1.06M</span><br><span class="line">used_memory_rss:4489216</span><br><span class="line">used_memory_rss_human:4.28M</span><br><span class="line">...</span><br><span class="line">mem_fragmentation_ratio:4.13</span><br><span class="line">mem_allocator:jemalloc-5.2.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>used_memory和used_memory_human是同一个数据表示Redis分配器的内存总量（包括虚拟内存），human只是便于人查看</li>
<li>used_memory_rss表示Redis服务从系统申请占用的真实内存（不包括虚拟内存），包括了服务自身的内存开销，而used_memory相当于业务占用内存</li>
<li>mem_fragmentation_ratio：内存碎片比率，该值是used_memory_rss / used_memory的比值，需要注意的是如果该数值小于1，说明使用了虚拟内存，服务会明显降速，需要进行排查</li>
<li>mem_allocator：Redis使用的内存分配器</li>
</ul>
<h2 id="1-1-2-内存分类"><a href="#1-1-2-内存分类" class="headerlink" title="1.1.2 内存分类"></a>1.1.2 内存分类</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>一般就是业务数据，五种类型：字符串、哈希、列表、集合、有序集合</p>
<h3 id="进程运行内存"><a href="#进程运行内存" class="headerlink" title="进程运行内存"></a>进程运行内存</h3><p>Redis主进程运行需要的内存（代码、常量池等），大概只有几兆，另外一些子进程（比如持久化的AOF、RDB进程）运行会占用内存，这些内存都不会被统计出来</p>
<h3 id="缓冲内存"><a href="#缓冲内存" class="headerlink" title="缓冲内存"></a>缓冲内存</h3><p>缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等（所以上面提到的进程内存指的是进程运行需要的内存数据小不统计影响也不大），会被纳入统计</p>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>这个之前遇到过故障，当大批量的从Redis中删除数据时，Redis是不会将对应的内存还给操作系统的，也就是说内存没被释放（可以显式的执行命令释放，但是效果并不理想），这些碎片导致机器内存资源吃紧，所以需要预先根据分配器策略去设计业务的存储方案，因为走到这一步就很难处理了</p>
<p>例如，机器只有8G内存，业务数据4G，理论上是完全够用的，但是业务数据不断更新迭代，Redis使用的内存越来越大，达到了7G（有效数据仍为4G，3G内存碎片），这个时候已经会影响服务性能，但此时通过命令让分配器释放内存，不能达到预期效果，只会释放一小部分碎片或耗时太长，彻底的解决方案为重启Redis服务，风险很大，一是业务上是否允许，二是持久化策略配置是否合理，当时对Redis进行了持久化的配置，但是不知道没生效还是空闲内存太少导致失败，最终检查持久化文件只有几十兆的情况下进行服务重启，导致数据丢失，所幸数据还不是太重要，经过一周的爬虫补充回来了</p>
<h1 id="二、存储细节"><a href="#二、存储细节" class="headerlink" title="二、存储细节"></a>二、存储细节</h1><p><img src="/img/iShot2023-05-04%2018.32.15.png" alt="iShot2023-05-04 18.32.15"></p>
<ul>
<li>dictEntry：每个键值对都会有一个dictEntry</li>
<li>SDS：简单动态字符串，最终所有的key、value数据都是存储在SDS中</li>
<li>redisObject：redis中5种类型的value都会使用redisObject进行包装存储，所以这里面会标记数据类型</li>
</ul>
<h2 id="2-1-jemalloc"><a href="#2-1-jemalloc" class="headerlink" title="2.1 jemalloc"></a>2.1 jemalloc</h2><p>Redis默认的内存分配器，另外两种暂不进行了解，这个分配器在减小内存碎片方面做得比较好，注意jemalloc是给数据预分配内存空间，而不是多少数据占多少空间，比如130字节对象会放到160字节内存单元中，内存单元划分如下：</p>
<p><img src="/img/1174710.png" alt="1174710"></p>
<h2 id="2-2-redisObject"><a href="#2-2-redisObject" class="headerlink" title="2.2 redisObject"></a>2.2 redisObject</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<h2 id="dictEntry"><a href="#dictEntry" class="headerlink" title="dictEntry"></a>dictEntry</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>     <span class="comment">/* Next entry in the same hash bucket. */</span></span><br><span class="line">    <span class="type">void</span> *metadata[];           <span class="comment">/* An arbitrary number of bytes (starting at a</span></span><br><span class="line"><span class="comment">                                 * pointer-aligned address) of size as returned</span></span><br><span class="line"><span class="comment">                                 * by dictType&#x27;s dictEntryMetadataBytes(). */</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>添加free和len而不直接使用c字符串的作用</p>
<ul>
<li>获取字符串长度：O(1)，字符串为O(n)</li>
<li>缓冲区溢出：之前提到jemalloc分配内存是按长度划分内存单元，数据内容变更时，对长度进行判断溢出时自动重新分配，当然没有len也能去获取一次长度做判断，只是效率更低</li>
<li>优化内存分配：c中字符串修改必然重新分配内存，这里相当于做了封装，预先给的空间会大一些，这样可以避免一部分情况下的内存分配，提高效率</li>
<li>存取二进制数据：由于c字符串以空字符作为字符串结束标识，对于一些二进制文件可能出现误读，sds有精确的len标记解决此问题</li>
</ul>
<h1 id="三、内存估算"><a href="#三、内存估算" class="headerlink" title="三、内存估算"></a>三、内存估算</h1><p>这里先不对5种数据类型内部的编码优化进行探索，只要结合上面的存储结构图和分配器内存单元图，对数据存储进行预估得到的结果也足够精准了</p>
<p>demo：90000个键值对，每个key的长度是7个字节，每个value的长度也是7个字节（都是字符串）</p>
<h2 id="3-1-模糊预估"><a href="#3-1-模糊预估" class="headerlink" title="3.1 模糊预估"></a>3.1 模糊预估</h2><ul>
<li>key<ul>
<li>dictEntry：24Byte</li>
<li>sds：9Byte+7Byte</li>
</ul>
</li>
<li>value<ul>
<li>redisObject：16Byte+7Byte</li>
<li>sds：9Byte+7Byte</li>
</ul>
</li>
<li>bucket数组：90000*8Byte</li>
<li>总数：(24+9+7+16+7+9+7+8)*90000=7830000=7.46M</li>
</ul>
<h2 id="3-2-精准预估"><a href="#3-2-精准预估" class="headerlink" title="3.2 精准预估"></a>3.2 精准预估</h2><ul>
<li>一个dictEntry，24字节，jemalloc会分配32字节的内存块</li>
<li>一个key，7字节，所以SDS(key)需要7+9=16个字节，jemalloc会分配16字节的内存块</li>
<li>一个redisObject，16字节，jemalloc会分配16字节的内存块</li>
<li>一个value，7字节，所以SDS(value)需要7+9=16个字节，jemalloc会分配16字节的内存块</li>
<li>综上，一个dictEntry需要32+16+16+16=80个字节</li>
<li>bucket数组的大小为大于90000的最小的2^n，是131072；每个bucket元素为8字节（因为64位系统中指针大小为8字节</li>
<li>估算出这90000个键值对占据的内存大小为：90000<em>80 + 131072</em>8 = 8248576=7.86M</li>
</ul>
<h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p>通过脚本批量创建Redis数据，运行结果：8247552z</p>
<h2 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h2><p>精准预估确实厉害（博主还介绍了一下误差是由于bucket预分配），但模糊预估也能估算个大概规模了</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis实现原理</title>
    <url>/2023/05/10/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Redis/Redis%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="/img/redis1111.png" alt="redis1111"></p>
<h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><p>把SDS单独提一下，所有的用户数据在Redis中都是使用SDS进行存储的，之前内存模型中有详细说明过</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>string是Redis中最简单的键值对存储方式，使用字典进行实现，基于Hash表，当往Redis中添加一个键值对的时候，通过key计算出的hash值被映射到一个Hash表上（Hash居然是一个单向链表），由于是Hash值做的映射，会发生冲突，冲突的时候通过链表把数据（key）依次进行存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;		<span class="comment">// 记录类型，用于创建多类型的字典，不清楚具体作用</span></span><br><span class="line"></span><br><span class="line">    dictEntry **ht_table[<span class="number">2</span>];	<span class="comment">// Hash表，这里有两个Hash表，正常只使用第一个，当第一个需要重做Hash时临时使用第二个</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ht_used[<span class="number">2</span>];		<span class="comment">// 之前版本有个独立的dictht结构体用来存储Hash表的统计信息，估计现在存在这个地方了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 用于保存rehash进度*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Keep small vars at end for optimal (minimal) struct padding */</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash; <span class="comment">/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> ht_size_exp[<span class="number">2</span>]; <span class="comment">/* exponent of size. (size = 1&lt;&lt;exp) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>     <span class="comment">/* Next entry in the same hash bucket. */</span></span><br><span class="line">    <span class="type">void</span> *metadata[];           <span class="comment">/* An arbitrary number of bytes (starting at a</span></span><br><span class="line"><span class="comment">                                 * pointer-aligned address) of size as returned</span></span><br><span class="line"><span class="comment">                                 * by dictType&#x27;s dictEntryMetadataBytes(). */</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*keyDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> *(*valDup)(dict *d, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*keyCompare)(dict *d, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(dict *d, <span class="type">void</span> *key);</span><br><span class="line">    <span class="type">void</span> (*valDestructor)(dict *d, <span class="type">void</span> *obj);</span><br><span class="line">    <span class="type">int</span> (*expandAllowed)(<span class="type">size_t</span> moreMem, <span class="type">double</span> usedRatio);</span><br><span class="line">    <span class="comment">/* Allow a dictEntry to carry extra caller-defined metadata.  The</span></span><br><span class="line"><span class="comment">     * extra memory is initialized to 0 when a dictEntry is allocated. */</span></span><br><span class="line">    <span class="type">size_t</span> (*dictEntryMetadataBytes)(dict *d);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p>比对从网上找到的Redis 3.x版本源码，结构做了调整，下图为3.x版本结构图：</p>
<p><img src="/img/2023-05-10dict.png" alt="3.x版本结构图"></p>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>列表的底层实现是链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>c中没有链表的实现，Redis自己实现了一个双向链表，这里的value应该是对应SDS的内存指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;		<span class="comment">// 头指针</span></span><br><span class="line">    listNode *tail;		<span class="comment">// 尾指针</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);	<span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);	<span class="comment">// 节点释放函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);	<span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;	<span class="comment">// 长度计数器</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/img/2023-05-10list.png" alt="2023-05-10list"></p>
<h1 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h1><p>zset在数据少的时候使用的压缩表，在数据多的时候使用跳跃表（SkipList）</p>
<h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>



<p><img src="/img/2023-05-12skiplist.png" alt="2023-05-12skiplist"></p>
<ul>
<li>上面是查找元素的过程，类似于二叉查找树，时间复杂度为logn，但是相对二叉查找树它维持平衡的成本更低，是以空间换时间的思路</li>
<li>数据删除，即是把元素在各个层的指针都断开，链接相邻节点指针</li>
<li>添加元素，先把元素添加到最底层的有序链表中，再通过完全随机的抛硬币（50%）几率决定是否要将元素上浮，直到停下</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis应用场景</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Redis/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h2><ul>
<li>所有的命令过来之后，Redis会放入一个任务队列中，挨个执行，所以Redis天生线程安全（NIO实现单线程速度优化）</li>
<li>访问速度快，Redis单服务器的并发大概是几万（普通服务器）</li>
</ul>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul>
<li>单值缓存<ul>
<li>商品库存 商品ID做为key，库存数量作为value</li>
</ul>
</li>
<li>对象缓存<ul>
<li>仍然使用set的方式，将对象的主键提出来作为key，将对象转换为json格式作为value</li>
<li>mset  批量进行存储操作，将对象的主键和对象的某一个属性比如user：1：name作为key，将对象改属性的值作为value<ul>
<li>缺点：set的操作会复杂一点，从直觉上没有json的方式异动</li>
<li>有点：取用和修改的时候更灵活</li>
</ul>
</li>
</ul>
</li>
<li>分布式锁<ul>
<li>场景：有两个服务器中运行着减库存的方法，该方法的结构<ul>
<li>查询库存</li>
<li>减库存</li>
<li>把减完的数据存储回数据库</li>
</ul>
</li>
<li>实现：使用setnx命令<ul>
<li>setnx命令相对于set命令会多一个判断逻辑，判断要设置的key在Redis中目前是否存在，如果不存在则将key和value进行正常的保存操作并返回1，如果已经存在不会对value进行更新并返回0</li>
<li>根据setnx的特性，在上面的流程中，在查询库存之前往Redis里面写入  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--将商品的ID拼接到key中--&gt;</span><br><span class="line">setnx pro-1 true</span><br></pre></td></tr></table></figure></li>
<li>在数据成功存储到数据库之后，将商品对应的key进行删除  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del pro-1</span><br></pre></td></tr></table></figure></li>
<li>这样多个线程想要在某个线程在对商品库存进行修改的过程中再去对商品库存信息进行读取修改的时候，Redis会返回0，实现分布式锁，当然没拿到锁的线程就自己去指定策略</li>
</ul>
</li>
</ul>
</li>
<li>原子加减<ul>
<li>场景：点赞计数</li>
<li>问题：如果使用数据库要考虑并发的处理</li>
<li>命令：incr会固定的将key对应的值+1  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--初始化数据为100，这一步可以不做--&gt;</span><br><span class="line">set user-1-like 100</span><br><span class="line">&lt;!--进行数据累加，如果key原本不存在，会默认初始化为1，该命令会返回累加之后的value--&gt;</span><br><span class="line">incr user-1-like</span><br></pre></td></tr></table></figure></li>
<li>这个数据需要同步到数据库吗，是什么样的机制？</li>
</ul>
</li>
<li>web集群的session共享</li>
<li>分布式系统全局序列号<ul>
<li>大型系统中对MySQL进行分库分表，这个时候用mysql默认的自增主键的时候可能会出现重复的ID</li>
<li>使用Redis来生成ID，如果使用incr来取单个的ID的话每秒能生成的ID数量会受到Redis处理性能的限制</li>
<li>使用incrby命令，这个命令可以设置数据递增量  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">incrby userId 1000</span><br></pre></td></tr></table></figure></li>
<li>通过incrby一次获取1000个可用的ID放到内存中慢慢使用即可</li>
</ul>
</li>
</ul>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>性能比string高，空间占用比string小，缺点是如果使用了集群架构，hash的方式存储的数据会集中在一个节点上不能做分片操作</p>
<ul>
<li>购物车 不用将这部分信息放到数据库，直接由Redis来维护<ul>
<li>场景：典型的购物车模块，涉及到用户、商品、商品数量三个数据，以及将商品添加到购物车、将商品从购物车移除、购物车商品数量增加、购物车商品数量减少以及查看购物车信息五个业务操作</li>
<li>原理：使用redis的hash存储，redis本身是通过key-value的方式进行存储，hash就是value内容又是一个key-value，即是一个嵌套的map,结构：key1-[key2-value]</li>
<li>方案：将shopping-cart-user:username作为key1, 将pro-id:proId作为key2，将商品数量作为value</li>
<li>命令：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--添加购物车--&gt;</span><br><span class="line">hset shopping-cart-user:luoyang pro-id:1001 1</span><br><span class="line">hset shopping-cart-user:luoyang pro-id:1002 4</span><br><span class="line">hset shopping-cart-user:luoyang pro-id:1003 1</span><br><span class="line">hset shopping-cart-user:luoyang pro-id:1004 2</span><br><span class="line">&lt;!--批量操作--&gt;</span><br><span class="line">hmset shopping-cart-user:luoyang pro-id:1001 1 pro-id:1002 4 pro-id:1003 1 pro-id:1004 2</span><br><span class="line">&lt;!--查看购物车信息--&gt;</span><br><span class="line">hgetall shopping-cart-user:luoyang</span><br><span class="line">&lt;!--将商品从购物车移除--&gt;</span><br><span class="line">hdel shopping-cart-user:luoyang pro-id:1004 2</span><br><span class="line">&lt;!--购物车商品数量增加--&gt;</span><br><span class="line">hincrby shopping-cart-user:luoyang pro-id:1003 1</span><br><span class="line">&lt;!--购物车商品数量减少--&gt;</span><br><span class="line">hincrby shopping-cart-user:luoyang pro-id:1003 -1</span><br></pre></td></tr></table></figure></li>
<li>和数据库实现对比：<ul>
<li>数据库实现需要建表、如果有涉及到表字段的增减需要对ORM映射流程的源代码进行修改、数据库中收藏表和订单详情表结构存在很大程度的内容重复冗余；效率上：高并发的场景对数据库不友好；</li>
<li>Redis实现只需要针对购物车流程中的核心数据进行存储，没有数据库表创建、没有dbschema备份执行、不用考虑字段类型优化、不用考虑索引创建、没有ORM映射文件生成，没有没有都没有，操作简单灵活（当然这一切都建立在数据库已经做了完善的基础信息维护之上，可以认为是一个更轻量级的场景解决方案，数据库只要存储一些像订单结果之类的改动频率低的数据即可）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul>
<li><p>公众号消息推送</p>
<ul>
<li>场景是微信公众号的消息推送，假定一个用户关注了10个公众号，公众号会不定时的发送消息，在用户打开公众号消息列表的时候，需要将公众号消息按发布时间进行展示</li>
<li>原理：使用redis的list存储，list是一个可以选择从左侧或者从右侧插入和获取数据的存储结构</li>
<li>方案：将msg:username作为key，将消息ID作为value</li>
<li>命令：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--公众号发布消息的时候，将消息推送到粉丝的消息列表（从左侧插入数据）--&gt;</span><br><span class="line">lpush msg:luoyang 1001</span><br><span class="line">lpush msg:luoyang 1002</span><br><span class="line">lpush msg:luoyang 1003</span><br><span class="line">lpush msg:luoyang 1004</span><br><span class="line">&lt;!--用户打开界面查看消息时，取最新的三条消息进行展示（从左侧获取数据）--&gt;</span><br><span class="line">lrange msg:luoyang 0 3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>聊天功能实现</p>
<ul>
<li>用hash存储某个用户拥有的消息队列以及其是否被激活:key1-[key2-value]<ul>
<li>用户只有一个消息队列：msg-list:username&amp;customerServiceName,还需要以string的方式记录用户消息队列的名称：(当用户打开客服咨询框的时候每秒钟从消息队列中刷新数据到页面)<ul>
<li>key：chat-string-for:username </li>
<li>value:msg-list:username&amp;customerServiceName</li>
</ul>
</li>
<li>客服需要维护两个set集合分别表示有新信息队列和没有信息的消息队列:(打开消息查看界面之后加载chat-set-new中所有消息队列数据，查看过的消息队列放到chat-set-old中去，并每秒钟都查看chat-set-new中所有消息队列的消息)<ul>
<li>key: chat-set-new:customerServiceName  chat-set-old:customerServiceName</li>
<li>value: msg-list:username&amp;customerServiceName<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--luoyang联系客服xiaona--&gt;</span><br><span class="line">lpush msg-list:luoyang&amp;xiaona luoyang:nihao</span><br><span class="line">set chat-string-for:luoyang msg-list:luoyang&amp;xiaona</span><br><span class="line">sadd chat-set-new:xiaona msg-list:luoyang&amp;xiaona</span><br><span class="line"></span><br><span class="line">&lt;!--luoyang固定每秒遍历自己的消息队列,取最新的10条消息，上拉刷新的时候可以加载更多--&gt;</span><br><span class="line">lrange msg-list:luoyang&amp;xiaona 0 9</span><br><span class="line"></span><br><span class="line">&lt;!--客服xiaona每5秒像服务器发起一次请求，服务器遍历chat-set-new:xiaona的值将由新消息的对话返回给前端；</span><br><span class="line">当客服在前端点击对应的对话框的时候，再获取对应消息队列最新的10条数据，并将这个消息队列放到chat-set-old:xiaona中--&gt;</span><br><span class="line">smembers chat-set-new:xiaona</span><br><span class="line">&lt;!--xiaona点击某个对话框的时候，去获取最后10条消息--&gt;</span><br><span class="line">lrange msg-list:luoyang&amp;xiaona 0 9</span><br><span class="line">&lt;!--这里new往old里面可以使用move，但是old往new里面移动要使用删除和添加，不确定old里面是否有对应的key--&gt;</span><br><span class="line">smove chat-set-new:xiaona chat-set-old:xiaona msg-list:luoyang&amp;xiaona</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2>]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据持久化机制</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Redis/Redis%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p><a href="https://juejin.im/post/5da14c37e51d45784603adb7">本文参考文章</a></p>
<h2 id="1-数据库结构"><a href="#1-数据库结构" class="headerlink" title="1.数据库结构"></a>1.数据库结构</h2><p>一个单机Redis服务器默认有16个数据库，这个数量是可以配置的，每个数据库都由一个redis.h和redisDB表示，记录了键空间、键过期时间、阻塞状态等</p>
<h2 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2 RDB持久化"></a>2 RDB持久化</h2><p>RDB持久化（快照持久化）将内存中的数据生成快照保存到磁盘里面，文件后缀是.rdb，是一个经过压缩的二进制文件，Redis重启的时候读取快照文件恢复数据</p>
<p>这是一个单文件全量数据，适合数据库的容灾备份，1G的快照文件载入内存的时间大概是20s</p>
<h3 id="2-1-RDB的创建和载入"><a href="#2-1-RDB的创建和载入" class="headerlink" title="2.1 RDB的创建和载入"></a>2.1 RDB的创建和载入</h3><h4 id="2-1-1-手动保存"><a href="#2-1-1-手动保存" class="headerlink" title="2.1.1 手动保存"></a>2.1.1 手动保存</h4><ul>
<li>SAVE命令：是一个同步式命令，它会阻塞Redis服务器进程，直到RDB文件创建完成为止，期间服务器不能处理任何其他命令请求</li>
<li>BGSAVE：异步命令，开启一个子进程来创建RDB文件，父进程继续处理客户命令</li>
</ul>
<h4 id="2-1-2-自动保存"><a href="#2-1-2-自动保存" class="headerlink" title="2.1.2 自动保存"></a>2.1.2 自动保存</h4><p>满足一些条件的时候会自动触发BGSAVE方式进行保存（以下三个条件中的一个）</p>
<ul>
<li>服务器在 900 秒之内，对数据库进行了至少 1 次修改。</li>
<li>服务器在 300 秒之内，对数据库进行了至少 10 次修改。</li>
<li>服务器在 60 秒之内，对数据库进行了至少 10000 次修改。</li>
</ul>
<p>Redis每100毫秒执行一次serverCron函数，它的一项任务就是检查当前是否满足自动保存的条件</p>
<h4 id="2-1-3-启动自动载入"><a href="#2-1-3-启动自动载入" class="headerlink" title="2.1.3 启动自动载入"></a>2.1.3 启动自动载入</h4><p>Redis没有运行期间载入本地备份的机制，从逻辑上来说也没有必要，只是在重启的时候会从本地载入数据</p>
<h3 id="2-2-RDB文件结构"><a href="#2-2-RDB文件结构" class="headerlink" title="2.2 RDB文件结构"></a>2.2 RDB文件结构</h3><h4 id="2-2-1-存储路径"><a href="#2-2-1-存储路径" class="headerlink" title="2.2.1 存储路径"></a>2.2.1 存储路径</h4><p>文件存储的名称（默认dump.rdb）和路径都是可以设置的，不是很重要，不细说</p>
<h4 id="2-2-2-文件内容"><a href="#2-2-2-文件内容" class="headerlink" title="2.2.2 文件内容"></a>2.2.2 文件内容</h4><p>大体可以分为两个部分</p>
<ul>
<li><p>databases：包含着零个或者任意多个数据库，以及各个数据库的键值对数据</p>
<ul>
<li>SELECTDB：长度为一个字节的常量，告诉用户程序接下来要读取的是一个 db_number</li>
<li>db_number：保存着一个数据库编号。当程序读到 db_number 时，服务器会立即调用 SELECT 命令切换到对应编号的数据库</li>
<li>key_value_pairs：保存了数据库中的所有键值对数据，包括带过期时间和不带过期时间两种类型的键值对<ul>
<li>存储5组数据：过期标记、过期时间、类型、key、value，如果是不带过期时间的键值对则没有前两组数据</li>
</ul>
</li>
</ul>
</li>
<li><p>其他：包含Redis版本、主机架构、内存配置等源数据信息</p>
</li>
</ul>
<h3 id="2-3-RDB常用配置项"><a href="#2-3-RDB常用配置项" class="headerlink" title="2.3 RDB常用配置项"></a>2.3 RDB常用配置项</h3><ul>
<li>save m n：bgsave自动触发条件</li>
<li>stop-writes-on-bgsave-error yes：当BGSAVE命令出现错误是，Redis是否停止执行写命令</li>
<li>rdbcompression yes：是否开启 RDB 文件压缩。</li>
<li>rdbchecksum yes：是否开启 RDB 文件的校验，在写入文件和读取文件时都起作用。关闭 checksum 在写入文件和启动文件时大约能带来 10% 的性能提升，但是数据损坏时无法发现。</li>
<li>dbfilename dump.rdb：设置 RDB 的文件名。</li>
<li>dir ./：设置 RDB 文件和 AOF 文件所在目录。</li>
</ul>
<h2 id="3-AOF持久化"><a href="#3-AOF持久化" class="headerlink" title="3 AOF持久化"></a>3 AOF持久化</h2><p>AOF 会把 Redis 服务器每次执行的写命令记录到一个日志文件中，当服务器重启时再次执行 AOF 文件中的命令来恢复数据，且AOF的优先级要高于RDB的，如果开启了AOF则不会使用RDB方式进行恢复</p>
<h3 id="3-1-AOF创建"><a href="#3-1-AOF创建" class="headerlink" title="3.1 AOF创建"></a>3.1 AOF创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--AOF 默认是关闭的，通过这个命令启动--&gt;</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<h3 id="3-2-工作原理"><a href="#3-2-工作原理" class="headerlink" title="3.2 工作原理"></a>3.2 工作原理</h3><p>将对Redis服务器的所有写命令都自动记录到AOF文件中</p>
<ul>
<li>命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 aof_buf</li>
<li>文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 aof_buf 的数据同步到硬盘<ul>
<li>write：操作系统会将数据先写入到内存缓冲区中，当缓冲区被填满或者超过了指定限制之后才真正将数据写入到磁盘里</li>
<li>fsync：write会有一个问题，如果刺痛宕机则会丢失缓存中的数据，为此同时提供了fsync同步函数，Redis提供三种缓存同步机制<ul>
<li>appendfsync always：每执行一次命令保存一次</li>
<li>appendfsync no：不保存，有操作系统负责，通常是30s</li>
<li>appendfsync everysec：每秒钟保存一次（前两种策略的折中，Redis默认规则）</li>
</ul>
</li>
</ul>
</li>
<li>文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩。<ul>
<li>AOF 文件重写指的是把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件中，然后使用新的 AOF 文件覆盖旧的 AOF 文件，这个过程不对旧的 AOF 文件的进行任何读写操作。</li>
<li>压缩原理：过期的数据不再写入AOF文件、无效命令（重复对key赋值）不再写入文件、多条命令被合并为单个</li>
</ul>
</li>
</ul>
<h3 id="3-3-AOF常用配置项"><a href="#3-3-AOF常用配置项" class="headerlink" title="3.3 AOF常用配置项"></a>3.3 AOF常用配置项</h3><ul>
<li>appendonly no：是否开启 AOF 持久化功能</li>
<li>appendfilename “appendonly.aof”：AOF 文件的名称</li>
<li>dir ./：RDB 文件和 AOF 文件所在目录</li>
<li>appendfsync everysec：fsync 持久化策略</li>
<li>no-appendfsync-on-rewrite no：重写 AOF 文件期间是否禁止 fsync 操作。如果开启该选项，可以减轻文件重写时 CPU 和磁盘的负载（尤其是磁盘），但是可能会丢失 AOF 重写期间的数据，需要在负载和安全性之间进行平衡</li>
<li>auto-aof-rewrite-percentage 100：AOF 文件重写触发条件之一</li>
<li>auto-aof-rewrite-min-size 64mb：AOF 文件重写触发条件之一</li>
<li>aof-load-truncated yes：如果 AOF 文件结尾损坏，Redis 服务器在启动时是否仍载入 AOF 文件</li>
</ul>
<h2 id="4-数据恢复机制"><a href="#4-数据恢复机制" class="headerlink" title="4 数据恢复机制"></a>4 数据恢复机制</h2><ul>
<li>AOF优先级高于RDB（AOF的精度高于RDB）</li>
<li>AOF开启的时候，即使AOF文件不存在，Redis也不会尝试使用RDB来进行数据恢复（这个时候应该是认为Redis在上次关闭时内存中没有数据）</li>
</ul>
<h2 id="5-RDB和AOF对比"><a href="#5-RDB和AOF对比" class="headerlink" title="5 RDB和AOF对比"></a>5 RDB和AOF对比</h2><table>
<thead>
<tr>
<th>机制</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>磁盘占用</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>数据还原速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>容易丢失</td>
<td>正常配置都会相对高</td>
</tr>
<tr>
<td>操作轻重级别</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody></table>
<h3 id="5-1-RDB优缺点"><a href="#5-1-RDB优缺点" class="headerlink" title="5.1 RDB优缺点"></a>5.1 RDB优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>文件结构紧凑，保存了某个时间节点上的所有数据，且磁盘占用小，适合做数据的备份和灾难恢复</li>
<li>数据备份时只要开启一个子进程来完成数据的写入操作，对父进程不受到影响</li>
<li>数据恢复时比AOF更快</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>数据的保存是一个重量级的操作，可能需要几分钟的时间，而且默认的配置是一个小时保存一次，所以可能会丢失几分钟或者更多的数据</li>
<li>Redis数据集较大时，子进程要完成快照比较耗费CPU和时间</li>
</ul>
<h3 id="5-2-AOF的优缺点"><a href="#5-2-AOF的优缺点" class="headerlink" title="5.2 AOF的优缺点"></a>5.2 AOF的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>数据完整性更高、秒级的数据丢失</li>
<li>文件是进行命令追加的命令文件，已Redis协议格式保存，可读，适合误删紧急恢复（从记录中找出被误删数据的写入命令执行）</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>文件体积更大，恢复速度更慢</li>
</ul>
<h2 id="6-混合持久化"><a href="#6-混合持久化" class="headerlink" title="6 混合持久化"></a>6 混合持久化</h2><ul>
<li>Redis 4.0 版本提供了一套基于 AOF-RDB 的混合持久化机制，保留了两种持久化机制的优点</li>
<li>基本的思路是，使用RDB来定时的对数据进行备份，在备份过程（或者是备份间隔）的时间的数据通过AOF来备份，即大部分的数据是通过RDB来进行备份的，最后小部分时间片段的数据通过AOF来进行备份</li>
<li>这样重写的 AOF 文件由两部份组成，一部分是 RDB 格式的头部数据，另一部分是 AOF 格式的尾部指令。</li>
</ul>
<h2 id="7-不同场景的策略选择"><a href="#7-不同场景的策略选择" class="headerlink" title="7 不同场景的策略选择"></a>7 不同场景的策略选择</h2><ul>
<li>数据库缓存：这个时候其实Redis服务器出现意外宕机数据丢失也无所谓，数据库中还维护这完整的数据，所以为了性能最大化，可以将所有持久化策略关闭</li>
<li>单机环境：如果可以接受十几分钟或者一个小时的数据丢失，那么使用RDB是一个很好的选择；如果只能接受秒级别的数据丢失，AOF更好一些</li>
<li>主从部署：大多数时候都会使用主从部署<ul>
<li>这时候主节点可以完全关闭持久化，从节点关闭RDB开启AOF</li>
<li>定时对持久化文件进行备份</li>
<li>关闭AOF自动重写功能，手动添加定时任务，在Redis服务器压力小的时间节点上调用bgrewriteaof对持久化文件进行重写</li>
<li>主从结构下还要对数据进行持久化，是预防所有节点同时宕机</li>
</ul>
</li>
<li>异地灾备：将持久化文件定时拷贝发送到远程机器进行存储</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis管理命令</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/Redis/Redis%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h1><h2 id="info-memory"><a href="#info-memory" class="headerlink" title="info memory"></a>info memory</h2><p>在进入redis命令行后执行<code>info memory</code>即可看到redis内存使用状态，这个是看总体的状态</p>
<h2 id="bigkeys命令"><a href="#bigkeys命令" class="headerlink" title="bigkeys命令"></a>bigkeys命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -p 8090 --bigkeys</span><br></pre></td></tr></table></figure>

<p>通过bigkeys命令可以统计出每个类型下数据规模最大的key（只有sting类型是空间占用最大）</p>
<h2 id="MEMORY-usage"><a href="#MEMORY-usage" class="headerlink" title="MEMORY usage"></a>MEMORY usage</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEMORY usage key_name</span><br></pre></td></tr></table></figure>
<p>通过这个命令可以看到一个key的内存占用大小，这个命令是会取5个key-value计算平均大小，再乘上规模来进行的预估</p>
<h2 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h2><p>直接在命令行执行<code>monitor</code>即可，但是开启这个监控会影响性能，所以不要后台执行，不用了之后及时退出</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse -- python调用clickhouse语法</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/clickhouse/python%E8%B0%83%E7%94%A8clickhouse%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="一、client方式"><a href="#一、client方式" class="headerlink" title="一、client方式"></a>一、client方式</h1><h2 id="1-1-基础用法"><a href="#1-1-基础用法" class="headerlink" title="1.1 基础用法"></a>1.1 基础用法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> clickhouse_driver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 HTTP 连接方式连接 ClickHouse 数据库</span></span><br><span class="line">client = clickhouse_driver.Client(</span><br><span class="line">    host=<span class="string">&#x27;your_host&#x27;</span>,</span><br><span class="line">    port=<span class="string">&#x27;your_port&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;your_user&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;your_password&#x27;</span>,</span><br><span class="line">    database=<span class="string">&#x27;your_database&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 SQL 查询语句</span></span><br><span class="line">results = client.execute(<span class="string">&#x27;SELECT * FROM your_table&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理查询结果</span></span><br><span class="line"><span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure>

<h2 id="1-2-防止SQL注入"><a href="#1-2-防止SQL注入" class="headerlink" title="1.2 防止SQL注入"></a>1.2 防止SQL注入</h2><ul>
<li>  查询操作，防止SQL注入，in查询语法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ck_client = get_slb_client()</span><br><span class="line">query_sql = <span class="string">&quot;select time, sum(in_bits), sum(out_bits) from slb_monitor_data_all where &quot;</span> \</span><br><span class="line">            <span class="string">&quot;listen_id = %(listen_id)s and vm_id in (%(vm_ids)s) and time &gt;= %(start_time)s and &quot;</span> \</span><br><span class="line">            <span class="string">&quot;time &lt; %(end_time)s group by time order by time;&quot;</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;listen_id&#x27;</span>: listen_obj.<span class="built_in">id</span>,</span><br><span class="line">    <span class="string">&#x27;vm_ids&#x27;</span>: [v.<span class="built_in">id</span> <span class="keyword">for</span> v <span class="keyword">in</span> vm_objs],</span><br><span class="line">    <span class="string">&#x27;start_time&#x27;</span>: start_time,</span><br><span class="line">    <span class="string">&#x27;end_time&#x27;</span>: end_time,</span><br><span class="line">&#125;</span><br><span class="line">res = ck_client.execute(query_sql, params)</span><br></pre></td></tr></table></figure>

<h2 id="1-3-插入操作"><a href="#1-3-插入操作" class="headerlink" title="1.3 插入操作"></a>1.3 插入操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">insert_list = [</span><br><span class="line">	&#123;<span class="string">&#x27;vm_id&#x27;</span>: <span class="string">&#x27;vm_id&#x27;</span>, <span class="string">&#x27;listen_id&#x27;</span>: <span class="string">&#x27;listen_id&#x27;</span> ...&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;vm_id&#x27;</span>: <span class="string">&#x27;vm_id&#x27;</span>, <span class="string">&#x27;listen_id&#x27;</span>: <span class="string">&#x27;listen_id&#x27;</span> ...&#125;,</span><br><span class="line">	...</span><br><span class="line">]</span><br><span class="line">insert_sql = <span class="string">&quot;insert into slb_monitor_data_local (vm_id, listen_id, time, active_conn, in_active_conn, &quot;</span> \</span><br><span class="line">             <span class="string">&quot;new_conn, loss_conn, all_conn, in_pkts, out_pkts, in_bits, out_bits, all_in_pkts, all_out_pkts, &quot;</span> \</span><br><span class="line">             <span class="string">&quot;all_in_bytes, all_out_bytes) values&quot;</span></span><br><span class="line">ck_client.execute(insert_sql, insert_list)</span><br></pre></td></tr></table></figure>

<h1 id="二、connect"><a href="#二、connect" class="headerlink" title="二、connect"></a>二、connect</h1><h2 id="2-1-基础用法一"><a href="#2-1-基础用法一" class="headerlink" title="2.1 基础用法一"></a>2.1 基础用法一</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> clickhouse_driver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 TCP 连接方式连接 ClickHouse 数据库</span></span><br><span class="line">connection = clickhouse_driver.connect(</span><br><span class="line">    host=<span class="string">&#x27;your_host&#x27;</span>,</span><br><span class="line">    port=<span class="string">&#x27;your_port&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;your_user&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;your_password&#x27;</span>,</span><br><span class="line">    database=<span class="string">&#x27;your_database&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取游标对象</span></span><br><span class="line">cursor = connection.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 SQL 查询语句</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;SELECT * FROM your_table&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理查询结果</span></span><br><span class="line">results = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭游标和连接</span></span><br><span class="line">cursor.close()</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<h2 id="2-2-基础用法二"><a href="#2-2-基础用法二" class="headerlink" title="2.2 基础用法二"></a>2.2 基础用法二</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> clickhouse_driver</span><br><span class="line"></span><br><span class="line">connection = clickhouse_driver.connect(host=<span class="string">&#x27;your_host&#x27;</span>, port=<span class="string">&#x27;your_port&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 with 语句块，确保程序结束时自动关闭游标和连接</span></span><br><span class="line"><span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">    <span class="comment"># 执行 SQL 查询语句</span></span><br><span class="line">    cursor.execute(<span class="string">&#x27;SELECT * FROM your_table&#x27;</span>)</span><br><span class="line">    <span class="comment"># 处理查询结果</span></span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 with 语句块结束后，游标和连接会自动关闭</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据持久化</category>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse -- 一、安装与配置</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/clickhouse/%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>{“canTryAgain”:false,”scope”:”PREVIOUS_EXCEPTION”,”error”:”27601”,”message”:”Message[NOS_ERROR_PARAM_EMPTY_KEY]: failed to download file, userId=qq7AE1C3EC95D8BC3B8E19DFC70C1C83F1, fileId=WEB7339520ab742d936c5ad910f6a987494”,”objectUser”:”qq7AE1C3EC95D8BC3B8E19DFC70C1C83F1”}</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse -- 三、表结构</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/clickhouse/%E4%B8%89%E3%80%81%E8%A1%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="定义数据表"><a href="#定义数据表" class="headerlink" title="定义数据表"></a>定义数据表</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><code>CREATE DATABASE if not exists lxl_test_flow_snmp ENGINE = Ordinary;</code></p>
<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>ch中数据库也是可以设置引擎的，目前支持5中引擎</p>
<ul>
<li>  ordinary：默认引擎，此数据库可以使用任意类型的表引擎</li>
<li>  dictionary：字典引擎，自动为所有数据字典创建他们的数据表</li>
<li>  memory：内存引擎，用于存放临时数据，此数据库下的数据表只会停留在内存中，不会涉及任何磁盘操作，当服务重启后数据会被清除</li>
<li>  lazy：日志引擎，此数据库下只能使用Log系列表引擎</li>
<li>  MySQL：MySQL引擎，此类数据库下会自动拉取远端MySQL中的数据，并为他们创建MySQL表引擎的数据表</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-07/ch%E5%AD%98%E5%82%A8.png" alt="image"></p>
<ul>
<li>  在data目录下创建对应的文件目录</li>
<li>  在metadata下创建用于数据库恢复的xx.sql文件</li>
</ul>
<h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><h3 id="本地表"><a href="#本地表" class="headerlink" title="本地表"></a>本地表</h3><pre><code>CREATE TABLE lxl_test_flow_snmp.flow_data_local_new ON CLUSTER clickhouse_remote_servers
(
    `pipe_id` String,
    `time` DateTime,
    `in_flow` Float64,
    `out_flow` Float64,
    `in_bps` Float64,
    `out_bps` Float64
)
ENGINE = ReplicatedMergeTree(&#39;/clickhouse/tables/&#123;shard&#125;/flow_data_local_new&#39;, &#39;&#123;replica&#125;&#39;)
PARTITION BY toYYYYMM(time)
ORDER BY (pipe_id, time)
SETTINGS index_granularity = 8192
</code></pre>
<ul>
<li>  通过<code>ON CLUSTER</code>来指定集群</li>
<li>  ReplicatedMergeTree引擎用来做副本自动同步，里面的参数{shard}是指分片编号取的配置文件中信息，replica则是取的副本信息，这样配置该表就会在集群中的各个节点上创建，不用一个个去创建</li>
<li>  分区的话CH做得比较好的就是按日期来分区，对字符的分区无法指定分区数量不太好用，除非自己创建一个字段专门用来分区，在业务侧为这个字段定义好分区信息；且分区只有MergeTree系列的表引擎才支持</li>
<li>  索引结构后面再详细研究，大体上是在磁盘上进行线性存储</li>
</ul>
<h3 id="分布式表"><a href="#分布式表" class="headerlink" title="分布式表"></a>分布式表</h3><pre><code>CREATE TABLE lxl_test_flow_snmp.flow_data_all ON CLUSTER clickhouse_remote_servers as lxl_test_flow_snmp.flow_data_local_new
ENGINE = Distributed(&#39;clickhouse_remote_servers&#39;, &#39;lxl_test_flow_snmp&#39;, &#39;flow_data_local_new&#39;, rand())
</code></pre>
<ul>
<li>  一般用all来进行命名，指定好对应的本地表即可</li>
<li>  最后的<code>rand()</code>是指通过分布式表进行数据插入的时候，会通过一个随机函数对数据存储的分片进行选择</li>
</ul>
<h3 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h3><p>也就是之前说的有个数据库引擎只支持临时表，数据在内存中不会落盘，临时表和普通表名可以相同，且临时表的优先级更高，都可以看做一个缓存机制，这个用户通常不会用到，是CH内部数据在集群建传播的载体</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>有普通和物化视图两种</p>
<ul>
<li>  普通视图就是封装的查询语句，帮助获得更清晰的逻辑，但是对性能没有优化作用</li>
<li>  物化视图是真的会存储到磁盘，视图初始化的时候可以选择同步映射字段中的数据，也可以选择同步之后新入的数据，物化视图不支持同步删除，源字段发生数据删除物化视图中数据仍会保留</li>
</ul>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区支持的操作：创建、复制、重置数据、卸载与装载</p>
<h2 id="分布式DDL"><a href="#分布式DDL" class="headerlink" title="分布式DDL"></a>分布式DDL</h2><p>在DDL中加入<code>ON CLUSTER</code>来让集群的每个节点都执行，免去依次去单个节点执行</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse -- 二、数据定义</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/clickhouse/%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>clickhouse的数据类型可以划分为基础数据类型、复合数据类型和特殊数据类型</p>
<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><p>数值、字符串和时间</p>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>数值</th>
<th>普遍称呼</th>
</tr>
</thead>
<tbody><tr>
<td>int8</td>
<td>1</td>
<td>-128~127</td>
<td>tinyint</td>
</tr>
<tr>
<td>int16</td>
<td>2</td>
<td>-32768~32767</td>
<td>smallint</td>
</tr>
<tr>
<td>int32</td>
<td>4</td>
<td>…</td>
<td>int</td>
</tr>
<tr>
<td>int64</td>
<td>8</td>
<td>…</td>
<td>bigint</td>
</tr>
</tbody></table>
<p>ch在这个地方还是比较直，int加上多少位进行命名，同MySQL一样，也支持无符号整数</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>数值</th>
<th>普遍称呼</th>
</tr>
</thead>
<tbody><tr>
<td>uint8</td>
<td>1</td>
<td>0~255</td>
<td>tinyint</td>
</tr>
<tr>
<td>uint16</td>
<td>2</td>
<td>0~65535</td>
<td>smallint</td>
</tr>
<tr>
<td>uint32</td>
<td>4</td>
<td>…</td>
<td>int</td>
</tr>
<tr>
<td>uint64</td>
<td>8</td>
<td>…</td>
<td>bigint</td>
</tr>
</tbody></table>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>ch中有float32和float64来表示单精度和双精度浮点数</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>精度</th>
<th>普遍称呼</th>
</tr>
</thead>
<tbody><tr>
<td>float32</td>
<td>4</td>
<td>7</td>
<td>float</td>
</tr>
<tr>
<td>float64</td>
<td>8</td>
<td>16</td>
<td>double</td>
</tr>
</tbody></table>
<p>同时浮点数还支持正无穷<code>select 8/0</code>和负无穷<code>select -8/0</code>以及非数字<code>select 0/0</code></p>
<h4 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h4><p>高精度计算，暂时没有接触过，以后用到再说</p>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>长度不限，也就说不用声明大小，也不需要设置字符集，可以存储任意编码的字符串，实际使用的时候同一套系统中最好还是相同的编码</p>
<h4 id="FixedString"><a href="#FixedString" class="headerlink" title="FixedString"></a>FixedString</h4><p>类似于char，只是char用空格进行补齐，FixedString使用null进行补齐</p>
<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>数据库中常见的主键类型，ch中直接作为一种数据类型，如果没有被赋值，会使用0按格式进行填充</p>
<h3 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h3><h4 id="DateTime"><a href="#DateTime" class="headerlink" title="DateTime"></a>DateTime</h4><p>包含时分秒信息，精度是秒，支持使用字符串形式写入</p>
<h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>精度是天，同样支持字符串格式写入</p>
<h4 id="DateTime64"><a href="#DateTime64" class="headerlink" title="DateTime64"></a>DateTime64</h4><p>这里没讲，遇到再查</p>
<h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>数组、元组、枚举和嵌套</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><pre><code>CREATE TABLE Array_TEST (
    c1 Array(String)
) engine = Memory ;
</code></pre>
<p>数组定义的时候需要指定元素的类型</p>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><pre><code>CREATE TABLE Tuple_TEST(
    c1 Tuple(String,Int8)
) ENGINE = Memory;
</code></pre>
<p>同样需要指定类型，不过元素间类型可以不同</p>
<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><pre><code>CREATE TABLE Enum_TEST (
    c1 Enum8(&#39;ready&#39; = 1,&#39;start&#39; = 2,&#39;success&#39; = 3,&#39;error&#39; = 4)
) ENGINE = Memory;

&lt;!--插入数据--&gt;
INSERT INTO Enum_TEST VALUES(&#39;ready&#39;);
INSERT INTO Enum_TEST VALUES(&#39;start&#39;);
</code></pre>
<p>InnoDB中反正是不推荐大家用枚举的，ch情况如何还不清楚；只是说性能比直接使用string要高，因为对枚举的操作都使用int类型的值进行</p>
<h3 id="nested"><a href="#nested" class="headerlink" title="nested"></a>nested</h3><pre><code>CREATE TABLE nested_test (
    name String,
    age UInt8,
    dept Nested(
        id UInt8,
        name String
        )
) ENGINE = Memory;
</code></pre>
<p>员工和部门这样的结构可以使用嵌套，ch中只支持一层嵌套</p>
<h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><h3 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h3><p>并不是一中独立的数据类型，是一个辅助修饰符</p>
<pre><code>CREATE TABLE Null_TEST (
    c1 String,
    c2 Nullable(UInt8)
) ENGINE = TinyLog;
</code></pre>
<p>表示取值可以为空，只能和基础类型搭配使用</p>
<h3 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h3><p>分为IPv4和IPv6两类，是对字符串和整型的进一步封装</p>
<pre><code>CREATE TABLE IP4_TEST (
    url String,
    ip IPv4
) ENGINE = Memory;

INSERT INTO IP4_TEST VALUES(&#39;www.nauu.com&#39;,&#39;192.0.0.0&#39;);
</code></pre>
<p>IPv4类型支持格式检查，格式错误的数据无法被写入，IPv4使用Uint32进行存储，相比String更加紧凑，占用空间更小，性能更高；需要注意的是，由于并不是按string进行存储的，所以不支持隐式的自动类型转换</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse -- 基础SQL</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/clickhouse/%E5%9F%BA%E7%A1%80SQL/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><h2 id="创建DB"><a href="#创建DB" class="headerlink" title="创建DB"></a>创建DB</h2><pre><code>CREATE DATABASE flow_snmp ON CLUSTER clickhouse_remote_servers  ENGINE = Ordinary;
</code></pre>
<h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><pre><code>CREATE TABLE lxl_test_flow_snmp.rename_test ON CLUSTER clickhouse_remote_servers
(
    `pipe_id` UUID,
    `time` DateTime,
    `in_flow` Float64,
    `out_flow` Float64,
    `in_bps` Float64,
    `out_bps` Float64
)
ENGINE = ReplicatedMergeTree(&#39;/clickhouse/tables/&#123;shard&#125;/rename_test&#39;, &#39;&#123;replica&#125;&#39;)
PARTITION BY toYYYYMM(time)
ORDER BY (pipe_id, time)
SETTINGS index_granularity = 8192
</code></pre>
<h2 id="修改数据库表名"><a href="#修改数据库表名" class="headerlink" title="修改数据库表名"></a>修改数据库表名</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RENAME <span class="keyword">TABLE</span> flow_snmp.flow_data_first_local <span class="keyword">TO</span> flow_snmp.flow_data_first_local_v1 <span class="keyword">ON</span> CLUSTER cluster_1shards_3replicas</span><br></pre></td></tr></table></figure>

<h2 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h2><pre><code>alter table slb_monitor.slb_monitor_data_local add column vm_id UUID 
</code></pre>
<h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><h2 id="删除分区数据"><a href="#删除分区数据" class="headerlink" title="删除分区数据"></a>删除分区数据</h2><pre><code>client.execute(&quot;ALTER TABLE flow_snmp.flow_data_second_local DROP PARTITION &#39;202107&#39;&quot;)
</code></pre>
<h2 id="x20-查询数据（防注入）"><a href="#x20-查询数据（防注入）" class="headerlink" title="&#x20;查询数据（防注入）"></a>&#x20;查询数据（防注入）</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">query_sql <span class="operator">=</span> &quot;select time, all_conn, all_in_pkts, all_out_pkts, all_in_bytes, all_out_bytes from slb_monitor_data_all where vm_id = %(slb_vm_id)s and listen_id = %(listen_id)s order by time desc limit 1;&quot;</span><br><span class="line">params <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="string">&#x27;slb_vm_id&#x27;</span>: slb_vm_id,</span><br><span class="line">    <span class="string">&#x27;listen_id&#x27;</span>: listen_id,</span><br><span class="line">&#125;</span><br><span class="line">res <span class="operator">=</span> ck_client.execute(query_sql, params)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="keyword">in</span>查询语法，假设查询列名为 column1</span><br><span class="line">query <span class="operator">=</span> <span class="string">&#x27;SELECT * FROM your_table WHERE column1 IN (%(values)s)&#x27;</span></span><br><span class="line">params <span class="operator">=</span> &#123;<span class="string">&#x27;values&#x27;</span>: [<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>, <span class="string">&#x27;value3&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><ul>
<li>  ck中数据的修改和删除都很困难，一开始ck直接是不支持这两个操作的</li>
<li>在集群中修改数据，修改命令只能面向本地表，不能面向分布式表进行操作，问题在于比如有两个分片，1-10号数据均匀分布在两个分片中<ul>
<li>  首先直接向某一个分片的本地表进行修改是可以成功的，且修改会自动被同步到分片的复制节点上</li>
<li>但是我们不能写个循环对每个分片进行修改，这样的方式显得蠢笨，ck提供了一个命令向集群中所有分片的本地表进行修改<br>  ALTER TABLE flow_snmp.flow_data_first_local ON CLUSTER clickhouse_remote_servers UPDATE in_bps = 5555,out_bps = 2222 WHERE pipe_id = ‘4b9ed63c-ae84-11ec-87f3-1200cba86117’ and time &gt; ‘2022-04-11 16:05:00’;</li>
<li>  上面的命令看起来很美，实际上执行的时候会超时（30s），但是呢数据又确实被修改成功了，体现出了一种不确定性</li>
<li>所幸目前线上库是1个分片三个复制，所以我不用加集群，直接对某个复制的本地表进行修改，改动就能成功的被同步到剩下的两个复制节点上，但问题没有完全解决<br>  ALTER TABLE flow_snmp.flow_data_first_local UPDATE in_bps = 5555,out_bps = 2222 WHERE pipe_id = ‘4b9ed63c-ae84-11ec-87f3-1200cba86117’ and time &gt; ‘2022-04-11 16:05:00’;</li>
</ul>
</li>
<li>  总结ck的修改是不稳定的，据说是异步进行的没有原子性，但效率其实还可以，面向一个7000w规模的分区进行修改，改动数据量小不超过100条时还是可以立马修改完成的</li>
</ul>
<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>和修改数据情况类似，给出命令<code>ALTER TABLE flow_snmp.flow_data_first_local ON CLUSTER clickhouse_remote_servers DELETE WHERE pipe_id = &#39;4b9ed63c-ae84-11ec-87f3-1200cba86117&#39; and time = &#39;2022-04-11 16:00:00&#39;;</code></p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>clickhouse -- 架构概述</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/clickhouse/%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="CH的核心特性"><a href="#CH的核心特性" class="headerlink" title="CH的核心特性"></a>CH的核心特性</h1><h2 id="完备的DBMS功能"><a href="#完备的DBMS功能" class="headerlink" title="完备的DBMS功能"></a>完备的DBMS功能</h2><p>不单是一个数据库，它应该是一个数据库管理系统，具备DDL、DML、分布式、权限控制、安全备份等特性</p>
<h2 id="列式存储和数据压缩"><a href="#列式存储和数据压缩" class="headerlink" title="列式存储和数据压缩"></a>列式存储和数据压缩</h2><p>列式存储是指同一列的数据会被存储到一起，同一行的数据的列被存储在不同的文件中，比如有一个表有50个字段，100行数据，要提取某5个字段的数据来进行分析，对于行存储来说实际还是要扫描所有字段然后取出要的字段，而列存储可以直接去获取需要的列</p>
<p>数据压缩的基本原理，比如字符串abcdefghi_bdcefghi可以被压缩为abcdefghi_(9,8)，压缩的本质就是对相同的数据进行编码存储，也就是说数据重复度越高，那么压缩率也就越高，而什么样的数据重复度高呢，同一列的数据由于拥有相同的属性，更容易出现重复，所以列式存储对数据压缩更友好</p>
<p>所以可以看到列式存储对于某些业务场景下，可以减少磁盘IO和数据传输体积，从而提高效率</p>
<h2 id="向量化执行引擎"><a href="#向量化执行引擎" class="headerlink" title="向量化执行引擎"></a>向量化执行引擎</h2><p>这里说的是从指令集的层面使用SSE4.2来进行单条指令执行多条数据，来进行并发，不懂</p>
<h2 id="标准SQL支持"><a href="#标准SQL支持" class="headerlink" title="标准SQL支持"></a>标准SQL支持</h2><p>CH不像NoSQL数据库，它拥有数据库、表、视图这些传统概念，</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>clickhouse</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>clickhouse</tag>
      </tags>
  </entry>
  <entry>
    <title>end -- 关于jdbc的conn、ps、rs、pool</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/end/%E5%85%B3%E4%BA%8Ejdbc%E7%9A%84conn%E3%80%81ps%E3%80%81rs%E3%80%81pool/</url>
    <content><![CDATA[<p>关于 parperedstatement和statement的故事</p>
<ol>
<li><p>ps可以传递参数</p>
</li>
<li><p>ps性能更为优化，具体原因：使用ps时sql会被预编译到数据库系统中（大概是一个什么缓存中把），但我们重复调用时效率更高，数据库压力更小；这个地方要注意的是，要想得到这种性能上的提升我们必须使用“？”占位符，而不能直接把字符串写入到sql语句中，比如</p>
</li>
<li><p>“select * from users where username=?”</p>
</li>
<li><p>“select * from users where username = “+username     //username是我们程序里面定义的一个字符串</p>
</li>
<li><p>上面的第二种写法就不再具有性能提升的功能</p>
</li>
<li><p>ps可以防止sql注入，sql注入举例：</p>
</li>
<li><p>sql：“select * from users where username = ”+username+”and password = “+password</p>
</li>
<li><p>当恶意传入的参数为：username = “‘1’ or ‘1’ = ‘1’ “   password =  “‘1’ or ‘1’ = ‘1’ “ 时，sql变成了：select * from user where username =’1’ or ‘1’ = ‘1’ and password = ‘1’ or ‘1’ = ‘1’ </p>
</li>
<li><p>这样就能直接登录了，而ps的占位符能解决这个问题，然后还有一种解决方案是：”SELECT * FROM users WHERE name = ‘“ + userName + “‘ and pw = ‘“+ passWord +”‘;这样写的sql也可以做到防止注入，但是看起来也不保险；</p>
</li>
</ol>
<p>关于rs的故事：</p>
<p>            一个ps同一时间只能有一个rs，这是什么意思呢，就是我打开了一个ps，这个ps是绑定了sql语句的，然后我用ps创建了一个结果集rs，我对这个rs一顿操作，但是当我想用前面的ps创建第二个结果集rs1的时候，系统默认关闭第一个结果集rs；这导致我们想要进行嵌套操作的时候，必须获取不同的ps，这个地方，同一个conn是可以创建不同ps的，不用再去获取新的连接；</p>
<p>    </p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>end</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>end</tag>
      </tags>
  </entry>
  <entry>
    <title>end -- 数据库笔记3--postgres语法</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/end/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B03--postgres%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>安装：</p>
<p>数据库管理命令：</p>
<ul>
<li><p>列出所有数据库：\l</p>
</li>
<li><p>切换数据库：\c</p>
</li>
<li><p>列出所有表：\d</p>
</li>
<li><p>查看表字段信息：\d tableName</p>
</li>
<li><p>列出所有用户：\du</p>
</li>
<li><p>列出当前数据库和连接信息：\conninfo</p>
</li>
</ul>
<p>基础操作</p>
<ul>
<li><p>创建数据库：create database dbName;</p>
</li>
<li><p>删除数据库：drop database dbName;</p>
</li>
<li><p>创建表：create table tableName(columnName type,columnName type);</p>
</li>
<li><p>删除表：alter table oldTableName rename to newTableName;</p>
</li>
<li><p>删除表：drop table tableName;</p>
</li>
<li><p>修改表字段类型:alter table tableName alter columnName type columnType;</p>
</li>
<li><p>修改表字段名字：alter table tableName alter oldColumnName to newColumnName;</p>
</li>
<li><p>删除表字段：alter table tableName drop column columnName;</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>end</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>end</tag>
      </tags>
  </entry>
  <entry>
    <title>名词解释 -- WAN、LAN、ETH接口</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/WAN%E3%80%81LAN%E3%80%81ETH%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="没有WAN和LAN"><a href="#没有WAN和LAN" class="headerlink" title="没有WAN和LAN"></a>没有WAN和LAN</h1><ul>
<li>  从日常生活的角度看，一般路由器上有一个wan和多个lan口，需要将运营商外网连接到WAN口，而家里的终端设备连接到LAN口</li>
<li>  从概念上说，其实都是物理接口，只是厂家出厂配置不同才从业务上分为了WAN口和LAN口</li>
<li>  那么问题来了，有的路由器有两个WAN口可以接入不同运营商网络，在实现原理上和单WAN口区别是什么</li>
</ul>
<h1 id="PHY和MAC"><a href="#PHY和MAC" class="headerlink" title="PHY和MAC"></a>PHY和MAC</h1><p><img src="/img/16800813936051680081393506.png"></p>
<ul>
<li>  mac和phy之间是一对多的关系</li>
</ul>
<h1 id="物理口和虚拟口"><a href="#物理口和虚拟口" class="headerlink" title="物理口和虚拟口"></a>物理口和虚拟口</h1><ul>
<li><p>  之前提到的其实没有什么WAN或者LAN，所有的物理接口都应该叫ETH（以太接口）</p>
</li>
<li><p>  ETH0-ETHn，每个ETH口对应一个mac，ETH信息是能在设备的操作系统中查询到的，一般是网卡加载的时候进行注册</p>
</li>
<li><p>虚拟网口：</p>
<ul>
<li>  ETH0:x</li>
<li>  ETH0.x 这个就很像我们设备上vlan了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>网络基础</category>
        <category>名词解释</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>名词解释</tag>
      </tags>
  </entry>
  <entry>
    <title>end -- 尚硅谷数据库课件</title>
    <url>/2023/04/13/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/end/%E5%B0%9A%E7%A1%85%E8%B0%B7%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E4%BB%B6/</url>
    <content><![CDATA[<p>尚硅谷数据库课件</p>
<p>2016年1月20日</p>
<p>15:08</p>
<p> </p>
<p> </p>
<p>day15-MySQL</p>
<p> </p>
<p>数据库</p>
<p> </p>
<p>1数据库概念（了解）</p>
<p>1.1什么是数据库</p>
<p>数据库就是用来存储和管理数据的仓库！</p>
<p>数据库存储数据的优先：</p>
<p>l </p>
<p>可存储大量数据；</p>
<p>l 方便检索；</p>
<p>l 保持数据的一致性、完整性；</p>
<p>l 安全，可共享；</p>
<p>l 通过组合分析，可产生新数据。</p>
<p> </p>
<p>1.2数据库的发展历程</p>
<p>l 没有数据库，使用磁盘文件存储数据；</p>
<p>l 层次结构模型数据库；</p>
<p>l 网状结构模型数据库；</p>
<p>l 关系结构模型数据库：使用二维表格来存储数据；</p>
<p>l 关系-对象模型数据库；</p>
<p> </p>
<p>MySQL就是关系型数据库！</p>
<p> </p>
<p>1.3常见数据库</p>
<p>l Oracle（神喻）：甲骨文（最高！）；</p>
<p>l DB2：IBM；</p>
<p>l SQL Server：微软；</p>
<p>l Sybase：赛尔斯；</p>
<p>l MySQL：甲骨文；</p>
<p> </p>
<p>1.4理解数据库</p>
<p>l RDBMS = 管理员（manager）+仓库（database）</p>
<p>l database = N个table</p>
<p>l table：</p>
<p>Ø 表结构：定义表的列名和列类型！</p>
<p>Ø 表记录：一行一行的记录！</p>
<p> </p>
<p> </p>
<p>我们现在所说的数据库泛指“关系型数据库管理系统（RDBMS - Relational database management system）”，即“数据库服务器”。</p>
<p>当我们安装了数据库服务器后，就可以在数据库服务器中创建数据库，每个数据库中还可以包含多张表。</p>
<p> </p>
<p>数据库表就是一个多行多列的表格。在创建表时，需要指定表的列数，以及列名称，列类型等信息。而不用指定表格的行数，行数是没有上限的。下面是tab_student表的结构：</p>
<p> </p>
<p> </p>
<p>当把表格创建好了之后，就可以向表格中添加数据了。向表格添加数据是以行为单位的！下面是s_student表的记录：</p>
<p> </p>
<table>
<thead>
<tr>
<th>s_id</th>
<th>s_name</th>
<th>s_age</th>
<th>s_sex</th>
</tr>
</thead>
<tbody><tr>
<td>S_1001</td>
<td>zhangSan</td>
<td>23</td>
<td>male</td>
</tr>
<tr>
<td>S_1002</td>
<td>liSi</td>
<td>32</td>
<td>female</td>
</tr>
<tr>
<td>S_1003</td>
<td>wangWu</td>
<td>44</td>
<td>male</td>
</tr>
</tbody></table>
<p> </p>
<p>大家要学会区分什么是表结构，什么是表记录。</p>
<p> </p>
<p>1.5应用程序与数据库</p>
<p>应用程序使用数据库完成对数据的存储！</p>
<p> </p>
<p>2安装MySQL数据库</p>
<p>2.1安装MySQL</p>
<p>参考：MySQL安装图解.doc</p>
<p> </p>
<p>2.2MySQL目录结构</p>
<p>MySQL的数据存储目录为data，data目录通常在C:\Documents and Settings\All Users\Application Data\MySQL\MySQL Server 5.1\data位置。在data下的每个目录都代表一个数据库。</p>
<p>MySQL的安装目录下：</p>
<p>l bin目录中都是可执行文件；</p>
<p>l my.ini文件是MySQL的配置文件；</p>
<p> </p>
<p>3基本命令</p>
<p>3.1启动和关闭mysql服务器</p>
<p>l 启动：net start mysql；</p>
<p>l 关闭：net stop mysql；</p>
<p> </p>
<p>在启动mysql服务后，打开windows任务管理器，会有一个名为mysqld.exe的进程运行，所以mysqld.exe才是MySQL服务器程序。</p>
<p> </p>
<p>3.2客户端登录退出mysql</p>
<p>在启动MySQL服务器后，我们需要使用管理员用户登录MySQL服务器，然后来对服务器进行操作。登录MySQL需要使用MySQL的客户端程序：mysql.exe</p>
<p>l 登录：mysql -u root -p 123 -h localhost；</p>
<p>Ø -u：后面的root是用户名，这里使用的是超级管理员root；</p>
<p>Ø -p：后面的123是密码，这是在安装MySQL时就已经指定的密码；</p>
<p>Ø -h：后面给出的localhost是服务器主机名，它是可以省略的，例如：mysql -u root -p 123；</p>
<p>l 退出：quit或exit；</p>
<p> </p>
<p>在登录成功后，打开windows任务管理器，会有一个名为mysql.exe的进程运行，所以mysql.exe是客户端程序。</p>
<p> </p>
<p>SQL语句</p>
<p> </p>
<p>1 SQL概述</p>
<p>1.1什么是SQL</p>
<p>SQL（Structured Query Language）是“结构化查询语言”，它是对关系型数据库的操作语言。它可以应用到所有关系型数据库中，例如：MySQL、Oracle、SQL Server等。SQ标准（ANSI/ISO）有：</p>
<p>l SQL-92：1992年发布的SQL语言标准；</p>
<p>l SQL:1999：1999年发布的SQL语言标签；</p>
<p>l SQL:2003：2003年发布的SQL语言标签；</p>
<p> </p>
<p>这些标准就与JDK的版本一样，在新的版本中总要有一些语法的变化。不同时期的数据库对不同标准做了实现。</p>
<p>虽然SQL可以用在所有关系型数据库中，但很多数据库还都有标准之后的一些语法，我们可以称之为“方言”。例如MySQL中的LIMIT语句就是MySQL独有的方言，其它数据库都不支持！当然，Oracle或SQL Server都有自己的方言。</p>
<p> </p>
<p>1.2语法要求</p>
<p>l SQL语句可以单行或多行书写，以分号结尾；</p>
<p>l 可以用空格和缩进来来增强语句的可读性；</p>
<p>l 关键字不区别大小写，建议使用大写；</p>
<p> </p>
<p>2分类</p>
<p>l DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</p>
<p>l DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</p>
<p>l DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</p>
<p>l DQL（Data Query Language）：数据查询语言，用来查询记录（数据）。</p>
<p> </p>
<p>3DDL</p>
<p>3.1基本操作</p>
<p>l 查看所有数据库名称：SHOW DATABASES；</p>
<p>l 切换数据库：USE mydb1，切换到mydb1数据库；</p>
<p>3.2操作数据库</p>
<p>l 创建数据库：CREATE DATABASE [IF NOT EXISTS] mydb1；</p>
<p>创建数据库，例如：CREATE DATABASE mydb1，创建一个名为mydb1的数据库。如果这个数据已经存在，那么会报错。例如CREATE DATABASE IF NOT EXISTS mydb1，在名为mydb1的数据库不存在时创建该库，这样可以避免报错。</p>
<p> </p>
<p>l 删除数据库：DROP DATABASE [IF EXISTS] mydb1；</p>
<p>删除数据库，例如：DROP DATABASE mydb1，删除名为mydb1的数据库。如果这个数据库不存在，那么会报错。DROP DATABASE IF EXISTS mydb1，就算mydb1不存在，也不会的报错。</p>
<p> </p>
<p>l 修改数据库编码：ALTER DATABASE mydb1 CHARACTER SET utf8</p>
<p>修改数据库mydb1的编码为utf8。注意，在MySQL中所有的UTF-8编码都不能使用中间的“-”，即UTF-8要书写为UTF8。</p>
<p> </p>
<p>3.3数据类型</p>
<p>MySQL与Java一样，也有数据类型。MySQL中数据类型主要应用在列上。</p>
<p> </p>
<p>常用类型：</p>
<p>l int：整型</p>
<p>l double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；</p>
<p>l decimal：泛型型，在表单钱方面使用该类型，因为不会出现精度缺失问题；</p>
<p>l char：固定长度字符串类型；</p>
<p>l varchar：可变长度字符串类型；</p>
<p>l text：字符串类型；</p>
<p>l blob：字节类型；</p>
<p>l date：日期类型，格式为：yyyy-MM-dd；</p>
<p>l time：时间类型，格式为：hh:mm:ss</p>
<p>l timestamp：时间戳类型；</p>
<p> </p>
<p>3.4操作表</p>
<p>l 创建表：</p>
<p>CREATE TABLE 表名(</p>
<p>  列名 列类型,</p>
<p>  列名 列类型,</p>
<p>  ……</p>
<p>);</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CREATE TABLE stu(<br>sid    CHAR(6),<br>snameVARCHAR(20),<br>ageINT,<br>genderVARCHAR(10) <br>);</td>
</tr>
</tbody></table>
<p> </p>
<p>再例如：</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CREATE TABLE emp(<br>eidCHAR(6),<br>enameVARCHAR(50),<br>ageINT,<br>genderVARCHAR(6),<br>birthdayDATE,<br>hiredateDATE,<br>salaryDECIMAL(7,2),<br>resumeVARCHAR(1000)<br>);</td>
</tr>
</tbody></table>
<p> </p>
<p>l 查看当前数据库中所有表名称：SHOW TABLES；</p>
<p>l 查看指定表的创建语句：SHOW CREATE TABLE emp，查看emp表的创建语句；</p>
<p>l 查看表结构：DESC emp，查看emp表结构；</p>
<p>l 删除表：DROP TABLE emp，删除emp表；</p>
<p>l 修改表：</p>
<p>1. 修改之添加列：给stu表添加classname列：</p>
<p>ALTER TABLE stu ADD (classname varchar(100));</p>
<p>2. 修改之修改列类型：修改stu表的gender列类型为CHAR(2)：</p>
<p>ALTER TABLE stu MODIFY gender CHAR(2);</p>
<p>3. 修改之修改列名：修改stu表的gender列名为sex：</p>
<p>ALTER TABLE stu change gender sex CHAR(2);</p>
<p>4. 修改之删除列：删除stu表的classname列：</p>
<p>ALTER TABLE stu DROP classname;</p>
<p>5. 修改之修改表名称：修改stu表名称为student：</p>
<p>ALTER TABLE stu RENAME TO student;</p>
<p> </p>
<p>4DML</p>
<p>4.1插入数据</p>
<p>语法：</p>
<p>INSERT INTO 表名(列名1,列名2, …) VALUES(值1, 值2)</p>
<table>
<thead>
<tr>
<th>INSERT INTO stu(sid, sname,age,gender) VALUES(‘s_1001’, ‘zhangSan’, 23, ‘male’);</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT INTO stu(sid, sname) VALUES(‘s_1001’, ‘zhangSan’);</td>
</tr>
</tbody></table>
<p> </p>
<p>语法：</p>
<p>INSERT INTO 表名 VALUES(值1,值2,…)</p>
<p>因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>INSERT INTO stu VALUES(‘s_1002’, ‘liSi’, 32, ‘female’);</td>
</tr>
</tbody></table>
<p> </p>
<p>注意：所有字符串数据必须使用单引用！</p>
<p> </p>
<p>4.2修改数据</p>
<p>语法：</p>
<p>UPDATE 表名 SET 列名1=值1, … 列名n=值n [WHERE 条件]</p>
<table>
<thead>
<tr>
<th>UPDATE stu SET sname=’zhangSanSan’, age=’32’, gender=’female’ WHERE sid=’s_1001’;</th>
</tr>
</thead>
<tbody><tr>
<td>UPDATE stu SET sname=’liSi’, age=’20’ WHERE age&gt;50 AND gender=’male’;</td>
</tr>
<tr>
<td>UPDATE stu SET sname=’wangWu’, age=’30’ WHERE age&gt;60 OR gender=’female’;</td>
</tr>
<tr>
<td>UPDATE stu SET gender=’female’ WHERE gender IS NULL<br>UPDATE stu SET age=age+1 WHERE sname=’zhaoLiu’;</td>
</tr>
</tbody></table>
<p> </p>
<p>4.3删除数据</p>
<p>语法：</p>
<p>DELETE FROM 表名 [WHERE 条件]</p>
<table>
<thead>
<tr>
<th>DELETE FROM stu WHERE sid=’s_1001’003B</th>
</tr>
</thead>
<tbody><tr>
<td>DELETE FROM stu WHERE sname=’chenQi’ OR age &gt; 30;</td>
</tr>
<tr>
<td>DELETE FROM stu;</td>
</tr>
</tbody></table>
<p> </p>
<p>语法：</p>
<p>TRUNCATE TABLE 表名</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>TRUNCATE TABLE stu;</td>
</tr>
</tbody></table>
<p> </p>
<p>虽然TRUNCATE和DELETE都可以删除表的所有记录，但有原理不同。DELETE的效率没有TRUNCATE高！</p>
<p>TRUNCATE其实属性DDL语句，因为它是先DROP TABLE，再CREATE TABLE。而且TRUNCATE删除的记录是无法回滚的，但DELETE删除的记录是可以回滚的（回滚是事务的知识！）。</p>
<p> </p>
<p>5DCL</p>
<p>5.1创建用户</p>
<p>语法：</p>
<p>CREATE USER 用户名@地址 IDENTIFIED BY ‘密码’;</p>
<table>
<thead>
<tr>
<th>CREATE USER user1@localhost IDENTIFIED BY &apos;123’;</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE USER user2@’%’ IDENTIFIED BY &apos;123’;</td>
</tr>
</tbody></table>
<p> </p>
<p>5.2给用户授权</p>
<p>语法：</p>
<p>GRANT 权限1, … , 权限n ON 数据库.* TO 用户名</p>
<table>
<thead>
<tr>
<th>GRANT CREATE,ALTER,DROP,INSERT,UPDATE,DELETE,SELECT ON mydb1.* TO user1@localhost;</th>
</tr>
</thead>
<tbody><tr>
<td>GRANT ALL ON mydb1.* TO user2@localhost;</td>
</tr>
</tbody></table>
<p> </p>
<p>5.3撤销授权</p>
<p>语法：</p>
<p>REVOKE权限1, … , 权限n ON 数据库.* FORM 用户名</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>REVOKE CREATE,ALTER,DROP ON mydb1.* FROM user1@localhost;</td>
</tr>
</tbody></table>
<p> </p>
<p>5.4查看用户权限</p>
<p>语法：</p>
<p>SHOW GRANTS FOR 用户名</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SHOW GRANTS FOR user1@localhost;</td>
</tr>
</tbody></table>
<p> </p>
<p>5.5删除用户</p>
<p>语法：</p>
<p>DROP USER 用户名</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>DROP USER user1@localhost;</td>
</tr>
</tbody></table>
<p> </p>
<p>5.6修改用户密码</p>
<p>语法：</p>
<p>USE mysql;</p>
<p>UPDATE USER SET PASSWORD=PASSWORD(‘密码’) WHERE User=’用户名’ and Host=’IP’;</p>
<p>FLUSH PRIVILEGES;</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>UPDATE USER SET PASSWORD=PASSWORD(‘1234’) WHERE User=’user2’ and Host=’localhost’;<br>FLUSH PRIVILEGES;</td>
</tr>
</tbody></table>
<p> </p>
<p>数据查询语法（DQL）</p>
<p>DQL就是数据查询语言，数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。</p>
<p>语法：</p>
<p>SELECT selection_list /<em>要查询的列名称</em>/</p>
<p>  FROM table_list /<em>要查询的表名称</em>/</p>
<p>  WHERE condition /<em>行条件</em>/</p>
<p>  GROUP BY grouping_columns /<em>对结果分组</em>/</p>
<p>  HAVING condition /<em>分组后的行条件</em>/</p>
<p>  ORDER BY sorting_columns /<em>对结果分组</em>/</p>
<p>  LIMIT offset_start, row_count /<em>结果限定</em>/</p>
<p> </p>
<p>创建名：</p>
<p>l 学生表：stu</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sid</td>
<td>char(6)</td>
<td>学生学号</td>
</tr>
<tr>
<td>sname</td>
<td>varchar(50)</td>
<td>学生姓名</td>
</tr>
<tr>
<td>age</td>
<td>int</td>
<td>学生年龄</td>
</tr>
<tr>
<td>gender</td>
<td>varchar(50)</td>
<td>学生性别</td>
</tr>
</tbody></table>
<p> </p>
<table>
<thead>
<tr>
<th>CREATE TABLE stu (<br>sidCHAR(6),<br>snameVARCHAR(50),<br>ageINT,<br>genderVARCHAR(50)<br>);</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT INTO stu VALUES(‘S_1001’, ‘liuYi’, 35, ‘male’);<br>INSERT INTO stu VALUES(‘S_1002’, ‘chenEr’, 15, ‘female’);<br>INSERT INTO stu VALUES(‘S_1003’, ‘zhangSan’, 95, ‘male’);<br>INSERT INTO stu VALUES(‘S_1004’, ‘liSi’, 65, ‘female’);<br>INSERT INTO stu VALUES(‘S_1005’, ‘wangWu’, 55, ‘male’);<br>INSERT INTO stu VALUES(‘S_1006’, ‘zhaoLiu’, 75, ‘female’);<br>INSERT INTO stu VALUES(‘S_1007’, ‘sunQi’, 25, ‘male’);<br>INSERT INTO stu VALUES(‘S_1008’, ‘zhouBa’, 45, ‘female’);<br>INSERT INTO stu VALUES(‘S_1009’, ‘wuJiu’, 85, ‘male’);<br>INSERT INTO stu VALUES(‘S_1010’, ‘zhengShi’, 5, ‘female’);<br>INSERT INTO stu VALUES(‘S_1011’, ‘xxx’, NULL, NULL);</td>
</tr>
</tbody></table>
<p> </p>
<p>l 雇员表：emp</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>empno</td>
<td>int</td>
<td>员工编号</td>
</tr>
<tr>
<td>ename</td>
<td>varchar(50)</td>
<td>员工姓名</td>
</tr>
<tr>
<td>job</td>
<td>varchar(50)</td>
<td>员工工作</td>
</tr>
<tr>
<td>mgr</td>
<td>int</td>
<td>领导编号</td>
</tr>
<tr>
<td>hiredate</td>
<td>date</td>
<td>入职日期</td>
</tr>
<tr>
<td>sal</td>
<td>decimal(7,2)</td>
<td>月薪</td>
</tr>
<tr>
<td>comm</td>
<td>decimal(7,2)</td>
<td>奖金</td>
</tr>
<tr>
<td>deptno</td>
<td>int</td>
<td>部分编号</td>
</tr>
</tbody></table>
<p> </p>
<table>
<thead>
<tr>
<th>CREATE TABLE emp(<br>empnoINT,<br>enameVARCHAR(50),<br>jobVARCHAR(50),<br>mgrINT,<br>hiredateDATE,<br>salDECIMAL(7,2),<br>commdecimal(7,2),<br>deptnoINT<br>) ;</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT INTO emp values(7369,’SMITH’,’CLERK’,7902,’1980-12-17’,800,NULL,20);<br>INSERT INTO emp values(7499,’ALLEN’,’SALESMAN’,7698,’1981-02-20’,1600,300,30);<br>INSERT INTO emp values(7521,’WARD’,’SALESMAN’,7698,’1981-02-22’,1250,500,30);<br>INSERT INTO emp values(7566,’JONES’,’MANAGER’,7839,’1981-04-02’,2975,NULL,20);<br>INSERT INTO emp values(7654,’MARTIN’,’SALESMAN’,7698,’1981-09-28’,1250,1400,30);<br>INSERT INTO emp values(7698,’BLAKE’,’MANAGER’,7839,’1981-05-01’,2850,NULL,30);<br>INSERT INTO emp values(7782,’CLARK’,’MANAGER’,7839,’1981-06-09’,2450,NULL,10);<br>INSERT INTO emp values(7788,’SCOTT’,’ANALYST’,7566,’1987-04-19’,3000,NULL,20);<br>INSERT INTO emp values(7839,’KING’,’PRESIDENT’,NULL,’1981-11-17’,5000,NULL,10);<br>INSERT INTO emp values(7844,’TURNER’,’SALESMAN’,7698,’1981-09-08’,1500,0,30);<br>INSERT INTO emp values(7876,’ADAMS’,’CLERK’,7788,’1987-05-23’,1100,NULL,20);<br>INSERT INTO emp values(7900,’JAMES’,’CLERK’,7698,’1981-12-03’,950,NULL,30);<br>INSERT INTO emp values(7902,’FORD’,’ANALYST’,7566,’1981-12-03’,3000,NULL,20);<br>INSERT INTO emp values(7934,’MILLER’,’CLERK’,7782,’1982-01-23’,1300,NULL,10);</td>
</tr>
</tbody></table>
<p> </p>
<p>l 部分表：dept</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>字段类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>deptno</td>
<td>int</td>
<td>部分编码</td>
</tr>
<tr>
<td>dname</td>
<td>varchar(50)</td>
<td>部分名称</td>
</tr>
<tr>
<td>loc</td>
<td>varchar(50)</td>
<td>部分所在地点</td>
</tr>
</tbody></table>
<p> </p>
<table>
<thead>
<tr>
<th>CREATE TABLE dept(<br>deptnoINT,<br>dnamevarchar(14),<br>locvarchar(13)<br>);</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT INTO dept values(10, ‘ACCOUNTING’, ‘NEW YORK’);<br>INSERT INTO dept values(20, ‘RESEARCH’, ‘DALLAS’);<br>INSERT INTO dept values(30, ‘SALES’, ‘CHICAGO’);<br>INSERT INTO dept values(40, ‘OPERATIONS’, ‘BOSTON’);</td>
</tr>
</tbody></table>
<p> </p>
<p>1基础查询</p>
<p>1.1查询所有列</p>
<p>SELECT * FROM stu;</p>
<p> </p>
<p>1.2查询指定列</p>
<p>SELECT sid, sname, age FROM stu;</p>
<p> </p>
<p>2条件查询</p>
<p>2.1条件查询介绍</p>
<p>条件查询就是在查询时给出WHERE子句，在WHERE子句中可以使用如下运算符及关键字：</p>
<p>l =、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</p>
<p>l BETWEEN…AND；</p>
<p>l IN(set)；</p>
<p>l IS NULL；</p>
<p>l AND；</p>
<p>l OR；</p>
<p>l NOT；</p>
<p> </p>
<p>2.2查询性别为女，并且年龄50的记录</p>
<p>SELECT * FROM stu </p>
<p>WHERE gender=’female’ AND ge&lt;50;</p>
<p> </p>
<p>2.3查询学号为S_1001，或者姓名为liSi的记录</p>
<p>SELECT * FROM stu </p>
<p>WHERE sid =’S_1001’ OR sname=’liSi’;</p>
<p> </p>
<p>2.4查询学号为S_1001，S_1002，S_1003的记录</p>
<p>SELECT * FROM stu </p>
<p>WHERE sid IN (‘S_1001’,’S_1002’,’S_1003’);</p>
<p> </p>
<p>2.5查询学号不是S_1001，S_1002，S_1003的记录</p>
<p>SELECT * FROM tab_student </p>
<p>WHERE s_number NOT IN (‘S_1001’,’S_1002’,’S_1003’);</p>
<p> </p>
<p>2.6查询年龄为null的记录</p>
<p>SELECT * FROM stu</p>
<p>WHERE age IS NULL;</p>
<p> </p>
<p>2.7查询年龄在20到40之间的学生记录</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE age&gt;=20 AND age&lt;=40;</p>
<p>或者</p>
<p>SELECT * </p>
<p>FROM stu </p>
<p>WHERE age BETWEEN 20 AND 40;</p>
<p> </p>
<p>2.8查询性别非男的学生记录</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE gender!=’male’;</p>
<p>或者</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE gender&lt;&gt;’male’;</p>
<p>或者</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE NOT gender=’male’;</p>
<p> </p>
<p>2.9查询姓名不为null的学生记录</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE NOT sname IS NULL;</p>
<p>或者</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE sname IS NOT NULL;</p>
<p> </p>
<p>3模糊查询</p>
<p>当想查询姓名中包含a字母的学生时就需要使用模糊查询了。模糊查询需要使用关键字LIKE。</p>
<p>3.1查询姓名由5个字母构成的学生记录</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE sname LIKE ‘_____’;</p>
<p>模糊查询必须使用LIKE关键字。其中 “_”匹配任意一个字母，5个“_”表示5个任意字母。</p>
<p> </p>
<p>3.2查询姓名由5个字母构成，并且第5个字母为“i”的学生记录</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE sname LIKE ‘____i’;</p>
<p> </p>
<p>3.3查询姓名以“z”开头的学生记录</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE sname LIKE ‘z%’;</p>
<p>其中“%”匹配0~n个任何字母。</p>
<p> </p>
<p>3.4查询姓名中第2个字母为“i”的学生记录</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE sname LIKE ‘_i%’;</p>
<p> </p>
<p>3.5查询姓名中包含“a”字母的学生记录</p>
<p>SELECT * </p>
<p>FROM stu</p>
<p>WHERE sname LIKE ‘%a%’;</p>
<p> </p>
<p>4字段控制查询</p>
<p>4.1去除重复记录</p>
<p>去除重复记录（两行或两行以上记录中系列的上的数据都相同），例如emp表中sal字段就存在相同的记录。当只查询emp表的sal字段时，那么会出现重复记录，那么想去除重复记录，需要使用DISTINCT：</p>
<p>SELECT DISTINCT sal FROM emp;</p>
<p> </p>
<p>4.2查看雇员的月薪与佣金之和</p>
<p>因为sal和comm两列的类型都是数值类型，所以可以做加运算。如果sal或comm中有一个字段不是数值类型，那么会出错。</p>
<p>SELECT *,sal+comm FROM emp;</p>
<p> </p>
<p>comm列有很多记录的值为NULL，因为任何东西与NULL相加结果还是NULL，所以结算结果可能会出现NULL。下面使用了把NULL转换成数值0的函数IFNULL：</p>
<p>SELECT *,sal+IFNULL(comm,0) FROM emp;</p>
<p> </p>
<p>4.3给列名添加别名</p>
<p>在上面查询中出现列名为sal+IFNULL(comm,0)，这很不美观，现在我们给这一列给出一个别名，为total：</p>
<p>SELECT *, sal+IFNULL(comm,0) AS total FROM emp;</p>
<p>给列起别名时，是可以省略AS关键字的：</p>
<p>SELECT *,sal+IFNULL(comm,0) total FROM emp;</p>
<p> </p>
<p>5排序</p>
<p>5.1查询所有学生记录，按年龄升序排序</p>
<p>SELECT *</p>
<p>FROM stu</p>
<p>ORDER BY sage ASC;</p>
<p>或者</p>
<p>SELECT *</p>
<p>FROM stu</p>
<p>ORDER BY sage;</p>
<p> </p>
<p>5.2查询所有学生记录，按年龄降序排序</p>
<p>SELECT *</p>
<p>FROM stu</p>
<p>ORDER BY age DESC;</p>
<p> </p>
<p>5.3查询所有雇员，按月薪降序排序，如果月薪相同时，按编号升序排序</p>
<p>SELECT * FROM emp</p>
<p>ORDER BY sal DESC,empno ASC;</p>
<p> </p>
<p>6聚合函数</p>
<p>聚合函数是用来做纵向运算的函数：</p>
<p>l COUNT()：统计指定列不为NULL的记录行数；</p>
<p>l MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</p>
<p>l MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</p>
<p>l SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</p>
<p>l AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</p>
<p> </p>
<p>6.1COUNT</p>
<p>当需要纵向统计时可以使用COUNT()。</p>
<p>l 查询emp表中记录数：</p>
<p>SELECT COUNT(*) AS cnt FROM emp;</p>
<p> </p>
<p>l 查询emp表中有佣金的人数：</p>
<p>SELECT COUNT(comm) cnt FROM emp;</p>
<p>注意，因为count()函数中给出的是comm列，那么只统计comm列非NULL的行数。</p>
<p> </p>
<p>l 查询emp表中月薪大于2500的人数：</p>
<p>SELECT COUNT(*) FROM emp</p>
<p>WHERE sal &gt; 2500;</p>
<p> </p>
<p>l 统计月薪与佣金之和大于2500元的人数：</p>
<p>SELECT COUNT(*) AS cnt FROM emp WHERE sal+IFNULL(comm,0) &gt; 2500;</p>
<p> </p>
<p>l 查询有佣金的人数，以及有领导的人数：</p>
<p>SELECT COUNT(comm), COUNT(mgr) FROM emp;</p>
<p> </p>
<p>6.2SUM和AVG</p>
<p>当需要纵向求和时使用sum()函数。</p>
<p>l 查询所有雇员月薪和：</p>
<p>SELECT SUM(sal) FROM emp;</p>
<p> </p>
<p>l 查询所有雇员月薪和，以及所有雇员佣金和：</p>
<p>SELECT SUM(sal), SUM(comm) FROM emp;</p>
<p> </p>
<p>l 查询所有雇员月薪+佣金和：</p>
<p>SELECT SUM(sal+IFNULL(comm,0)) FROM emp;</p>
<p> </p>
<p>l 统计所有员工平均工资：</p>
<p>SELECT SUM(sal), COUNT(sal) FROM emp;</p>
<p>或者</p>
<p>SELECT AVG(sal) FROM emp;</p>
<p> </p>
<p>6.3MAX和MIN</p>
<p>l 查询最高工资和最低工资：</p>
<p>SELECT MAX(sal), MIN(sal) FROM emp;</p>
<p> </p>
<p>7分组查询</p>
<p> </p>
<p>当需要分组查询时需要使用GROUP BY子句，例如查询每个部门的工资和，这说明要使用部分来分组。</p>
<p> </p>
<p>7.1分组查询</p>
<p>l 查询每个部门的部门编号和每个部门的工资和：</p>
<p>SELECT deptno, SUM(sal)</p>
<p>FROM emp</p>
<p>GROUP BY deptno;</p>
<p> </p>
<p>l 查询每个部门的部门编号以及每个部门的人数：</p>
<p>SELECT deptno,COUNT(*)</p>
<p>FROM emp</p>
<p>GROUP BY deptno;</p>
<p> </p>
<p>l 查询每个部门的部门编号以及每个部门工资大于1500的人数：</p>
<p>SELECT deptno,COUNT(*)</p>
<p>FROM emp</p>
<p>WHERE sal&gt;1500</p>
<p>GROUP BY deptno;</p>
<p> </p>
<p>7.2HAVING子句</p>
<p>l 查询工资总和大于9000的部门编号以及工资和：</p>
<p>SELECT deptno, SUM(sal)</p>
<p>FROM emp</p>
<p>GROUP BY deptno</p>
<p>HAVING SUM(sal) &gt; 9000;</p>
<p> </p>
<p>注意，WHERE是对分组前记录的条件，如果某行记录没有满足WHERE子句的条件，那么这行记录不会参加分组；而HAVING是对分组后数据的约束。</p>
<p> </p>
<p>8LIMIT</p>
<p>LIMIT用来限定查询结果的起始行，以及总行数。</p>
<p> </p>
<p>8.1查询5行记录，起始行从0开始</p>
<p>SELECT * FROM emp LIMIT 0, 5;</p>
<p> </p>
<p>注意，起始行从0开始，即第一行开始！</p>
<p> </p>
<p>8.2查询10行记录，起始行从3开始</p>
<p>SELECT * FROM emp LIMIT 3, 10;</p>
<p> </p>
<p>8.3分页查询</p>
<p>如果一页记录为10条，希望查看第3页记录应该怎么查呢？</p>
<p>l 第一页记录起始行为0，一共查询10行；</p>
<p>l 第二页记录起始行为10，一共查询10行；</p>
<p>l 第三页记录起始行为20，一共查询10行；</p>
<p> </p>
<p>完整性约束</p>
<p>完整性约束是为了表的数据的正确性！如果数据不正确，那么一开始就不能添加到表中。</p>
<p> </p>
<p>1主键</p>
<p>当某一列添加了主键约束后，那么这一列的数据就不能重复出现。这样每行记录中其主键列的值就是这一行的唯一标识。例如学生的学号可以用来做唯一标识，而学生的姓名是不能做唯一标识的，因为学习有可能同名。</p>
<p>主键列的值不能为NULL，也不能重复！</p>
<p>指定主键约束使用PRIMARY KEY关键字</p>
<p> </p>
<p>l 创建表：定义列时指定主键：</p>
<p>CREATE TABLE stu(</p>
<p>sid    CHAR(6) PRIMARY KEY,</p>
<p>snameVARCHAR(20),</p>
<p>ageINT,</p>
<p>genderVARCHAR(10) </p>
<p>);</p>
<p>l 创建表：定义列之后独立指定主键：</p>
<p> </p>
<p>CREATE TABLE stu(</p>
<p>sid    CHAR(6),</p>
<p>snameVARCHAR(20),</p>
<p>ageINT,</p>
<p>genderVARCHAR(10),</p>
<p>PRIMARY KEY(sid)</p>
<p>);</p>
<p> </p>
<p>l 修改表时指定主键：</p>
<p>ALTER TABLE stu</p>
<p>ADD PRIMARY KEY(sid);</p>
<p> </p>
<p>l 删除主键（只是删除主键约束，而不会删除主键列）：</p>
<p>ALTER TABLE stu DROP PRIMARY KEY;</p>
<p> </p>
<p>2主键自增长</p>
<p>MySQL提供了主键自动增长的功能！这样用户就不用再为是否有主键是否重复而烦恼了。当主键设置为自动增长后，在没有给出主键值时，主键的值会自动生成，而且是最大主键值+1，也就不会出现重复主键的可能了。</p>
<p>l 创建表时设置主键自增长（主键必须是整型才可以自增长）：</p>
<p>CREATE TABLE stu(</p>
<p>sid INT PRIMARY KEY AUTO_INCREMENT,</p>
<p>snameVARCHAR(20),</p>
<p>ageINT,</p>
<p>genderVARCHAR(10)</p>
<p>);</p>
<p> </p>
<p>l 修改表时设置主键自增长：</p>
<p>ALTER TABLE stu CHANGE sid sid INT AUTO_INCREMENT;</p>
<p> </p>
<p>l 修改表时删除主键自增长：</p>
<p>ALTER TABLE stu CHANGE sid sid INT;</p>
<p> </p>
<p>3非空</p>
<p>指定非空约束的列不能没有值，也就是说在插入记录时，对添加了非空约束的列一定要给值；在修改记录时，不能把非空列的值设置为NULL。</p>
<p>l 指定非空约束：</p>
<p>CREATE TABLE stu(</p>
<p>sid INT PRIMARY KEY AUTO_INCREMENT,</p>
<p>sname VARCHAR(10) NOT NULL,</p>
<p>ageINT,</p>
<p>genderVARCHAR(10)</p>
<p>);</p>
<p>当为sname字段指定为非空后，在向stu表中插入记录时，必须给sname字段指定值，否则会报错：</p>
<p>INSERT INTO stu(sid) VALUES(1);</p>
<p> </p>
<p>插入的记录中sname没有指定值，所以会报错！</p>
<p> </p>
<p>4唯一</p>
<p>还可以为字段指定唯一约束！当为字段指定唯一约束后，那么字段的值必须是唯一的。这一点与主键相似！例如给stu表的sname字段指定唯一约束：</p>
<p>CREATE TABLE tab_ab(</p>
<p>sid INT PRIMARY KEY AUTO_INCREMENT,</p>
<p>sname VARCHAR(10) UNIQUE</p>
<p>);</p>
<p> </p>
<p>INSERT INTO sname(sid, sname) VALUES(1001, ‘zs’);</p>
<p>INSERT INTO sname(sid, sname) VALUES(1002, ‘zs’);</p>
<p>当两次插入相同的名字时，MySQL会报错！</p>
<p> </p>
<p>5外键</p>
<p>主外键是构成表与表关联的唯一途径！</p>
<p>外键是另一张表的主键！例如员工表与部门表之间就存在关联关系，其中员工表中的部门编号字段就是外键，是相对部门表的外键。</p>
<p>我们再来看BBS系统中：用户表（t_user）、分类表（t_section）、帖子表（t_topic）三者之间的关系。</p>
<p> </p>
<p> </p>
<p>例如在t_section表中sid为1的记录说明有一个分类叫java，版主是t_user表中uid为1的用户，即zs！</p>
<p>例如在t_topic表中tid为2的记录是名字为“Java是咖啡”的帖子，它是java版块的帖子，它的作者是ww。</p>
<p>外键就是用来约束这一列的值必须是另一张表的主键值！！！</p>
<p> </p>
<p>l 创建t_user表，指定uid为主键列：</p>
<p>CREATE TABLE t_user(</p>
<p>uidINT PRIMARY KEY AUTO_INCREMENT,</p>
<p>unameVARCHAR(20) UNIQUE NOT NULL</p>
<p>);</p>
<p> </p>
<p>l 创建t_section表，指定sid为主键列，u_id为相对t_user表的uid列的外键：</p>
<p>CREATE TABLE t_section(</p>
<p>sidINT PRIMARY KEY AUTO_INCREMENT,</p>
<p>snameVARCHAR(30),</p>
<p>u_idINT,</p>
<p>CONSTRAINT fk_t_user FOREIGN KEY(u_id) REFERENCES t_user(uid)</p>
<p>);</p>
<p>l 修改t_section表，指定u_id为相对t_user表的uid列的外键：</p>
<p>ALTER TABLE t_section </p>
<p>ADD CONSTRAINT fk_t_user </p>
<p>FOREIGN KEY(u_id) </p>
<p>REFERENCES t_user(uid);</p>
<p>l 修改t_section表，删除u_id的外键约束：</p>
<p>ALTER TABLE t_section</p>
<p>DROP FOREIGN KEY fk_t_user;</p>
<p> </p>
<p>6表与表之间的关系</p>
<p>l 一对一：例如t_person表和t_card表，即人和身份证。这种情况需要找出主从关系，即谁是主表，谁是从表。人可以没有身份证，但身份证必须要有人才行，所以人是主表，而身份证是从表。设计从表可以有两种方案：</p>
<p>Ø 在t_card表中添加外键列（相对t_user表），并且给外键添加唯一约束；</p>
<p>Ø 给t_card表的主键添加外键约束（相对t_user表），即t_card表的主键也是外键。</p>
<p>l 一对多（多对一）：最为常见的就是一对多！一对多和多对一，这是从哪个角度去看得出来的。t_user和t_section的关系，从t_user来看就是一对多，而从t_section的角度来看就是多对一！这种情况都是在多方创建外键！</p>
<p>l 多对多：例如t_stu和t_teacher表，即一个学生可以有多个老师，而一个老师也可以有多个学生。这种情况通常需要创建中间表来处理多对多关系。例如再创建一张表t_stu_tea表，给出两个外键，一个相对t_stu表的外键，另一个相对t_teacher表的外键。</p>
<p> </p>
<p>编码</p>
<p> </p>
<p>1查看MySQL编码</p>
<p>SHOW VARIABLES LIKE ‘char%’;</p>
<p> </p>
<p>因为当初安装时指定了字符集为UTF8，所以所有的编码都是UTF8。</p>
<p>l character_set_client：你发送的数据必须与client指定的编码一致！！！服务器会使用该编码来解读客户端发送过来的数据；</p>
<p>l character_set_connection：通过该编码与client一致！该编码不会导致乱码！当执行的是查询语句时，客户端发送过来的数据会先转换成connection指定的编码。但只要客户端发送过来的数据与client指定的编码一致，那么转换就不会出现问题；</p>
<p>l character_set_database：数据库默认编码，在创建数据库时，如果没有指定编码，那么默认使用database编码；</p>
<p>l character_set_server：MySQL服务器默认编码；</p>
<p>l character_set_results：响应的编码，即查询结果返回给客户端的编码。这说明客户端必须使用result指定的编码来解码；</p>
<p> </p>
<p>2控制台编码</p>
<p>修改character_set_client、character_set_results、character_set_connection为GBK，就不会出现乱码了。但其实只需要修改character_set_client和character_set_results。</p>
<p> </p>
<p>控制台的编码只能是GBK，而不能修改为UTF8，这就出现一个问题。客户端发送的数据是GBK，而character_set_client为UTF8，这就说明客户端数据到了服务器端后一定会出现乱码。既然不能修改控制台的编码，那么只能修改character_set_client为GBK了。</p>
<p>服务器发送给客户端的数据编码为character_set_result，它如果是UTF8，那么控制台使用GBK解码也一定会出现乱码。因为无法修改控制台编码，所以只能把character_set_result修改为GBK。</p>
<p>l 修改character_set_client变量：set character_set_client=gbk;</p>
<p>l 修改character_set_results变量：set character_set_results=gbk;</p>
<p> </p>
<p>设置编码只对当前连接有效，这说明每次登录MySQL提示符后都要去修改这两个编码，但可以通过修改配置文件来处理这一问题：配置文件路径：D:\Program Files\MySQL\MySQL Server 5.1\ my.ini</p>
<p> </p>
<p> </p>
<p>3MySQL工具</p>
<p>使用MySQL工具是不会出现乱码的，因为它们会每次连接时都修改character_set_client、character_set_results、character_set_connection的编码。这样对my.ini上的配置覆盖了，也就不会出现乱码了。</p>
<p> </p>
<p>MySQL数据库备份与还原</p>
<p> </p>
<p>备份和恢复数据</p>
<p> </p>
<p>1生成SQL脚本</p>
<p>在控制台使用mysqldump命令可以用来生成指定数据库的脚本文本，但要注意，脚本文本中只包含数据库的内容，而不会存在创建数据库的语句！所以在恢复数据时，还需要自已手动创建一个数据库之后再去恢复数据。</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mysqldump –u用户名 –p密码 数据库名&gt;生成的脚本文件路径</td>
</tr>
</tbody></table>
<p> </p>
<p> </p>
<p>现在可以在C盘下找到mydb1.sql文件了！</p>
<p>注意，mysqldump命令是在Windows控制台下执行，无需登录mysql！！！</p>
<p> </p>
<p>2执行SQL脚本</p>
<p>执行SQL脚本需要登录mysql，然后进入指定数据库，才可以执行SQL脚本！！！</p>
<p>执行SQL脚本不只是用来恢复数据库，也可以在平时编写SQL脚本，然后使用执行SQL 脚本来操作数据库！大家都知道，在黑屏下编写SQL语句时，就算发现了错误，可能也不能修改了。所以我建议大家使用脚本文件来编写SQL代码，然后执行之！</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SOURCE C:\mydb1.sql</td>
</tr>
</tbody></table>
<p> </p>
<p> </p>
<p> </p>
<p>注意，在执行脚本时需要先行核查当前数据库中的表是否与脚本文件中的语句有冲突！例如在脚本文件中存在create table a的语句，而当前数据库中已经存在了a表，那么就会出错！</p>
<p> </p>
<p>还可以通过下面的方式来执行脚本文件：</p>
<p>mysql -uroot -p123 mydb1&lt;c:\mydb1.sql</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mysql –u用户名 –p密码 数据库&lt;要执行脚本文件路径</td>
</tr>
</tbody></table>
<p> </p>
<p>这种方式无需登录mysql！</p>
<p> </p>
<p> </p>
<p>多表查询</p>
<p>多表查询有如下几种：</p>
<p>l 合并结果集；</p>
<p>l 连接查询</p>
<p>Ø 内连接</p>
<p>Ø 外连接</p>
<p>² 左外连接</p>
<p>² 右外连接</p>
<p>² 全外连接（MySQL不支持）</p>
<p>Ø 自然连接</p>
<p>l 子查询</p>
<p> </p>
<p>1合并结果集</p>
<p>1. 作用：合并结果集就是把两个select语句的查询结果合并到一起！</p>
<p>2. 合并结果集有两种方式：</p>
<p>l UNION：去除重复记录，例如：SELECT * FROM t1 UNION SELECT * FROM t2；</p>
<p>l UNION ALL：不去除重复记录，例如：SELECT * FROM t1 UNION ALL SELECT * FROM t2。</p>
<p> </p>
<p>3. 要求：被合并的两个结果：列数、列类型必须相同。</p>
<p>2连接查询</p>
<p>连接查询就是求出多个表的乘积，例如t1连接t2，那么查询出的结果就是t1*t2。</p>
<p> </p>
<p> </p>
<p>连接查询会产生笛卡尔积，假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}。可以扩展到多个集合的情况。</p>
<p>那么多表查询产生这样的结果并不是我们想要的，那么怎么去除重复的，不想要的记录呢，当然是通过条件过滤。通常要查询的多个表之间都存在关联关系，那么就通过关联关系去除笛卡尔积。</p>
<p>你能想像到emp和dept表连接查询的结果么？emp一共14行记录，dept表一共4行记录，那么连接后查询出的结果是56行记录。</p>
<p>也就你只是想在查询emp表的同时，把每个员工的所在部门信息显示出来，那么就需要使用主外键来去除无用信息了。</p>
<p> </p>
<p>使用主外键关系做为条件来去除无用信息</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp,dept WHERE emp.deptno=dept.deptno;</td>
</tr>
</tbody></table>
<p> </p>
<p> </p>
<p>上面查询结果会把两张表的所有列都查询出来，也许你不需要那么多列，这时就可以指定要查询的列了。</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT emp.ename,emp.sal,emp.comm,dept.dname <br>FROM emp,dept <br>WHERE emp.deptno=dept.deptno;</td>
</tr>
</tbody></table>
<p> </p>
<p> </p>
<p>还可以为表指定别名，然后在引用列时使用别名即可。</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT e.ename,e.sal,e.comm,d.dname <br>FROM emp AS e,dept AS d<br>WHERE e.deptno=d.deptno;</td>
</tr>
</tbody></table>
<p> </p>
<p>2.1内连接</p>
<p>上面的连接语句就是内连接，但它不是SQL标准中的查询方式，可以理解为方言！SQL标准的内连接为：</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * <br>FROM emp e <br>INNER JOIN dept d <br>ON e.deptno=d.deptno;</td>
</tr>
</tbody></table>
<p> </p>
<p>内连接的特点：查询结果必须满足条件。例如我们向emp表中插入一条记录：</p>
<p>其中deptno为50，而在dept表中只有10、20、30、40部门，那么上面的查询结果中就不会出现“张三”这条记录，因为它不能满足e.deptno=d.deptno这个条件。</p>
<p> </p>
<p>2.2外连接（左连接、右连接）</p>
<p>外连接的特点：查询出的结果存在不满足条件的可能。</p>
<p>左连接：</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp e <br>LEFT OUTER JOIN dept d <br>ON e.deptno=d.deptno;</td>
</tr>
</tbody></table>
<p> </p>
<p>左连接是先查询出左表（即以左表为主），然后查询右表，右表中满足条件的显示出来，不满足条件的显示NULL。</p>
<p>这么说你可能不太明白，我们还是用上面的例子来说明。其中emp表中“张三”这条记录中，部门编号为50，而dept表中不存在部门编号为50的记录，所以“张三”这条记录，不能满足e.deptno=d.deptno这条件。但在左连接中，因为emp表是左表，所以左表中的记录都会查询出来，即“张三”这条记录也会查出，但相应的右表部分显示NULL。</p>
<p> </p>
<p>2.3右连接</p>
<p>右连接就是先把右表中所有记录都查询出来，然后左表满足条件的显示，不满足显示NULL。例如在dept表中的40部门并不存在员工，但在右连接中，如果dept表为右表，那么还是会查出40部门，但相应的员工信息为NULL。</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp e <br>RIGHT OUTER JOIN dept d <br>ON e.deptno=d.deptno;</td>
</tr>
</tbody></table>
<p> </p>
<p> </p>
<p> </p>
<p>连接查询心得：</p>
<p>连接不限与两张表，连接查询也可以是三张、四张，甚至N张表的连接查询。通常连接查询不可能需要整个笛卡尔积，而只是需要其中一部分，那么这时就需要使用条件来去除不需要的记录。这个条件大多数情况下都是使用主外键关系去除。</p>
<p>两张表的连接查询一定有一个主外键关系，三张表的连接查询就一定有两个主外键关系，所以在大家不是很熟悉连接查询时，首先要学会去除无用笛卡尔积，那么就是用主外键关系作为条件来处理。如果两张表的查询，那么至少有一个主外键条件，三张表连接至少有两个主外键条件。</p>
<p> </p>
<p>3自然连接</p>
<p>大家也都知道，连接查询会产生无用笛卡尔积，我们通常使用主外键关系等式来去除它。而自然连接无需你去给出主外键等式，它会自动找到这一等式：</p>
<p>l 两张连接的表中名称和类型完成一致的列作为条件，例如emp和dept表都存在deptno列，并且类型一致，所以会被自然连接找到！</p>
<p>当然自然连接还有其他的查找条件的方式，但其他方式都可能存在问题！</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp NATURAL JOIN dept;<br>SELECT * FROM emp NATURAL LEFT JOIN dept;<br>SELECT * FROM emp NATURAL RIGHT JOIN dept;</td>
</tr>
</tbody></table>
<p> </p>
<p>4子查询</p>
<p>子查询就是嵌套查询，即SELECT中包含SELECT，如果一条语句中存在两个，或两个以上SELECT，那么就是子查询语句了。</p>
<p>l 子查询出现的位置：</p>
<p>Ø where后，作为条件的一部分；</p>
<p>Ø from后，作为被查询的一条表；</p>
<p>l 当子查询出现在where后作为条件时，还可以使用如下关键字：</p>
<p>Ø any</p>
<p>Ø all</p>
<p>l 子查询结果集的形式：</p>
<p>Ø 单行单列（用于条件）</p>
<p>Ø 单行多列（用于条件）</p>
<p>Ø 多行单列（用于条件）</p>
<p>Ø 多行多列（用于表）</p>
<p>练习：</p>
<p>1. 工资高于甘宁的员工。</p>
<p>分析：</p>
<p>查询条件：工资&gt;甘宁工资，其中甘宁工资需要一条子查询。</p>
<p> </p>
<p>第一步：查询甘宁的工资</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT sal FROM emp WHERE ename=’甘宁’</td>
</tr>
</tbody></table>
<p> </p>
<p>第二步：查询高于甘宁工资的员工</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp WHERE sal &gt; (${第一步})</td>
</tr>
</tbody></table>
<p> </p>
<p>结果：</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp WHERE sal &gt; (SELECT sal FROM emp WHERE ename=’甘宁’)</td>
</tr>
</tbody></table>
<p> </p>
<p>l 子查询作为条件</p>
<p>l 子查询形式为单行单列</p>
<p> </p>
<p>2. 工资高于30部门所有人的员工信息</p>
<p>分析：</p>
<p>查询条件：工资高于30部门所有人工资，其中30部门所有人工资是子查询。高于所有需要使用all关键字。</p>
<p> </p>
<p>第一步：查询30部门所有人工资</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT sal FROM emp WHERE deptno=30;</td>
</tr>
</tbody></table>
<p> </p>
<p>第二步：查询高于30部门所有人工资的员工信息</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp WHERE sal &gt; ALL (${第一步})</td>
</tr>
</tbody></table>
<p> </p>
<p>结果：</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp WHERE sal &gt; ALL (SELECT sal FROM emp WHERE deptno=30)</td>
</tr>
</tbody></table>
<p> </p>
<p>l 子查询作为条件</p>
<p>l 子查询形式为多行单列（当子查询结果集形式为多行单列时可以使用ALL或ANY关键字）</p>
<p> </p>
<p>3. 查询工作和工资与殷天正完全相同的员工信息</p>
<p>分析：</p>
<p>查询条件：工作和工资与殷天正完全相同，这是子查询</p>
<p> </p>
<p>第一步：查询出殷天正的工作和工资</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT job,sal FROM emp WHERE ename=’殷天正’</td>
</tr>
</tbody></table>
<p> </p>
<p>第二步：查询出与殷天正工作和工资相同的人</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp WHERE (job,sal) IN (${第一步})</td>
</tr>
</tbody></table>
<p> </p>
<p>结果：</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT * FROM emp WHERE (job,sal) IN (SELECT job,sal FROM emp WHERE ename=’殷天正’)</td>
</tr>
</tbody></table>
<p> </p>
<p>l 子查询作为条件</p>
<p>l 子查询形式为单行多列</p>
<p> </p>
<p>4. 查询员工编号为1006的员工名称、员工工资、部门名称、部门地址</p>
<p>分析：</p>
<p>查询列：员工名称、员工工资、部门名称、部门地址</p>
<p>查询表：emp和dept，分析得出，不需要外连接（外连接的特性：某一行（或某些行）记录上会出现一半有值，一半为NULL值）</p>
<p>条件：员工编号为1006</p>
<p> </p>
<p>第一步：去除多表，只查一张表，这里去除部门表，只查员工表</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT ename, sal FROM emp e WHERE empno=1006</td>
</tr>
</tbody></table>
<p> </p>
<p>第二步：让第一步与dept做内连接查询，添加主外键条件去除无用笛卡尔积</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT e.ename, e.sal, d.dname, d.loc <br>FROM emp e, dept d <br>WHERE e.deptno=d.deptno AND empno=1006</td>
</tr>
</tbody></table>
<p> </p>
<p>第二步中的dept表表示所有行所有列的一张完整的表，这里可以把dept替换成所有行，但只有dname和loc列的表，这需要子查询。</p>
<p>第三步：查询dept表中dname和loc两列，因为deptno会被作为条件，用来去除无用笛卡尔积，所以需要查询它。</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT dname,loc,deptno FROM dept;</td>
</tr>
</tbody></table>
<p> </p>
<p>第四步：替换第二步中的dept</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT e.ename, e.sal, d.dname, d.loc <br>FROM emp e, (SELECT dname,loc,deptno FROM dept) d <br>WHERE e.deptno=d.deptno AND e.empno=1006</td>
</tr>
</tbody></table>
<p> </p>
<p>l 子查询作为表</p>
<p>l 子查询形式为多行多列</p>
<p> </p>
<p> </p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。b,sal FROM emp WHERE ename=’殷天正’) |</p>
<p> </p>
<p>l 子查询作为条件</p>
<p>l 子查询形式为单行多列</p>
<p> </p>
<p>4. 查询员工编号为1006的员工名称、员工工资、部门名称、部门地址</p>
<p>分析：</p>
<p>查询列：员工名称、员工工资、部门名称、部门地址</p>
<p>查询表：emp和dept，分析得出，不需要外连接（外连接的特性：某一行（或某些行）记录上会出现一半有值，一半为NULL值）</p>
<p>条件：员工编号为1006</p>
<p> </p>
<p>第一步：去除多表，只查一张表，这里去除部门表，只查员工表</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT ename, sal FROM emp e WHERE empno=1006</td>
</tr>
</tbody></table>
<p> </p>
<p>第二步：让第一步与dept做内连接查询，添加主外键条件去除无用笛卡尔积</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT e.ename, e.sal, d.dname, d.loc <br>FROM emp e, dept d <br>WHERE e.deptno=d.deptno AND empno=1006</td>
</tr>
</tbody></table>
<p> </p>
<p>第二步中的dept表表示所有行所有列的一张完整的表，这里可以把dept替换成所有行，但只有dname和loc列的表，这需要子查询。</p>
<p>第三步：查询dept表中dname和loc两列，因为deptno会被作为条件，用来去除无用笛卡尔积，所以需要查询它。</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT dname,loc,deptno FROM dept;</td>
</tr>
</tbody></table>
<p> </p>
<p>第四步：替换第二步中的dept</p>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>SELECT e.ename, e.sal, d.dname, d.loc <br>FROM emp e, (SELECT dname,loc,deptno FROM dept) d <br>WHERE e.deptno=d.deptno AND e.empno=1006</td>
</tr>
</tbody></table>
<p> </p>
<p>l 子查询作为表</p>
<p>l 子查询形式为多行多列</p>
<p> </p>
<p> </p>
<p> </p>
<p>已使用 Microsoft OneNote 2016 创建。</p>
]]></content>
      <categories>
        <category>数据持久化</category>
        <category>end</category>
      </categories>
      <tags>
        <tag>数据持久化</tag>
        <tag>end</tag>
      </tags>
  </entry>
  <entry>
    <title>网络工具 -- 带宽测试工具iperf3</title>
    <url>/2023/04/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/%E5%B8%A6%E5%AE%BD%E6%B5%8B%E8%AF%95-iperf3/</url>
    <content><![CDATA[<p><img src="/img/v2-df27fdb147b3cb02c6e37e2b207f8c81_1440w.jpg" alt="img"></p>
<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>官方一点说是用来测量一个网络最大带宽的工具。</p>
<p>个人常用于跑流量、测带宽，以检测一些路由限速规则是否生效，以及线路流量监控是否准确。</p>
<p>iperf支持TCP、UDP协议，默认使用TCP。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><ul>
<li>安装非常简单<code>apt-get install iperf3</code></li>
<li>查看版本<code>iperf3 -v</code></li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>一台公网服务A作为服务端，IP为：139.159.96.26</p>
<ul>
<li><p>开启服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf3 -s -i 10 -p 5201</span><br><span class="line"><span class="comment"># -s 作为服务端运行</span></span><br><span class="line"><span class="comment"># -i 每10s生成一次报告</span></span><br><span class="line"><span class="comment"># -p 端口，默认5201</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-b <span class="comment"># 指定带宽</span></span><br></pre></td></tr></table></figure>



<h3 id="指定测试时间"><a href="#指定测试时间" class="headerlink" title="指定测试时间"></a>指定测试时间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf3 -c 139.159.96.26 -p 5201 -t 5 -P 1 -R</span><br><span class="line"><span class="comment"># -c client</span></span><br><span class="line"><span class="comment"># 139.159.96.26服务端IP</span></span><br><span class="line"><span class="comment"># -p 服务端端口</span></span><br><span class="line"><span class="comment"># -t 传输时间，默认10s</span></span><br><span class="line"><span class="comment"># -P 发送连接数</span></span><br><span class="line"><span class="comment"># -R 表示测试为下载</span></span><br><span class="line"></span><br><span class="line">Connecting to host 139.159.96.26, port 5201</span><br><span class="line">Reverse mode, remote host 139.159.96.26 is sending</span><br><span class="line">[  5] <span class="built_in">local</span> 106.3.133.42 port 44718 connected to 139.159.96.26 port 5201</span><br><span class="line">[ ID] Interval           Transfer     Bitrate</span><br><span class="line">[  5]   0.00-1.00   sec  1.35 MBytes  11.3 Mbits/sec</span><br><span class="line">[  5]   1.00-2.00   sec  1.30 MBytes  10.9 Mbits/sec</span><br><span class="line">[  5]   2.00-3.00   sec  1.29 MBytes  10.8 Mbits/sec</span><br><span class="line">[  5]   3.00-4.00   sec  1.25 MBytes  10.5 Mbits/sec</span><br><span class="line">[  5]   4.00-5.00   sec  1022 KBytes  8.38 Mbits/sec</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line">[ ID] Interval           Transfer     Bitrate         Retr</span><br><span class="line">[  5]   0.00-5.04   sec  7.11 MBytes  11.8 Mbits/sec    9             sender</span><br><span class="line">[  5]   0.00-5.00   sec  6.18 MBytes  10.4 Mbits/sec                  receiver</span><br><span class="line"></span><br><span class="line">iperf Done.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="指定测试流量"><a href="#指定测试流量" class="headerlink" title="指定测试流量"></a>指定测试流量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iperf3 -c 139.159.96.26 -n 0.1G -i 10</span><br><span class="line"><span class="comment"># -n 传输1G数据</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>网络基础</category>
        <category>网络工具</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>网络工具</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下方法 -- 第一章 概论</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="internet概览"><a href="#internet概览" class="headerlink" title="internet概览"></a>internet概览</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li><p>  局域网（local area network，LAN）：一个家庭、公司内部的网络，主要是按照需求进行的划分</p>
</li>
<li><p>  广域网（wide area network，WAN）：广域网的连接范围更大（全世界），局域网是互联主机，广域网是互联交换机、路由器、调解器等设备</p>
</li>
<li><p>互联网络：下图表示了公司的两个分部要进行通讯的网络结构，局域网内消息通过交换机分发，跨境通讯通过路由进行传输，搭建了一个私有互联网<br>  <img src="https://github.com/fireflyso/Img/blob/master/markdown/iShot2021-04-01%2014.17.26.png?raw=true" alt="image"></p>
</li>
<li><p>  路由器：将网络连接到其他网络</p>
</li>
<li><p>  交换机：将设备连接到一起，在过去网络中所有主机连接到一个公共电缆上，这个时候的通讯是广播的方式，目标接收者接收信息，其他主机丢弃数据包，交换机的作用就是帮助识别数据包的接收者，避免出现广播的方式进行传递，减轻了局域网中的流量</p>
</li>
<li><p>  调解器：变换数据类型</p>
</li>
</ul>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>这里直接说网络通过交换机进行连接，有两种交换模型，电路交换和分组交换</p>
<ul>
<li>  电路交换：以前的电话网络常采用电路交换，假如两个交换机各有4个电话，每个电话与交换机连线的容量为1，那么两个交换机之间的数据主线容量是4，这样才能支持4组电话能同时运行</li>
<li>  分组交换：可以看出电路交换其实很浪费主线资源，真实场景下很少能把主线资源占满，分组交换上将要传输的数据进行分组，挨个传输，对于上面的场景，我们只需要一根容量为2的主线，就可以支持，不过如果还是有个4组人同时通讯，会出现延迟</li>
</ul>
<h3 id="internet"><a href="#internet" class="headerlink" title="internet"></a>internet</h3><p>两个或多个互相连接的通讯网络就叫互联网，而internet是其中最出名的</p>
<ul>
<li>  internet服务提供商（Internet Service Provider，ISP）：就是像中国的联通电信，他们搭建了物理链路也就是光纤，普通用户要上网就要付费来使用他们的网络主干道</li>
</ul>
<h3 id="访问internet"><a href="#访问internet" class="headerlink" title="访问internet"></a>访问internet</h3><p>internet运行任何用户接入变成它的一部分，但是普通用户总不能自己去拉网线，所以要花钱让ISP提供服务</p>
<ul>
<li>使用电话网络：由于电话网络是一个更早的链路体系，大多数道电话网络自身已经连接到了Internet，所以可以通过转换电话网络来连接Internet<ul>
<li>  拨号服务：通过调节器将数据转化为语音，在计算机中通过软件拨打ISP的号码来通讯，缺点是速度慢和不能再打电话</li>
<li>  DSL：升级版的电话线路（物理链路升级），允许同时进行语音和数据通讯</li>
</ul>
</li>
<li>  有线电视网络：类似于电话网络，走有线电视的网络连接internet</li>
<li>  无线网络：有线和无线混合的方式，比如Wi-Fi</li>
<li>  直接连接到互联网：大公司可以直接把自己变成一个本地ISP，从线路供应者那里租用高速广域网接入本地ISP，比如几个校区自己搭建一个私有互联网然后介入internet</li>
</ul>
<h3 id="硬件和软件"><a href="#硬件和软件" class="headerlink" title="硬件和软件"></a>硬件和软件</h3><p>上面讲的基本都是物理传输的结构，后面会讲到内部的软件协议</p>
<h2 id="协议分层（protocol-layering）"><a href="#协议分层（protocol-layering）" class="headerlink" title="协议分层（protocol layering）"></a>协议分层（protocol layering）</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>通过两个简单的场景来看什么是协议分层</p>
]]></content>
      <categories>
        <category>网络基础</category>
        <category>自顶向下方法</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>自顶向下方法</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下方法 -- 第一章 计算机网络与因特网</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%9B%A0%E7%89%B9%E7%BD%91/</url>
    <content><![CDATA[<h1 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h1><h2 id="具体构成描述"><a href="#具体构成描述" class="headerlink" title="具体构成描述"></a>具体构成描述</h2><p>一个全世界范围内的计算机网络，但是近些年很多智能终端接入，单纯说是计算机构成的网络不太准确了，所有的接入设备称为主机或端系统</p>
<ul>
<li>  端系统通过通信链路和分组交换机（packet switch）连接到一起；</li>
<li>  通信时发送方端系统将数据分段并在每段加上首部子节形成信息包，这个过程叫做分组，接收方还原数据</li>
<li>  分组交换机收到分组信息，并投递到接收方，常见两个类型的分组交换机-路由器和链路层交换机，路由器常用语网络核心中，链路层交换机通常用于接入网中</li>
</ul>
<h3 id="英特尔网络服务供应商（ISP）"><a href="#英特尔网络服务供应商（ISP）" class="headerlink" title="英特尔网络服务供应商（ISP）"></a>英特尔网络服务供应商（ISP）</h3><p>端系统通过ISP联入因特网，也就是像中国的联通电信之类的，低层的ISP通过高层ISP（国际）进行连接，每个ISP都是独立管理的</p>
<h3 id="协议Protocol"><a href="#协议Protocol" class="headerlink" title="协议Protocol"></a>协议Protocol</h3><ul>
<li>  TCP：传输控制协议</li>
<li>  IP：网际协议，定义了分组在路由器和终端系统之间的传输格式</li>
</ul>
<h2 id="服务描述"><a href="#服务描述" class="headerlink" title="服务描述"></a>服务描述</h2><p>套接字接口 socket：端系统与端系统之间的通讯通过套接字接口完成，socket定义了一系列的接口规范来保证数据能交付给目的地，好比寄信的时候要写邮编地址之类的来保证信能被送达</p>
<h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><ul>
<li>  人类活动类比：先要打招呼吸引到注意力，然后进行对话，一对一；广播的方式与所有人对线，一对多</li>
<li>  网络中不同的协议用于完成不同到通信任务</li>
</ul>
<h1 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h1><p>把因特网相连接的计算机和其他设备称为端系统，也叫主机，又被分为客户端和服务器；</p>
<h2 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h2><h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><p>DSL、电缆、FTTH、拨号和卫星</p>
<h3 id="企业（和家庭）接入"><a href="#企业（和家庭）接入" class="headerlink" title="企业（和家庭）接入"></a>企业（和家庭）接入</h3><p>以太网和WIFI</p>
<h3 id="广域网无线接入"><a href="#广域网无线接入" class="headerlink" title="广域网无线接入"></a>广域网无线接入</h3><p>3G和LTE</p>
<h2 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h2><p>比特从源到目的地传输需要的物理媒体，分为两种：导引型媒体（固体）和非导引型媒体（空气或外层空间）</p>
<h3 id="双绞铜线"><a href="#双绞铜线" class="headerlink" title="双绞铜线"></a>双绞铜线</h3><p>最便宜最常用的导引型传输媒体，以前的电话网，现在家里用的网线都是这个东西；它对比特的传输速率是低于光纤的，但是成本更低，且现代的双绞线技术也能达到短距离内的高速率传输</p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p>与双绞线类似</p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>是一种细而柔软能够引导光脉冲的媒体，能够支持极高的比特速率数十甚至数百Gbps，且远距离传输信号衰减极低，就是成本高，所以基本是用于长途导引，局域网还是用上面说到的媒体</p>
<h3 id="陆地无线电通道"><a href="#陆地无线电通道" class="headerlink" title="陆地无线电通道"></a>陆地无线电通道</h3><p>不需要物理设备，短距离的如蓝牙、中距离的WiFi、长距离的手机移动网络</p>
<h3 id="卫星无线电通道"><a href="#卫星无线电通道" class="headerlink" title="卫星无线电通道"></a>卫星无线电通道</h3><p>近地轨道上与地面保持相对静止的卫星形成的通信网，目前还未用于接入因特网</p>
<h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><p>由互联因特网端系统的分组交换机和链路构成的网状网络</p>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>端系统之间交换的信息被叫做报文（message），这里面包含了协议和数据，报文在传输的时候会被划分为较小的块，叫做分组，源和目的地之间通过通信链路和分组交换机（路由器和链路层交换机）进行传输</p>
<p>我们要先定义一下，一个L比特的分组，在传输速率为R比特每秒的链路上传输时间为L/R</p>
<h3 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h3><p>多数的分组交换机使用这种传输方式，即交换机要先收到整个分组，然后才会开始将这个分组推往下一个节点</p>
<p>结合上面说的分组传输耗时，来看一下 源–交换机–目的地，这个过程中一个分组从源到交换机需要L/R秒，交换机到目的地又需要L/R秒，共计2L/R秒，即n条链路所需时间为nL/R，当然一个报文可能有p个分组</p>
<h3 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h3><ul>
<li><p>  排队时延：上面说到了，分组交换机需要将整个分组拿到后才会向后传输，也就是它会有一个缓存来放数据，如果交换机向后传输的链路正被别的分组传输占用，那么后来的分组就只能进行等待，也就是说除了传输延时还有排队时延</p>
</li>
<li><p>  分组丢失：如果交换机的缓存被用尽，那么新到达的分组或者之前的分组之一将被丢弃</p>
</li>
</ul>
<h3 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h3><ul>
<li>  转发表：源向目标发送分组数据的时候，携带了目标的IP，通过在路由器中跳转到目标，路由器中存储着目标地址的信息，形成一个映射表</li>
<li>  路由选择协议：上面说到的分组在路由间跳转，路由需要会选择下一个路由节点，就是路由选择协议</li>
</ul>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>在链路中创建一个连接，独占资源，这样的好处是稳定，坏处是资源利用率低</p>
<h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>较大的ISP相互连接，下面又有二层的ISP，底层还有好几层的ISP，最后是用户向地方ISP付费来接入因特网</p>
<h1 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h1><h2 id="时延概述"><a href="#时延概述" class="headerlink" title="时延概述"></a>时延概述</h2><h3 id="时延的类型"><a href="#时延的类型" class="headerlink" title="时延的类型"></a>时延的类型</h3><ul>
<li>  处理时延：检查分组首部以及决定将分组导向何处所需时间</li>
<li>  排队时延</li>
<li>  传输时延</li>
<li>  传播时延：源到目的地单纯链路传播需要的时间，排除路由去计算</li>
</ul>
<h1 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h1><h2 id="分层的体系结构"><a href="#分层的体系结构" class="headerlink" title="分层的体系结构"></a>分层的体系结构</h2><ul>
<li>  应用层：应用程序的网络协议，比如http、smtp、FTP、DNS；应用层的信息分组称为报文</li>
<li>  运输层：用于传输应用层报文，两种协议：TCP和UDP；运输层的分组称为报文段</li>
<li>  网络层：IP层，运输层通过IP将信息运输到目的地；分组叫做数据报</li>
<li>  链路层：数据报在路由器节点上的跳转；分组称为帧</li>
<li>  物理层：将帧中的比特从一个节点移动到下一个节点，由于不同的物理媒介，这一层有对应的不同协议（双绞铜线、光纤等）</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>网络的五层模型，一层层的进行数据封装来添加自己需要的控制信息<br><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-05/%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85.png" alt="image"></p>
<h1 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h1><h2 id="植入病毒攻击"><a href="#植入病毒攻击" class="headerlink" title="植入病毒攻击"></a>植入病毒攻击</h2><p>病毒软件</p>
<h2 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h2><p>DoS攻击使得网络、主机活其他基础设施部分不能由何方用户使用</p>
<ul>
<li>  弱点攻击：向易受攻击的应用程序或操作系统发送特定的报文，导致其停止运行或崩溃</li>
<li>  宽带洪泛：发送大量分组，使得接入链路变得拥塞，正常的分组无法到达服务器</li>
<li>  链接洪泛：创建大量的半开或者全开TCP</li>
</ul>
<h2 id="嗅探分组"><a href="#嗅探分组" class="headerlink" title="嗅探分组"></a>嗅探分组</h2><p>拷贝到通信分组来窃取信息，通过加密来应对</p>
<h2 id="身份伪装"><a href="#身份伪装" class="headerlink" title="身份伪装"></a>身份伪装</h2><p>IP哄骗，通过端点鉴别来应对</p>
<h1 id="计算机网络和因特网历史"><a href="#计算机网络和因特网历史" class="headerlink" title="计算机网络和因特网历史"></a>计算机网络和因特网历史</h1><ul>
<li>  分组交换 1961-1972</li>
<li>  专用网络和网络互联 1972-1980</li>
<li>  网络激增：1980-1990</li>
<li>  因特网爆炸：1990之后</li>
</ul>
]]></content>
      <categories>
        <category>网络基础</category>
        <category>自顶向下方法</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>自顶向下方法</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下方法 -- 第三章 运输层</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="概述与运输层服务"><a href="#概述与运输层服务" class="headerlink" title="概述与运输层服务"></a>概述与运输层服务</h1><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-07/%E8%BF%90%E8%BE%93%E5%B1%82.png" alt="image"></p>
<p>运输层为不同主机上的进程提供逻辑通信功能，是在端系统而不是路由器中实现的</p>
<p>运输层从应用程序中接收到报文转换为运输层分组（报文段segment），一般是将应用报文划分为较小的块，为每个块加上运输层的协议信息，然后将这些报文段传递给网络层，网络层将其封装为网络层分组（数据报）向目的地发送，注意网络路由器仅作用与该数据报的网络层字段不检查运输层报文字段，接收端从网络层数据报中提取运输层报文并上交给运输层，运输层处理收到的报文后再交给应用进程使用</p>
<h2 id="运输层和网络层的关系"><a href="#运输层和网络层的关系" class="headerlink" title="运输层和网络层的关系"></a>运输层和网络层的关系</h2><p>这里书中举了一个例子：两个远房亲戚家族通信，家族A让小刘统一负责收发信件，家族B让小张负责收发信件，于是两个家族里面的人都只合负责收发信件的小刘小张打交道就行，邮政服务将信件从一个家族送往另一个家族，而不是具体的一个人到另一个人</p>
<ul>
<li>  应用层报文 = 信封里的内容</li>
<li>  进程 = 家族里的亲戚</li>
<li>  主机（端系统） = 家族</li>
<li>  运输层协议 = 小刘和小张</li>
<li>  网络层协议 = 邮政服务（包括邮车）</li>
</ul>
<p>在这里小刘和小张都是在各自家里工作的，他们不参与到邮件的分拣和传输，类似的运输层协议值工作在端系统中</p>
<p>运输层中最常用的两个协议，UDP和TCP</p>
<h1 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h1><p>设备上运行多个服务需要进行网络通信，建立了多个socket连接，这个时候需要将对应的数据通过对应的socket进行传输，运输层报文中有几个字段用来标识对应的套接字</p>
<ul>
<li>  发送端主机从不同的套接字中收集数据块，并为他们封装上标识信息，然后将报文段传递到网络层，这个过程叫做多路复用</li>
<li>  对应的目标主机接收到报文段之后，通过首部标识将他们分发到对应的套接字，这个过程叫做多路分解</li>
</ul>
<p>看一下具体的工作流程：</p>
<ul>
<li>  套接字有唯一标识符</li>
<li>每个报文段有特殊字段来指示需要交付的套接字，这个特殊字段是源端口号和目的端口号，端口号是一个16bit的数，也就是0-65535，0-1023范围的端口号为周知端口号，是受限制的，比如HTTP使用80，HTTPs使用443<br>  <img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="image"></li>
</ul>
<h2 id="UDP的多路复用与分解"><a href="#UDP的多路复用与分解" class="headerlink" title="UDP的多路复用与分解"></a>UDP的多路复用与分解</h2><p>UDP的套接字是一个二元组（目的ip，目的端口号），所以当不同来源ip和不同来源端口号的两个拥有相同二元组信息时，这两个报文段将通过相同的套接字定向到相同的目的进程</p>
<h2 id="TCP的多路复用与分解"><a href="#TCP的多路复用与分解" class="headerlink" title="TCP的多路复用与分解"></a>TCP的多路复用与分解</h2><p>TCP套接字是一个四元组（源IP，源端口，目的IP，目的端口），需要这四个信息完全匹配时才会被放到同一个套接字进程中，也就是不同的源IP和端口的报文将被定向到两个不同的套接字</p>
<h2 id="web服务器与TCP"><a href="#web服务器与TCP" class="headerlink" title="web服务器与TCP"></a>web服务器与TCP</h2><p>例如一台端口80上运行Apache的服务器，当客户端发来报文段时（由于源ip和端口不同）会创建对应的HTTP进程，每个进程有自己的套接字，通过这些套接字可以接收和响应HTTP请求；实际上目前高性能的web服务器一般使用一个进程多线程的方式（线程对应套接字）</p>
<p>如果客户与服务器建使用持续HTTP则整个生命周期会使用同一个套接字，如果使用非持续的HTTP，则每次请求/响应后都要重新创建套接字</p>
<h1 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h1><p>最简单的运输层协议是什么，即UDP，由于应用层和网络层之间实在无法直接通信，网络层把报文送达后目的主机不知道该把报文给哪个应用进程，所以最少要求运输层要实现多路复用与分解，而UDP就是这样的协议（还有少量的差错检测）</p>
<p>DNS通常使用UDP的应用层协议，当DNS应用程序想要进行一次查询时，它构建一个DNS查询报文交给UDP，UDP封装后丢给网络层，然后就开始等待目的主机的响应，如果没有响应要么会向另一个服务器发一次查询要么就通知应用程序不能获得响应</p>
<p>UDP优势：</p>
<ul>
<li>  希望对应用层有更精细的控制，前面说道TCP有一个拥塞控制机制，会系统的调度报文的发送，而UDP简单粗暴（这个行为比较自私，大家都得不到好，大佬们已经提出了面向所有数据源的自适应拥塞控制，这个机制也导致UDP的优势减小）</li>
<li>  无需连接建立，TCP三次握手带来建立连接的时延，UDP速度更快，这个应该是DNS采用UDP的主要原因</li>
<li>  无连接状态，TCP需要维护连接状态，带来更多的资源开销</li>
<li>  分组首部开销，TCP首部占用20字节，UDP占用8字节</li>
<li>  开发者可以通过自定义检查机制来基于UDP完成可靠数据传输，只是实现起来比较繁琐，也不可能达到TCP那样的稳定性</li>
</ul>
<p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/%E6%B5%81%E8%A1%8C%E5%BA%94%E7%94%A8%E7%9A%84%E8%BF%90%E8%BE%93%E5%8D%8F%E8%AE%AE.png" alt="image"><br>这里单独说一下SNMP也是使用的UDP，网络管理应用程序一般要在网络处于重压的时候运行，这个时候很难建立TCP的稳定传输</p>
<h2 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h2><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/UDP.png" alt="image"></p>
<ul>
<li>  4个字段每个字段都是两个字节，所以UDP的首部占用8字节</li>
<li>  长度字段记录UDP报文段中的字节数（包括首部）</li>
<li>  检验和：接收方使用检验和来检查报文段是否出现差错</li>
</ul>
<h2 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h2><ul>
<li>  检验和通过补码反码的方式来对数据进行校验，具体过程没看懂，先不纠结</li>
<li>  UDP为什么要提供检验和，主要是不能保证传输过程中的协议都有差错检测，所以自己进行了实现，但是UDP对于差错的处理很糟糕，要么丢弃受损报文段，要么给应用程序提出警告</li>
</ul>
<h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><p>在不可靠的底层系统上构建可靠数据传输协议是一个困难的任务，这里将展开探索具体的实现逻辑</p>
<h2 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h2><h3 id="可靠信道的可靠数据传输：rdt1-0"><a href="#可靠信道的可靠数据传输：rdt1-0" class="headerlink" title="可靠信道的可靠数据传输：rdt1.0"></a>可靠信道的可靠数据传输：rdt1.0</h3><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%931.png" alt="image"><br>从最简单的模型来，假设底层信道的可靠传输时，这个时候没什么要做的，就是把应用层传过来的数据封装一下然后丢给下层，书上引入十个名词来解释给我看吐了</p>
<h3 id="经具有比特差错信道的可靠数据传输：rdt2-0"><a href="#经具有比特差错信道的可靠数据传输：rdt2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输：rdt2.0"></a>经具有比特差错信道的可靠数据传输：rdt2.0</h3><p>实际上我们都知道底层传输是可靠的，和人类的行为类似，两个人通过bb机交流的时候，如果听到了会说收到收到，没听到就让人重复，数据报文传输也使用类似的方式叫做自动重传请求（ARQ）协议</p>
<ul>
<li>  差错检测：为了确定收到的内容是否和发送内容一致，需要差错检测和纠错技术（后面的章节会详细讲），数据报文中需要一些额外的比特来记录这个技术需要的信息</li>
<li>  接收方反馈：接收方验证完差错之后给发送方反馈“肯定确认”ACK和“否定确认”NAK</li>
<li>  重传：发送方收到接收方的NAK时重新传输该分组数据</li>
<li>  停等：发送方发出分组后要等待接收方的反馈信号，这个过程中不会发送新的数据分组</li>
</ul>
<p>现在我们要考虑另一个问题，如果接收方反馈数据（ACK和NAK）出现了受损该如何处理</p>
<ul>
<li>  从人类角度出发，发送方收到了一个看不懂的反馈数据时，让接收方再说一次收到没有，问题是这个“再说一次你收到没有”这个数据出现受损，进入一个死循环，这种方式不可取</li>
<li>  第二种方式，增加足够的检验和比特，让发送方不仅可以检测差错还可以恢复差错，如果底层是只有可能产生差错不会丢失分组的信道，这个方法可以解决问题</li>
<li>第三种是，发送方收到含糊的反馈时，直接重新发送当前分组，引入冗余分组，冗余分组的根本困难在于接收方不知道收到的分组是新的还是一次重传<br>  解决这个问题的办法是为数据分组加上编号，这样接收方通过对比编号就知道是否为冗余分组，发送方会一直发送冗余分组直到收到正确的ACK；对于非停等协议情况，就需要接收方明确的标识反馈对应的分组，这样发送方就能确认各个分组的传输情况</li>
</ul>
<h3 id="既有比特差错也有丢包的情况：rdt3-0"><a href="#既有比特差错也有丢包的情况：rdt3-0" class="headerlink" title="既有比特差错也有丢包的情况：rdt3.0"></a>既有比特差错也有丢包的情况：rdt3.0</h3><p><em>“从发送方的观点来看，重传是一种万能灵药。发送方不知道是一个数据分组丢失，还 是一个ACK丢失，或者只是该分组或ACK过度延时。在所有这些情况下，动作是同样 的:重传。”</em></p>
<p>所以解决丢包的方法也是重传，发送方在一个时间阈值下没有收到接收方的ACK则重传数据</p>
<p>比特交替协议：分组需要在0和1之间交替（1个比特即可表达出来）<br><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/%E6%AF%94%E7%89%B9%E4%BA%A4%E6%9B%BF%E5%8D%8F%E8%AE%AE.png" alt="image"></p>
<h2 id="流水线可靠传输协议"><a href="#流水线可靠传输协议" class="headerlink" title="流水线可靠传输协议"></a>流水线可靠传输协议</h2><p>停等的方式效率很低，带宽利用率只有万分之2.7（大多数时间都在网络层传输数据），所以采取流水线的方式，即允许发送方发送多个分组而不用等待确认<br><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/%E5%88%86%E7%BB%84%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="image"></p>
<ul>
<li>  比特交替不行了，需要扩大编号存储空间</li>
<li>  发送方需要缓存那些未被确认的分组，接收方也许也需要缓存已正确接收的分组（取决于差错恢复策略）</li>
<li>  解决流水线差错恢复的两种方法：回退N步和选择重传</li>
</ul>
<h3 id="回退N步（Go-Back-N-GBN）"><a href="#回退N步（Go-Back-N-GBN）" class="headerlink" title="回退N步（Go Back N GBN）"></a>回退N步（Go Back N GBN）</h3><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/%E5%9B%9E%E9%80%80N%E6%AD%A5.png" alt="image"><br>上面的图片颜色有点不对劲，从左到右，分别是已经发送且确认、已发送未确认、待发送、不可用，需要注意的是这个是指分组序号，这个序号是存储在分组首部的一个数据，TCP中序号字段长度为32比特，也就是总共可用的序号为[0, 2^32-1]，而上面的比特交替由于只有一个比特[0, 1]</p>
<p>N被叫做窗口长度，有个问题是：为什么要限制这个发送未被确认和待发送的长度为N不让它占满所有序号呢，后面会解释，这里还不知道</p>
<ul>
<li>  上层调用的时候要判断窗口是否已满，未满则放进去发送，满了就要告诉上层让他过一会再试，或者有一个同步机制让上层仅在窗口不满时才调用send方法</li>
<li>  GBN累计确认：收到序号n的ACK时表明包括n在内的之前的分组都已经收到了，后面会解释原理</li>
<li>  超时事件：这里是为N个分组共享定时器，一个分组被确认这个定时器都会被重置，当然如果没有等待确认的分组时这个定时器被停止，如果超时则所有待确认的分组都会被重发</li>
</ul>
<p>GBN的接收方逻辑被设置得很简单：如果正确接收了一个序号为n的分组，检查上次交付给上层的分组序号为n-1，则发送n的ACK并把n中的数据取出来交付给上层，所有其他情况丢弃该分组</p>
<p>也就是说接收方会丢弃所有失序的分组，哪怕这个分组是正确接收，这里就是为了简单的设计，如果对这个n进行缓存等待n-1分组被正确的接收，这个设计的复杂度就高了，先前说了发送方是为N个分组统一设置的定时器，所以整个是批量进行重发的</p>
<h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><p>回退N步的代价太高了，一个分组丢失，所有后面的分组都被重传</p>
<p>太累了，下次再看这个的实现逻辑！（晚上要吃火锅，爽到）</p>
<h1 id="面向链接的运输：TCP"><a href="#面向链接的运输：TCP" class="headerlink" title="面向链接的运输：TCP"></a>面向链接的运输：TCP</h1><p>已经了解了可靠数据传输的基本原理，接下来看看TCP如何做的</p>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/TCP%E7%BC%93%E5%AD%98.png" alt="image"><br>最大报文长度（Maximum Segment Size, MSS）：由于TCP的报文长度是受限于网络层IP协议报文长度的，再往下的以太网协议长度为1500，TCP和IP的首部一般都是20，所以这个MSS一般是1460</p>
<h2 id="报文段结构"><a href="#报文段结构" class="headerlink" title="报文段结构"></a>报文段结构</h2><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/TCP%E6%8A%A5%E6%96%87%E6%AE%B5.png" alt="image"></p>
<ul>
<li>  两个端口号和UDP一样</li>
<li>  序号和确认号是发送方和接收方用来进行数据确认的，上面说过了</li>
<li>  16比特的接收窗口字段，用于流量控制，后面会讲</li>
<li>  4比特的首部长度字段，TCP首部有一些可选字段导致不是定长的，这个字段就是用来记录首部长度的，比较奇怪的是4比特最多能表示16，而TCP首部的最大长度为32，通常长度是20</li>
<li>  可选与变长的选项字段：用于发送方和接收方协商最大报文的长度（MSS）</li>
<li>6比特的标志字段<ul>
<li>  ACK</li>
<li>  RST、SYN和FIN比特用于连接的建立和拆除</li>
<li>  CWR和ECE服务于拥塞控制</li>
<li>  PSH用于标记将数据推送给应用层（实践中未使用）</li>
<li>  URG指示报文段里存在着被发送端上层实体置为紧急的数据（实践中未使用）</li>
</ul>
</li>
</ul>
<h3 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h3><ul>
<li>  序号：加入发送的数据流有500000字节，MSS为1000字节，那么第一个报文段分配序列号0，第二个分配序列号1000，是以数据流字节的编号作为序号</li>
<li>确认号：<ul>
<li>  简单的模型下接收方收到0-1000的数据后，给发送方发送一个报文其中确认号为1001，表示需要发送方从1001开始发送数据</li>
<li>  实际上发送方和接收方是相互传输数据的，假设A收到了B发送的0-555的字节，A在等待B数据流中556及之后的字节，A往B发送报文（A向B传输数据，不单是ACK）的时候就会在确认号中写556</li>
<li>  另外A收到了0-555，又收到了888-1000，但是由于中间的字节缺失，A到B的下一个报文的确认号仍然是556，这叫累积确认</li>
<li>  上面的例子中，888-1000的字节该怎么处理，TCP没有进行规定，可以直接丢弃也可以等待中间缺失的报文，这个交给编程人员去进行实现，一般不会丢弃这样效率更高</li>
<li>  另外为了避免端口号上之前建立过连接，起始序号一般是随机产生的，避免网络中存在之前的报文段被新的连接使用</li>
</ul>
</li>
</ul>
<h3 id="Telnet：序号和确认号的一个学习案例"><a href="#Telnet：序号和确认号的一个学习案例" class="headerlink" title="Telnet：序号和确认号的一个学习案例"></a>Telnet：序号和确认号的一个学习案例</h3><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-08/telnet.png" alt="image"><br>telnet是基于TCP的远程登录应用层协议，但是由于是明文传输，现在大家都用ssh，telnet一般用来测试目标主机上的某个端口是否可用</p>
<p>简单说一下流程：TCP连接建立之后，A向B发送了一个数据字符串C，这个时候给它分配了序号为42，确认号79（这里还没有接收过数据，这个确认号只是告诉B如果要发送数据序号从79开始），然后B接收到字符串C并且向A发送回显字符串C，序号为79（A指定的），确认号为43（告诉A如果要发送数据从43开始），A再次向B发送报文，这次没有数据，序号仍然为43，确认号为80（告诉B 79及之前的数据收到了），这是一个单纯的确认报文</p>
<p>上面第二次通信，也就是B发送数据给A的时候，将确认号43放到了数据报文中而不是用一个单独的确认报文，这叫做捎带</p>
<h2 id="往返时间与超时"><a href="#往返时间与超时" class="headerlink" title="往返时间与超时"></a>往返时间与超时</h2><p>TCP使用超时/重传的机制来处理报文丢失的问题</p>
<h3 id="估计往返时"><a href="#估计往返时" class="headerlink" title="估计往返时"></a>估计往返时</h3><p>超时时间该如何指定呢，由于网络信道每时每刻都在变化，很难得到一个通用的值，大多数TCP采用的方法是，在某个时间点上取一次RTT，之后再随机的取获取RTT，然后通过函数来动态更新往返时间，具体公式有些复杂不必纠结</p>
<h3 id="超时间隔"><a href="#超时间隔" class="headerlink" title="超时间隔"></a>超时间隔</h3><p>获取到一个趋近实际的往返时间之后，超时时间又该如何设置呢，肯定要大于往返时间，大太多会使得重发的效率低，大太少又会导致频繁的重发，这里也是带入往返时间进行函数动态评估，另外如果发生超时这这个超时的间隔会翻倍</p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><ul>
<li>  超时时间加倍：通过这个加倍的规则，可以粗略的实现拥塞控制，也就是认为网络堵塞的时候将重传频率降低，避免整个系统越发恶化</li>
<li>  快速重传：超时重传的问题之一，如果超时周期比较长，那一个报文丢失后重传的间隔也长，有一个机制来解决这个问题，冗余ACK，比如有abcd四个报文，其中a已经确认收到，b丢失，而c和d都收到，这个时候接收方不会发送一个对b的否定，而是重复发送对a的ACK，当接收方收到三个相同的ACK时，说明它之后的数据很可能是丢失了，不会再等到定时器过期（超市间隔），直接重传被认为丢失的报文段‘</li>
</ul>
<h3 id="回退N还是选择重传"><a href="#回退N还是选择重传" class="headerlink" title="回退N还是选择重传"></a>回退N还是选择重传</h3><p>TCP发送方仅需维持已发送但未被确认的字节的最小序号（SendBase）和下一个要发送的字节序号（NextSeqNum），看起来很想一个GBN，实际还是有些区别，TCP允许接收方有选择的确认失序报文段，而不是单纯的累计确认，和选择重传结合起来（跳过已被确认的报文段），TCP的差错恢复机制是GBN和SR的混合体</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>TCP连接两端的主机都会设置一个接收缓存（正确有序的字节），应用层服务会从缓存里面读取数据，但是如果传输速度太快，但是应用层服务读取比较慢（服务可能在处理别的工作），可能会导致缓存溢出，TCP为解决这个问题提供了流量控制服务</p>
<p>注意流量控制服务是为了防止传输速度过快缓存溢出，而之前提到的拥塞控制是为了保持整个底层信道的通畅，虽然都是主动的限速操作，但是意义完全不同</p>
<p>实现的逻辑：有一个前置设定是接受方会丢弃所有无序的报文，这个时候发送方会跟踪接收方缓存中的两个变量，第一个是LastByteRcvd最后确认接受到的字节，第二个LastByteRead应用最后一次读取的字节，然后保证发送窗口中发送未确认的报文大小小于LastByteRcvd-LastByteRead</p>
<h2 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h2><h3 id="三次握手的详解"><a href="#三次握手的详解" class="headerlink" title="三次握手的详解"></a>三次握手的详解</h3><ul>
<li>  第一步是客户端发送一个SYN被标记为1的报文，叫做SYN报文，并随机初始化序号（为避免SYN泛洪攻击，这个随机的方式也有说道）</li>
<li>  第二步服务器收到SYN报文，会为该TCP分配缓存和变量，并向客户端发送允许连接的报文，该报文中SYN为1，确认号为客户端SYN序号加一（不是序号本身），服务端初始化一个序号，这个报文叫做SYNACK</li>
<li>  第三步客户端收到SYNACK，同样为TCP分配缓存和变量，再向服务器发送一个对SYNACK的确认报文（这个是为了向服务器表达自己的TCP资源准备好了），这个时候SYN为0，同样确认号为服务器初始化的序号加一</li>
</ul>
<p>后面会讲为什么是三次而不是两次，之后的通信中SYN都是0</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>累了，以后再看</p>
<h1 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h1><p>上面我们讨论可靠传输的实现原理，主要原因就是底层的传输是不可靠的，而之前也讲过，网络拥塞导致的路由器缓存溢出是丢包最常见的原因，这里会对拥塞做进一步的探索</p>
<h2 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h2><p>拥塞控制需要先了解底层网络的拥塞情况，两种情景下对拥塞情况的探知方式</p>
<ul>
<li>端到端：底层不为运输层提供拥塞信息的支持<ul>
<li>  超时</li>
<li>  3次冗余确认</li>
<li>  往返时延的变化</li>
</ul>
</li>
<li>网络辅助：<ul>
<li>  网络路由器直接向发送发反馈信息，表示自己拥塞了</li>
<li>  路由器给分组数据中加入拥塞的标识，接收方收到带有标识的分组后会告诉发送方网络拥塞</li>
</ul>
</li>
</ul>
<h1 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h1><p>TCP让发送方根据所感知到的网络拥塞程度来限制其发送流量的速度，核心问题：</p>
<ul>
<li>  如何限制流量发送速度</li>
<li>  如何感知传输路径上的拥塞情况</li>
<li>  出现拥塞时速率调整的算法</li>
</ul>
]]></content>
      <categories>
        <category>网络基础</category>
        <category>自顶向下方法</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>自顶向下方法</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下方法 -- 第二章 应用层</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h1><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-05/应用层.png" width="600">

<h2 id="网络应用程序体系"><a href="#网络应用程序体系" class="headerlink" title="网络应用程序体系"></a>网络应用程序体系</h2><h3 id="客户-服务器"><a href="#客户-服务器" class="headerlink" title="客户-服务器"></a>客户-服务器</h3><p>典型的web应用，需要服务器主机一直运行，随时处理来自客户端的请求；对于大型网站来说，单个的服务器不能应对海量的请求，配备大量主机的数据中心常用来创建强大的虚拟服务器；</p>
<h3 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h3><p>对服务器没有依赖或者依赖很小，两个主机之间直接进行通信，优点很明显不需要厂家提供海量的服务器，每个用户主机的资源都可以作为服务的一部分，缺点是稳定性和安全性难得到保障</p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>最终进行通信的单元是进程不是程序，这里也不会太多的研究同一主机上的进程间通信，来看看跨越计算机网络交换报文的不同端系统上的进程间的通信</p>
<h3 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h3><p>在web应用中很明显浏览器进程是客户进程，但对于P2P来说呢，我们认为发起通信的进程是客户，等待联系的进程是服务器</p>
<h3 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h3><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-05/套接字.png" width="600">

<ul>
<li>  套接字：如上所述，多数应用程序是有通信进程对组成，相互发送报文，这些报文必须通过下层网络进行传输，定义了一个叫套接字（socket）的软件接口来让进程发送和接收报文</li>
<li>  API：套接字是应用层和传输层之间的接口，也称为应用程序和网络之间的应用程序编程接口（API），开发者可以控制套接字在应用层的一切，但对套接字在运输层端几乎没有控制权，能选择运输层协议和少量的参数配置</li>
</ul>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>为了向目标主机上的进程发送分组，接收进程需要有一个地址，需要定义两种信息：主机的地址（IP）、目标主机中接收进程的标识符（端口号）</p>
<h2 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h2><p>运输层存在不同的传输协议，提供了不同的服务，我们对服务特性进行分类：可靠数据传输、吞吐量、定时和安全性</p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>之前说过，分组传输可能因为路由缓存耗尽而丢失或者比特损坏等，出现数据丢失；一些应用像电子邮件、文件传输、金融应用等不能接受数据的丢失，为了支持这些应用，需要确保应用程序在一端发出的数据能完全正确的交付给另一端，提供这样服务的协议就具有了可靠数据传输的特性</p>
<p>像通话这样的应用是可以接受数据丢失的</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>由于分组在网络上是共享带宽的方式进行传输的，所以本身并不能保证自己能占用多少带宽，但对于及时通话或者视频这样的带宽敏感的应用来说，如果带宽不能稳定的大于某个阈值，那它的服务将服务提供，这个时候就需要传输协议能保证传输带宽至少大于阈值</p>
<h3 id="定时"><a href="#定时" class="headerlink" title="定时"></a>定时</h3><p>这里说的定时其实是说保证比特到达接收方的时间不超过阈值，也就是保证延时</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>这个很好理解，比如https</p>
<h2 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h2><p>因特网提供两个运输层协议，UDP和TCP</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul>
<li>  面向连接的服务：在完成握手之后，一个TCP链接就在两个进程套接字之间建立了，在这个连接里面两个进程可以同时进行报文的收发</li>
<li>  可靠的数据传输服务</li>
<li>  拥塞控制：当发现传输网络出现拥塞时，TCP会抑制发送进程来缓解网络压力</li>
<li>  安全性：无论是TCP还是UDP都没有提供任何的加密机制，数据是以明文在网络上传递的，可以被中间链路嗅探</li>
<li>  SSL（secure sockets layer）：安全套接字层，SSL是对TCP的加强而不是运输层上的第三种协议，而且这个地方的非对称加密是在应用层上实现的</li>
</ul>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP是一个轻量级的运输协议，无连接、不可靠数据传输、没有拥塞控制，应用场景比较少（电话应用），基本被TCP替代</p>
<h3 id="因特网运输协议不提供的服务"><a href="#因特网运输协议不提供的服务" class="headerlink" title="因特网运输协议不提供的服务"></a>因特网运输协议不提供的服务</h3><p>可以看出TCP没有提供吞吐量和定时相关的服务，因特网有别的方式来提供这两种服务，后面会探讨</p>
<h2 id="会涉及的网络应用"><a href="#会涉及的网络应用" class="headerlink" title="会涉及的网络应用"></a>会涉及的网络应用</h2><p>由于网络应用种类太多，这里只会主要介绍常见的几种：Web、文件传输、电子邮件、目录服务、流式视频和P2P</p>
<h1 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h1><p>上世界90年代以前，因特网只是众多的数据网络中的一个，它的主要使用者是研究人员和学者不为大众所知，正是万维网（world Wide Web）的出现引起了公众的注意，因特网开始一枝独秀</p>
<h2 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h2><p>web的应用层协议是HTTP，先看一些基础概念!</p>
<ul>
<li>  web页面：由对象组成，可以是一个HTML文件、图片、小程序或者视频之类的数据，可以通过一个URL地址寻址。于是可以相互引用</li>
<li>  HTTP：定义了客户想服务器请求的方式，以及服务器向客户传送页面的方式，使用TCP作为传输协议，两端通过套接字接口进行通信，一旦数据发送之后，就不再由端系统控制，进入TCP的控制；而且服务器并不会记录客户的任何信息，我们称HTTP为无状态协议，且服务器总是打开的具有一个固定的IP</li>
</ul>
<h2 id="非持续连接和持续链接"><a href="#非持续连接和持续链接" class="headerlink" title="非持续连接和持续链接"></a>非持续连接和持续链接</h2><p>非连续连接就是说，客户端和服务器的一次请求和响应完成后连接就断开，下次请求重新建立连接，这样的问题是频繁的创建销毁连接带来资源开销，而且如果一个客户端同时有多个请求会建立多个连接，连接规模会比较大</p>
<p>持续连接即使说不要立马断开，下次请求还可以通过这个连接进行通信，会有一个超时时间来断开连接，如果有多个请求是可以并发的进行，而不是串行的</p>
<h2 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h2><p>有请求报文和响应报文，具体的内容就那些，列到这里意义不大，该记不住的还是记不住</p>
<h2 id="用户与服务器的交互：cookie"><a href="#用户与服务器的交互：cookie" class="headerlink" title="用户与服务器的交互：cookie"></a>用户与服务器的交互：cookie</h2><p>由于http本身是无状态的，所以通过cookie来维护一些用户的活动，登录、访问记录、身份识别权限控制等；cookie的使用其实是对用户隐私的一种侵犯，所以要求网站需要得到用户的授权之后才能使用</p>
<h2 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h2><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-06/缓存服务器.png" width="300">

<p>在局域网内加入一个web缓存器，这样重复的请求不需要进入公网链路，由于局域网带宽一般是很高的响应快，且极大的减轻公网链路的传输压力</p>
<h2 id="条件get方法"><a href="#条件get方法" class="headerlink" title="条件get方法"></a>条件get方法</h2><p>上面说了添加web缓存服务器，带来一个问题，如果真正的服务器上的信息发生了改变，那缓存如何处理，GET提供了一种条件请求，if-modified-since:时间，缓存服务器向真实的服务器发送条件请求，只有当这个时间点之后服务器上的结果发生了变化才返回真正的结果，如果没有变化则只返回一些响应头数据，不包含真正的dat，这样报文体积就很小对网络带宽没有多少占用</p>
<h1 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h1><p>电子邮件应该是因特网中最早的一个流行应用，直至今日也仍然是因特网上最重要和实用的应用程序之一</p>
<h2 id="电子邮件系统组成"><a href="#电子邮件系统组成" class="headerlink" title="电子邮件系统组成"></a>电子邮件系统组成</h2><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-06/邮件服务.png" width="300">

<ul>
<li>  用户代理：允许用户阅读、回复、转发、保存和撰写报文</li>
<li>  邮件服务器：</li>
<li>  简单邮件传输协议：</li>
</ul>
<h1 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h1><h2 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h2><h2 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h2><h2 id="DNS记录和报文"><a href="#DNS记录和报文" class="headerlink" title="DNS记录和报文"></a>DNS记录和报文</h2><h1 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h1><p>上面的结构都是服务器和客户端，现在有一个场景，服务器要向大量的客户端推送一个系统的版本更新，体积为2G，如果所有的客户端都去服务器上下载数据，那对服务器的带宽要求太高了</p>
<p>用到P2P文件分发，每个对等方能够向任何其他对等方重新发送它已经收到的该文件的任何部分，减小服务器压力，目前最流行的P2P文件分发协议是BitTorrent</p>
<h2 id="P2P体系结构的扩展性"><a href="#P2P体系结构的扩展性" class="headerlink" title="P2P体系结构的扩展性"></a>P2P体系结构的扩展性</h2><p><img src="https://raw.githubusercontent.com/fireflyso/Img/master/2021-07/p2p.png" alt="image"></p>
<p>书上用了一大堆公式来进行推导，最终的结论就如图中展示的样子，服务器的模式下耗时是线性增长的，P2P模式下用户规模的扩展不会带来太多耗时的增长</p>
<h2 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h2><p>来简单的介绍一下这个协议的原理，由于其真实的实现非常复杂，了解核心思维即可</p>
<ul>
<li>  参与某个文件分发的所有对等方集合称为一个洪流，文件被拆分为文件块在对等方间传输，典型的大小是256KB，洪流中总是有新的对等方加入和老的对等方离开</li>
<li>  每个洪流具有一个追踪器，每个对等方都在追踪器中注册自己并周期性的通知追踪器自己还在洪流中，以此来同步对等方信息</li>
<li>  现在加入小张加入了一个洪流，目前洪流中有50个对等方，追踪器会将这50个对等方的IP发给小张，小张尝试和他们进行TCP交易，建立成功的称为邻近对等方</li>
<li>  小张会周期性的查询（所有的通讯都通过TCP进行）邻近对等方所持有的块，接下来需要解决两个核心问题，小张该从她的邻居那请求那些块，第二小张该向哪些邻居发送块</li>
<li>  小张会去请求她没有的块里面最稀缺的数据，稀缺就是说在邻居上副本数据少的数据，目的也好理解，为了大致均衡每个块在洪流中的副本数量</li>
<li>  小张会持续的测量从邻居那里接收比特的速率，并记录Top4速度列表，每10秒检测更新这个列表，这top4称为疏通，一直更新也没有用，引入新的竞争者，每30s会随机的向一个邻居发送数据，同理也会有一个随机邻居小刘向小张发送数据，如果小刘发送数据的速度比现在的top4更快自然top4就会重新洗牌；也就是说同时只会有5个对等方可以和小张进行数据传输</li>
</ul>
<h1 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h1><p>事先录制好的视频流（非及时）基本占用了住宅ISP一半的流量，这里我们来看看是怎么进行传输的</p>
<h2 id="因特网视频"><a href="#因特网视频" class="headerlink" title="因特网视频"></a>因特网视频</h2><p>视频是由连续播放的图片组成的，图片又是由像素矩阵构成，图像的特点是能被压缩，现今的技术允许视频被压缩到任意比特率</p>
<h2 id="HTTP和DASH"><a href="#HTTP和DASH" class="headerlink" title="HTTP和DASH"></a>HTTP和DASH</h2><p>通过HTTP get请求客户端和服务器之间建立一个TCP连接，进行数据传输，达到设定的阈值之后就开始播放，且继续传输后面的数据；HTTP的方式存在一个严重的缺陷是只能传输同一比特率的视频，本质就是有一个视频文件放到了服务器上，然后进行传输嘛，所以大家拿到的都是同一个视频文件</p>
<p>DASH（Dynamic Adaptive Streaming over HTTP）：动态适应流，基于HTTP将视频压缩为不同码率的版本放到服务器，客户动态的请求来自不同版本且长度为几秒的视频段数据块，这样当用户的带宽出现波动的时候，也能在不同比特率的块上进行切换；自动切换的原理就是看带宽速率能不能满足播放的需求</p>
<h2 id="内容分发网-CDN"><a href="#内容分发网-CDN" class="headerlink" title="内容分发网 CDN"></a>内容分发网 CDN</h2><p>CDN的基础概念不在这里描述了，两种服务器安置原则</p>
<ul>
<li>  深入：即是在遍及全球的接入ISP中部署服务器（1700个），通过靠近端用户来提升速率</li>
<li>  邀请做客：在少量的关键位置（10个）部署大集群，不是将集群接入ISP，而是放置在因特网交换点（IXP），成本低，但是效果不如深入原则</li>
</ul>
<p>CDN也不能把数据都复制到每个节点上，所以采用热度淘汰的策略来进行分布式存储</p>
<h3 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h3><p>比如公司智线云的产品FN上有很多视频内容，智线云是个小公司不能自己部署一套CDN，于是使用了阿里云提供的CDN，用户请求视频数据的流程为：</p>
<ul>
<li>  用户访问FN web网页</li>
<li>  用户点击视频内容，用户主机发送了一个请求，用户本地DNS服务器将请求中继到智线云的DNS服务器，该服务器发现请求资源是视频的时候向用户DNS返回一个阿里云CDN的主机名</li>
<li>  用户DNS向阿里云CDN主机发送请求，阿里云CDN的DNS系统会指定一个具体的CDN服务器并返回IP，用户将从这台服务器上获取数据</li>
<li>  用户DNS向用户主机转发了CDN服务器IP，用户将和这个IP建立TCP连接进行通信</li>
</ul>
<p>实际上操作的时候，数据应该事先被放到阿里云的CDN上，网页上直接就是写的阿里云CDN提供的链接，用户通过这个链接访问CDN数据</p>
<h3 id="集群选择策略"><a href="#集群选择策略" class="headerlink" title="集群选择策略"></a>集群选择策略</h3><p>在上面的案例中，阿里云CDN是如何选择让哪个集群来响应用户请求的呢</p>
<ul>
<li>  最直接的就是从地理上的最近来进行响应，不错的策略，但是实际情况下用户的DNS有可能远离用户的，这里的地理最近是从用户DNS来进行计算的，另外网络还存在带宽以及时延等现实的问题</li>
<li>  比较好的策略是实时测量，CDN的每个集群都周期性的向位于全世界的所有用户DNS发送探测分组来测量时延和丢包，缺陷是许多的DNS被配置为不会响应这些探测LOL</li>
</ul>
<h2 id="案例：Netflix、YouTube"><a href="#案例：Netflix、YouTube" class="headerlink" title="案例：Netflix、YouTube"></a>案例：Netflix、YouTube</h2><h3 id="Netflix"><a href="#Netflix" class="headerlink" title="Netflix"></a>Netflix</h3><ul>
<li>  使用了亚马逊云，新电影发布前，将数据上传到亚马逊云的主机上，并转化为不同的格式以及比特率，然后将这些处理后的不同版本数据上载到CDN上</li>
<li>  Netflix 2007年起搭建了自己的CDN，在IXP和他们自己的住宅ISP中安装服务器机架，当前有超过50个IXP上安装了机架，Netflix还会联系ISP免费的安装机架，这些机架具有几个10Gbps的以太网端口和超过100T的存储</li>
<li>  Netflix的CDN并不通过拉高速缓存的方式进行数据分发，通过主动推送的方式，将流行的视频在非高峰时段推送到CDN服务器</li>
</ul>
<h3 id="YouTube"><a href="#YouTube" class="headerlink" title="YouTube"></a>YouTube</h3><p>同样适用CDN来分发视频，与Netflix不同，Google使用了拉高速缓存的方式来进行同步,和Netflix一样也使用自己专用的CDN，YouTube不使用DSAH而是让用户自行选择</p>
<h3 id="迅雷看看"><a href="#迅雷看看" class="headerlink" title="迅雷看看"></a>迅雷看看</h3><p>迅雷使用P2P交付的方式来传输流视频，看看在使用CDN-P2P混合流式系统，用户从CDN请求内容开头的部分，并从对等方请求内容，当P2P流量可以满足视频播放时，停止向CDN请求，极大降低了基础设施服务器成本</p>
<h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><p>之前也介绍过，不同的开发者使用相同的协议进行编程，可以让不同的应用进行交互，下面会实现简单的TCP和UDP协议程序</p>
<h2 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h2><p>书上给出了demo，本地测试可以，但是和服务器之间的通信失败了</p>
<h2 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h2>]]></content>
      <categories>
        <category>网络基础</category>
        <category>自顶向下方法</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>自顶向下方法</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下方法 -- 第四章 网络层-数据平面</title>
    <url>/2023/04/13/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h1><p>大概就是把运输层的数据拿过来再做一次封装加入自己需要的标识信息之后在路由器之前传递报文，然后目标路由器再丢给运输层</p>
<h2 id="转发和路由选择：数据平面和控制平面"><a href="#转发和路由选择：数据平面和控制平面" class="headerlink" title="转发和路由选择：数据平面和控制平面"></a>转发和路由选择：数据平面和控制平面</h2><ul>
<li>  转发：当一个分组到达某个路由器的一条输入链路时，改路由器将分组移动到适当的输出链路</li>
<li>  路由选择：当分组从发送方流向接收方时，网络层必须决定这些分组锁采用的路由或路径，计算的方式叫做路由选择算法</li>
</ul>
<p>每台网络路由器中有一个转发表，分组会根据表示字段到转发表中进行索引来决定分组的输出链路</p>
<h3 id="控制平面：传统方法"><a href="#控制平面：传统方法" class="headerlink" title="控制平面：传统方法"></a>控制平面：传统方法</h3><p>路由器之间通过路由选择报文进行通信，以计算出转发表的值；如果所有的转发表是人工配置的那就不需要路由选择算法了，但是这种情况下人工效率低且容易出错</p>
<h3 id="控制平面：SDN方法（Software-Defined-Networking）"><a href="#控制平面：SDN方法（Software-Defined-Networking）" class="headerlink" title="控制平面：SDN方法（Software-Defined Networking）"></a>控制平面：SDN方法（Software-Defined Networking）</h3><p>通过一个远程控制器来计算并分发转发表，路由器仅执行转发，远程控制器和路由器之间通过交换包含转发表和其他路由选择信息的报文来进行通信</p>
<h2 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h2><p>思考一些问题：运输层可以指望网络层完成分组的交付吗？网络层会顺序的交付分组吗？分组发送的间隔和交付的间隔会一致吗？网络层会提供拥塞信息反馈吗？</p>
<p>这些问题是有网络层提供的服务模型所决定的，网络服务模型定义了分组在发送与接收端之间运输的特性，可能提供的服务：</p>
<ul>
<li>  确保交付</li>
<li>  具有时延上界的确保交付</li>
<li>  有序交付</li>
<li>  确保最小带宽</li>
<li>  安全性</li>
</ul>
<p>实际上确实有一些服务模型实现了以上的需求（ATM），但因特网的网络层提供的单一服务确是尽力而为服务，也就是说，我尽量给你做到这些事情，但实际效果不保证，看起来很不负责，但现实的结果是这个服务模型非常好用</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>  下一小结中会展开讲路由器的内部硬件以及IPv4和v6协议</li>
<li>  链路交换机：是基于链路层帧中字段值做转发决定的交换机</li>
<li>  路由器：基于网络层数据报中字段来决定转发的交换机</li>
</ul>
<h1 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h1>]]></content>
      <categories>
        <category>网络基础</category>
        <category>自顶向下方法</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>自顶向下方法</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡--LVS</title>
    <url>/2023/05/28/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/LVS/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>LVS（Linux Virtual Server）Linux虚拟服务，是一个开源的软件项目，在linux2.4版本中内置了LVS，可以看出LVS的影响力非常大</li>
<li>LVS可以实现高可伸缩的、高可用的网络服务，也就是说Linux集成它之后，所有基于Linux内核的服务器原生即可实现集群</li>
<li>优点：<ul>
<li>性能强：一方面是集成到内核里面的，对硬件资源的调度非常直接，另外是4层本身只做分发，这活本身也够简单，所以速度快，稳定性强（不容易出bug）</li>
<li>低成本，没啥好说，典型的软件优化替代硬件</li>
<li>配置简单，支持多做算法，支持多种工作模型，另外由于是在4层工作所以基本可以对所有应用进行负载均衡</li>
</ul>
</li>
<li>不足：不支持7层规则修改，也就是没有7层那么多的功能，机制过于庞大，不适合小规模应用，比如说DPVS（基于LVS）一台设备基本可以到达百万级别的CPS（每秒建立连接数），一般也没有这么大的需求，可以选择七层的负载均衡达到更灵活的功能配置；所以其实这里提到的不足都不是LVS的缺陷，只是某些场景不适合使用LVS而已</li>
</ul>
<h1 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h1><p>LVS的管理工具和内核模块ipvsadm/ipvs</p>
<ul>
<li>ipvsadm：命令行工具，用于管理集群服务，比如统计集群的相关状态信息，重启服务等</li>
<li>ipvs：工作与内核上的netfilter INPUT钩子之上的程序，可根据用户定义的集群实现请求转发</li>
</ul>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul>
<li>VS：virtual server即虚拟服务</li>
<li>Director-分发器、Balancer-负载均衡器</li>
<li>RS：real server后端真正处理请求的服务器</li>
<li>CIP：client IP</li>
<li>VIP：Director Virtual IP负载均衡器虚拟IP，即客户端统一访问的IP</li>
<li>DIP：Director IP负载均衡器IP</li>
<li>RIP：real server IP</li>
</ul>
<h1 id="内核工作流程"><a href="#内核工作流程" class="headerlink" title="内核工作流程"></a>内核工作流程</h1><p><img src="/img/image-20230601163304403.png" alt="image-20230601163304403"></p>
<h1 id="四种工作模式"><a href="#四种工作模式" class="headerlink" title="四种工作模式"></a>四种工作模式</h1><h2 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h2><p>用地址转换实现虚拟服务器，外界看到的是LVS的VIP，LVS会根据配置的转发规则对数据包的目标IP做修改，以实现数据转发，优点是节省IP地址，缺点是效率低，因为返回给客户端的流量经过转换器</p>
<p><img src="/img/image-20230601163154404.png" alt="image-20230601163154404"></p>
<ul>
<li>用户请求到达LVS，报文会到内核空间的PREROUTING，此时报文源IP为CIP，目标IP为VIP</li>
<li>当PREROUTING发现数据包的目标IP是本机，则将数据包转发到INPUT链，通过IPVS对比转发规则，如果有匹配的规则，就按规则修改数据包的目标IP为RIP，再通过PREROUTING链将数据包发送给RS</li>
<li>RS处理请求，生成响应报文发回给LVS，此时报文源IP为RIP，目标IP为CIP</li>
<li>LVS通过FORWORD将源IP修改为VIP，并转发给客户端</li>
</ul>
<h2 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h2><p>DR 和 REAL SERVER 都使用同一个 IP 对外服务。但只有 DR 对 ARP 请求进行响应，所有 REAL SERVER 对本身这个 IP 的 ARP 请求保持静默。也就是说，网关会把这个服务 IP 的请求全部定向给 DR，而 DR 收到数据包后根据调度算法，找出对应的 REAL SERVER，把目的 MAC 地址改成 REAL SERVER 的 MAC 并发给这台REAL SERVER。这时 REAL SERVER 收到这个数据包，则等于直接从客户端收到这个数据包无异，处理后直接返回给客户端。由于 DR 要对二层包头进行改换，所以 DR 和 REAL SERVER 之间必须在一个广播域，也可以简单的理解为在同一台交 换机上。</p>
<p><img src="/img/image-20230601122933251.png" alt="image-20230601122933251"></p>
<ul>
<li>用户请求到达LVS，报文会到内核空间的PREROUTING，此时报文源IP为CIP，目标IP为VIP</li>
<li>当PREROUTING发现数据包的目标IP是本机，则将数据包转发到INPUT链，通过IPVS对比转发规则，如果有匹配的规则，就按规则修改数据包的源MAC地址修改为LVS的MAC地址，将目标MAC地址修改为RS的MAC地址，此时源IP和目标IP不会被修改</li>
<li>由于LVS和TS在一个广播域内，PREROUTING链通过二层转发将数据包发送给RS</li>
<li>RS接到请求后进行处理，响应报文通过lo接口传送给eth0网卡然后向外发出，此时源IP地址为VIP，目标IP为CIP</li>
<li>响应报文送达客户端</li>
</ul>
<h2 id="TUN模式"><a href="#TUN模式" class="headerlink" title="TUN模式"></a>TUN模式</h2><p>对NAT模式的优化，在NAT模式下请求和响应的报文都需要LVS机器进行修改，吃CPU资源，TUN模式不直接修改请求报文的源IP和目标IP，而是在请求报文首部再封装一层IP报文，增加一个源地址为DIP，目标地址为RIP，这层封装只是为了让报文能被转发给对应的RS，RS拿到数据包后拆开LVS封装的报文，拿到真实的目标地址发现是自己lo接口上的VIP，则会处理请求，这个时候由于RS是知道CIP的，所以直接通过eth0网卡发送给客户端即可，不需要再转发LVS进行地址转换</p>
<p><img src="/img/image-20230601163015454.png" alt="image-20230601163015454"></p>
<h2 id="full-nat模式"><a href="#full-nat模式" class="headerlink" title="full-nat模式"></a>full-nat模式</h2><p>对NAT模型的改进，使得RS与LVS可以处于不同网络</p>
<ul>
<li>RIP和DIP可以使用私有网络</li>
<li>RIP和DIP可以不在同一个网络中，且RIP的网关可以不指向DIP</li>
<li>支持端口映射</li>
</ul>
<h1 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h1><p>一些连续的请求场景需要同一个RS进行连续的响应，LVS实现了持久连接机制，让同一用户的HTTP请求在超时时间内都重定向到同一个RS进行响应，超时时间可以设定，还可以通过设定端口的姻亲关系来绑定同一用户对不同端口的请求由同一RS响应</p>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="静态算法"><a href="#静态算法" class="headerlink" title="静态算法"></a>静态算法</h2><ul>
<li>RR（Round Robin）轮询：按请求顺序轮流转发给RS</li>
<li>WRR（Weight RR）加权轮询：调度器自动询问RS的负载情况，来动态调整其权值，来分配请求</li>
<li>DH（Destination Hash）：目标地址散列</li>
<li>SH（Source Hash）：源地址散列</li>
</ul>
<h2 id="动态算法"><a href="#动态算法" class="headerlink" title="动态算法"></a>动态算法</h2><ul>
<li>LC（Least connections）最少连接：将请求分配给已建立连接最少的RS，在RS性能接近时合理</li>
<li>WLC（Weight LC）加权最少连接（默认算法）：不清楚和WRR的区别</li>
<li>SED（Shortest Expected Delay）最短期望延迟</li>
<li>NQ（Never Queue）无需队列：如果RS连接数为0，直接分配</li>
<li>LBLC（locality-Based Least Connections）基于局部性的最少链接：离客户端近且未超负载的RS进行响应</li>
<li>LBLCR（Locality-Based Least Connections with Replication）带复制的基于局部性最少连接</li>
</ul>
]]></content>
      <categories>
        <category>网络基础</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡基础概念</title>
    <url>/2023/05/28/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h1><ul>
<li>VIP</li>
<li>RS：真实服务器，即真正提供服务的机器</li>
<li>硬件负载均衡产品：F5等，这个是比较贵的，听说农行用了F5</li>
<li>软件负载均衡：LVS、DPVS（基于LVS）、Haproxy、Nginx，通常都使用软件负载均衡方案</li>
</ul>
<h1 id="OSI网络层负载均衡"><a href="#OSI网络层负载均衡" class="headerlink" title="OSI网络层负载均衡"></a>OSI网络层负载均衡</h1><img src="/img/202208131605543.png" alt="202208131605543" style="zoom: 67%;">

<h2 id="二层（mac）"><a href="#二层（mac）" class="headerlink" title="二层（mac）"></a>二层（mac）</h2><p>虚拟mac地址，对外使用虚拟mac地址，接收后再分配给后端实际的mac地址</p>
<h2 id="三层（ip）"><a href="#三层（ip）" class="headerlink" title="三层（ip）"></a>三层（ip）</h2><p>虚拟ip</p>
<h2 id="四层（tcp）"><a href="#四层（tcp）" class="headerlink" title="四层（tcp）"></a>四层（tcp）</h2><p>在三层负载均衡基础上，使用IP+port方式做虚拟映射，对流量做NAT处理，转发到后台服务器，并记录流量是由哪台服务器处理的，后续这个连接的所有流量会被转发到同一台服务器</p>
<p>注意，Nginx和Haproxy也可以实现四层的负载均衡，后面详细介绍</p>
<h3 id="五元组"><a href="#五元组" class="headerlink" title="五元组"></a>五元组</h3><p>通过五元组来决定流量的转发目的地</p>
<ul>
<li>来源IP、端口</li>
<li>目标IP、端口</li>
<li>协议</li>
</ul>
<h3 id="VIP的实现"><a href="#VIP的实现" class="headerlink" title="VIP的实现"></a>VIP的实现</h3><ul>
<li>通过keepalive实现</li>
</ul>
<img src="/img/image-20230526190614854.png" alt="image-20230526190614854" style="zoom: 50%;">

<ul>
<li>通过BGP协议实现，这种方式可以让流量轮询实现均分</li>
</ul>
<h2 id="七层（http）"><a href="#七层（http）" class="headerlink" title="七层（http）"></a>七层（http）</h2><p>虚拟url或者ip，在四层负载均衡基础上，根据应用层的特征来转发流量，比如URL、浏览器类别、语言等。</p>
<p>以TCP为例，负载均衡设备要根据应用层的内容来进行转发，那么势必需要对客户请求的内容进行解析，所以客户端是先和负载均衡器建立连接，负载均衡器再根据客户报文内容进行流量转发（和RS建立连接），而四层的负载均衡只需要解析段内容，不会和客户端建立连接，所以四层的负载均衡效率会高于七层负载均衡</p>
<h2 id="四层与七层的区别"><a href="#四层与七层的区别" class="headerlink" title="四层与七层的区别"></a>四层与七层的区别</h2><p>区别这事儿众说纷纭，这里只是个人是一些理解</p>
<p>综合来说四层负载均衡类似于路由器，规则比较简单，所以效率较高；而七层的负载均衡是一个代理服务器，因为和客户端创建了连接，所以能拿到更多是信息，对应的实现更复杂的功能，同样的性能相对低一些</p>
<p>技术选型肯定都是结合业务场景去选择最合适的架构，没有银弹</p>
]]></content>
      <categories>
        <category>网络基础</category>
        <category>负载均衡</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>路由交换--基础</title>
    <url>/2023/05/28/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2/%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="路由的基本概念"><a href="#路由的基本概念" class="headerlink" title="路由的基本概念"></a>路由的基本概念</h1><p>互联网上数据通过IP协议进行转发传输，基于路由器、交换机、防火墙、负载均衡器等设备进行转发，这些设备上都会维护自己的路由表，通过路由表来进行IP寻址</p>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><img src="/img/image-20230606182347729.png" alt="image-20230606182347729" style="zoom: 67%;">

<ul>
<li>目的网络地址/掩码：路由指向的目的网段（注意是远端网段）</li>
<li>路由协议：Static是通过手工配置的静态路由，OSPF是一个路由协议自动学习路由信息</li>
<li>优先级：数值越小优先级越高，静态路由的默认优先级为60</li>
<li>度量值：只本条路由到达目的网段的代价值，直连路由和静态路由的默认代价值为0，不同的路由协议有自己的度量值计算方式</li>
<li>下一跳：下次转发到的路由器接口网段，可能要经过多次转发才能到达目的网段</li>
<li>出接口：数据转发出去的路由器接口</li>
</ul>
<h2 id="路由信息的来源"><a href="#路由信息的来源" class="headerlink" title="路由信息的来源"></a>路由信息的来源</h2><ul>
<li>直连路由：路由器能自动获本设备直连接口的路由并写入路由表，加载到路由表的前提是该接口的物理状态和协议状态，也就是说即使物理接线也可以通过禁用协议来屏蔽该接口路由</li>
<li>静态路由：直连路由不能发现远端网络，可以手动配置，弊端是互联网结构复杂工作量太大且不能灵活变通</li>
<li>动态路由：通过动态路由设备间可以交互信息自动计算和发现网络中的路由</li>
</ul>
<h2 id="路由优先级"><a href="#路由优先级" class="headerlink" title="路由优先级"></a>路由优先级</h2><img src="/img/image-20230606184225751.png" alt="image-20230606184225751" style="zoom:50%;">

<p>图中，R2可以通过R1或者R3到达1.1.1.0/24网段，但是由于OSPF协议优先级高于RIP，所以R2最终选择通过R3进行转发</p>
<h2 id="路由度量值"><a href="#路由度量值" class="headerlink" title="路由度量值"></a>路由度量值</h2><p>之前说过，直连和静态路由的度量值都是0，因为是直连所以不用中间转发，所以认为没有开销；不同动态路由协议对度量值的计算方式不同，比如RIP是通过转发跳数作为度量值，而OSPF则以链路带宽资源作为度量值</p>
<img src="/img/image-20230606185036320.png" alt="image-20230606185036320" style="zoom:50%;">

<p>综合来说，路由器可以通过多种途径获得路由信息，当路由协议不同时，会通过优先级来选路，同协议下通过度量值来选路，当然这只是一个基础的思路，实际上像OSPF或者BGP等在路由选优时策略更为复杂</p>
<h1 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h1><p>静态路由就是手动配置的路由，本身概念非常简单，这里举一个配置的案例</p>
<h2 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h2><img src="/img/image-20230606190109027.png" alt="image-20230606190109027" style="zoom: 50%;">

<h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>如图所示，当R1和R2都没有开启动态路由时，我们为两个PC设置网卡IP地址和默认网关地址（直连路由器接口的IP地址），两个路由会探测到他们直连设备的路由信息</p>
<p>此时让PC1发送数据给PC2，也就是192.168.1.1/24发送到192.168.2.1/24，首先PC1的本地网卡会对目标IP地址和掩码进行运算，发现不是局域网地址不能通过二层转发达到，所以将报文发送给默认网关也就是R1，此时R1上有R2的路由（192.168.12.2/24），但是没有PC2网段的路由，所以数据包被丢弃</p>
<h3 id="在R1配置静态路由"><a href="#在R1配置静态路由" class="headerlink" title="在R1配置静态路由"></a>在R1配置静态路由</h3><p>在R1上配置到192.168.2.1/24的路由</p>
<blockquote>
<p>ip route-static 192.168.2.0 24 GE0/0/0 192.168.12.2</p>
</blockquote>
<p>当PC1将数据包发送给R1时，R1就知道通过R2可以达到该网段，所以此时数据可以被发送到PC2，但是此时PC1和PC2还是不能正常通信，因为双向通信要双向路径可达，PC2回复PC1的数据无法转发成功</p>
<h3 id="在R2配置静态路由"><a href="#在R2配置静态路由" class="headerlink" title="在R2配置静态路由"></a>在R2配置静态路由</h3><p>在R2上做R1差不多的配置，这样PC1就可以ping通PC2了，通过这个案例可以看出，在最简单的网络模型下通过静态路由配置是没问题的，但实际的网络是非常复杂的，还是需要通过动态路由协议来配置路由</p>
<h2 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h2><img src="/img/image-20230606192612448.png" alt="image-20230606192612448" style="zoom:50%;">

<p>上图中是三种接口类型</p>
<h3 id="BMA广播型多路访问"><a href="#BMA广播型多路访问" class="headerlink" title="BMA广播型多路访问"></a>BMA广播型多路访问</h3><p>图中R1到R2，由于中间接入了一个交换机，所以此时从GE0/0/0接口发出的数据可以被多个目标IP段接收，此时配置到2.2.2.0/24网段的静态路由需要明确指定下一跳地址为10.1.12.2，否则可能无法正常转发</p>
<p>来看一下如果不配置下一跳地址时，R1会认为2.2.2.0/24是直连网段，加上该接口是一个BMA接口，当R1向2.2.2.0/24转发数据包时（例如2.2.2.2）会从该接口广播ARP报文，R2收到这个ARP请求是不会回应的，因为它的地址不是2.2.2.2，所以此时R1无法将数据包转发到目的IP</p>
<p>但是对于这个场景，可以通过激活R2的GE0/0/0接口上的ARP代理，该接口收到对2.2.2.2的ARP请求是，由于R2直连这2.2.2.0/24网段，它会回应这个ARP请求，回复的是自己GE0/0/0接口的MAC地址，这样R1会在其ARP表中创建一个数据项，将2.2.2.2与R2的GE0/0/0接口的MAC地址进行绑定，这样R1会将数据发往R2的GE0/0/0接口，R2接收到数据后拆包发现IP在本地直连网段，于是重新封装数据帧并发给2.2.2.2</p>
<h3 id="NBMA非广播多路转发"><a href="#NBMA非广播多路转发" class="headerlink" title="NBMA非广播多路转发"></a>NBMA非广播多路转发</h3><p>图中R1到R3，通过帧中继的方式可以实现NBMA，这种接口同样可以接入多台设备，但并不支持广播，此时也是需要指定下一跳地址</p>
<h3 id="P2P点对点"><a href="#P2P点对点" class="headerlink" title="P2P点对点"></a>P2P点对点</h3><p>图中R1到R2，此时由于是一对一，所以可以不指定下一跳地址</p>
]]></content>
      <categories>
        <category>网络基础</category>
        <category>路由交换</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
        <tag>路由交换</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-10：find命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-10%EF%BC%9Afind%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find pathname -options</span><br></pre></td></tr></table></figure></li>
<li>功能：在文件树中查找文件</li>
<li>参数</li>
<li>常用命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--关键字查找--&gt;</span><br><span class="line">find ./ -name &quot;*.log&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--根据大小查找--&gt;</span><br><span class="line">find ./ -size +1000c -print</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-1：ls命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-1%EF%BC%9Als%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ls是Linux中最基础的几个命令之一，是List的一个简写；用来展示指定目录的文件夹和文件清单，默认是当前目录；</p>
<h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls [选项] [目录]</span><br></pre></td></tr></table></figure></li>
<li>功能：用于列出目标目录中的所有子目录和文件</li>
<li>常用参数<br>```<!--对all的缩写，列出所有的内容，包括.开头的隐藏文件-->
ls -a</li>
</ul>
<!--同-a，只是不列出.和..(当前目录和父目录)-->
<p>ls -A</p>
<!--展示文件的权限、所有者、大小等信息-->
<p>ls -l</p>
<!--按修改时间排序-->
<p>ls -t</p>
<!--根据大小排序-->
<p>ls -S</p>
<!--列出所有子目录-->
<p>ls -R</p>
<!--目录名称后面加/,可执行文件后面加*，这个模式方面查看-->
<p>ls -AF</p>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-2：cd命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-2%EF%BC%9Acd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Linux中最基础的命令之一，用来切换目录。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd [目录名]</span><br></pre></td></tr></table></figure></li>
<li>功能：切换到目标目录</li>
<li>常用参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--切换到根目录--&gt;</span><br><span class="line">cd /</span><br><span class="line"></span><br><span class="line">&lt;!--切换到父目录--&gt;</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">&lt;!--切换到当前用户主目录--&gt;</span><br><span class="line">cd</span><br><span class="line">cd ~</span><br><span class="line"></span><br><span class="line">&lt;!--返回进入此目录之前所在的目录--&gt;</span><br><span class="line">cd -</span><br><span class="line"></span><br><span class="line">&lt;!--把上个命令的参数作为cd参数使用,没理解啥时候能用到--&gt;</span><br><span class="line">cd !$</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-3：mkdir命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-3%EF%BC%9Amkdir%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>mkdir命令用来创建指定名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir [选项] 目录</span><br></pre></td></tr></table></figure></li>
<li>功能：创建目录</li>
<li>常用参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-m --mode  指定权限（类似chmod）</span><br><span class="line">-p --parents  递归的创建一个目录结构（子目录）</span><br><span class="line">-v --verbose  每次创建新目录都显示信息</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--递归创建目录--&gt;</span><br><span class="line">mkdir -vp scf/&#123;lib/,bin/,doc/&#123;info,product&#125;,logs/&#123;info,product&#125;,service/deploy/&#123;info,product&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--最终结构--&gt;</span><br><span class="line">scf/</span><br><span class="line"></span><br><span class="line">|-- bin</span><br><span class="line"></span><br><span class="line">|-- doc</span><br><span class="line"></span><br><span class="line">|   |-- info</span><br><span class="line"></span><br><span class="line">|   `-- product</span><br><span class="line"></span><br><span class="line">|-- lib</span><br><span class="line"></span><br><span class="line">|-- logs</span><br><span class="line"></span><br><span class="line">|   |-- info</span><br><span class="line"></span><br><span class="line">|   `-- product</span><br><span class="line"></span><br><span class="line">`-- service</span><br><span class="line"></span><br><span class="line">      `-- deploy</span><br><span class="line"></span><br><span class="line">        |-- info</span><br><span class="line"></span><br><span class="line">         `-- product</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-4：rm命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-4%EF%BC%9Arm%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>rm命令用于删除文件和目录，需要谨慎使用</p>
<h3 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h3><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm [选项] 文件</span><br></pre></td></tr></table></figure></li>
<li>功能：删除一个目录中的一个活多个文件或目录</li>
<li>常用参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f  --force 忽略不存在的文件，不给出提示</span><br><span class="line">-i  --interactive   进行交互式删除，会问你是否确认删除</span><br><span class="line">-r,R    --recursive 递归进行删除</span><br><span class="line">-v  --verbose   详细显示进行的步骤</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-5：mv命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-5%EF%BC%9Amv%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>用于移动文件或者为文件改名</p>
<h3 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h3><ul>
<li><p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv [选项] 原文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure></li>
<li><p>功能：移动文件或修改文件名</p>
</li>
<li><p>常用参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b  若需要覆盖文件，则覆盖前先进行备份</span><br><span class="line">-f  force强制，如果目标文件已存在，不会询问直接覆盖</span><br><span class="line">-l  如果目标文件已存在，询问是否覆盖</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-6：cat、nl命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-6%EF%BC%9Acat%E3%80%81nl%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>用于显示文件内容，或将几个文件连接起来显示，配合重定向符号可以拼接文件内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--打印文件，有的时候进入文件复制内容会出现编码问题--&gt;</span><br><span class="line">cat filename</span><br><span class="line">&lt;!--打印文件，显示行号--&gt;</span><br><span class="line">cat -n filename</span><br><span class="line">&lt;!--将one和two两个文件内容拼接后写入three--&gt;</span><br><span class="line">cat one.out two.out &gt; three.out</span><br></pre></td></tr></table></figure>

<h2 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h2><p>用于计算文件中的行号，与cat -n 的区别在于空行不会被加上行号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--按行号显示文件内容，空行不显示行号--&gt;</span><br><span class="line">nl filename</span><br><span class="line">&lt;!--空行也展示行号--&gt;</span><br><span class="line">nl -b a filename</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-7：more命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-7%EF%BC%9Amore%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类似cat，more命令会将内容以分页的方式显示到屏幕上</p>
<h2 id="命令简介"><a href="#命令简介" class="headerlink" title="命令简介"></a>命令简介</h2><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more file</span><br></pre></td></tr></table></figure></li>
<li>功能：便于查看文件内容</li>
<li>常用参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+n 从第几行开始显示</span><br><span class="line">-n 定义屏幕大小为几行(屏幕高度)</span><br><span class="line">+/keyword 在文档显示前搜索该字符串（keyword），然后从该字符串前两行开始显示</span><br><span class="line">-c 从顶部清屏然后显示，这个命令很有意思，不加的时候就算用-n命令定义了屏幕高度，实际展示的时候随着翻页还是会把屏幕占满，加上这个命令之后显示范围会被一直限制在-n这个高度中</span><br><span class="line">-p 通过清除窗口而不是滚屏来进行展示，和-c很像</span><br><span class="line">-s 把连续多个空行显示为一行</span><br></pre></td></tr></table></figure></li>
<li>常用操作命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空格键 向下翻页</span><br><span class="line">b   向上翻页</span><br><span class="line">Enter   向下n行，应该和vi里面是一样的</span><br><span class="line">q   退出</span><br><span class="line">v   调用vi编辑器</span><br></pre></td></tr></table></figure></li>
<li>实用案例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--目录下文件数量多时可以使用more来进行分页展示--&gt;</span><br><span class="line">ls -l | more -5</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-8：head、tail命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-8%EF%BC%9Ahead%E3%80%81tail%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head [参数] [文件]</span><br></pre></td></tr></table></figure></li>
<li>功能：将文件开头在标准输出中展示，默认是打印开头10行</li>
<li>参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-q  隐藏文件名</span><br><span class="line">-v  显示文件名</span><br><span class="line">-c  显示字节数</span><br><span class="line">-n  显示行数</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail [参数] [文件]</span><br></pre></td></tr></table></figure></li>
<li>功能：用于显示文件末尾内容，通常用来查看日志</li>
<li>参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f  循环读取</span><br><span class="line">-q  不显示处理信息</span><br><span class="line">-v  显示详细的处理信息</span><br><span class="line">-c  显示的字节数</span><br><span class="line">-n  显示行数</span><br><span class="line">-s  和f配合使用，表示刷新间隔时间秒</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每日命令 -- Day-9：which、whereis命令</title>
    <url>/2023/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/%E6%AF%8F%E6%97%A5%E5%91%BD%E4%BB%A4/Day-9%EF%BC%9Awhich%E3%80%81whereis%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">which [可执行文件]</span><br></pre></td></tr></table></figure></li>
<li>功能：which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果</li>
<li>猜测：这里假设所谓PATH变量是和Windows里面的环境变量中Path一个性质，在命令行中直接执行命令的时候都会去这个变量中寻找文件的真实位置，所以安装一个软件之后如果找不到命令那是不是可以把它的对应关系添加到Path中，前面用的一个ln命令是不是就是往PATH里面添加了关联关系，当然也可以以别名的方式放到当前$SHELL配置中去</li>
<li>参数</li>
<li>常用命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--这个是最常用到的，找到NGINX的位置就可以找到它的配置文件（一般都在一起的）--&gt;</span><br><span class="line">which nginx</span><br><span class="line">&lt;!--这个比较有意思，在普通环境下执行会返回系统中安装的Python3的位置，在进入virtualenv之后执行会返回虚拟环境下python3的位置，通过这个命令可以确认虚拟环境使用的Python版本是否是自己想要的--&gt;</span><br><span class="line">which python3</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><ul>
<li>格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whereis [二进制文件、说明文件、源代码文件]</span><br></pre></td></tr></table></figure></li>
<li>功能：whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置</li>
<li>参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b   定位可执行文件</span><br><span class="line">-m   定位帮助文件</span><br><span class="line">-s   定位源代码文件</span><br><span class="line">-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件</span><br><span class="line">-B   指定搜索可执行文件的路径</span><br><span class="line">-M   指定搜索帮助文件的路径</span><br><span class="line">-S   指定搜索源代码文件的路径</span><br></pre></td></tr></table></figure></li>
<li>对比which：whereis是在Linux的文件数据库（系统维护）中进行的搜索，速度很快，但有个问题是这个数据库的数据更新频率默认是一周一次，导致通过whereis命令进行搜索的时候值不会是绝对准确的</li>
</ul>
]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>linux</category>
        <category>每日命令</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
        <tag>linux</tag>
        <tag>每日命令</tag>
      </tags>
  </entry>
</search>
